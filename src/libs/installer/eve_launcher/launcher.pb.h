// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eve_launcher/launcher.proto

#ifndef PROTOBUF_INCLUDED_eve_5flauncher_2flauncher_2eproto
#define PROTOBUF_INCLUDED_eve_5flauncher_2flauncher_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "eve_launcher/graphics.pb.h"
#include "eve_launcher/user.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_eve_5flauncher_2flauncher_2eproto 

namespace protobuf_eve_5flauncher_2flauncher_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[47];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_eve_5flauncher_2flauncher_2eproto
namespace eve_launcher {
class Application;
class ApplicationDefaultTypeInternal;
extern ApplicationDefaultTypeInternal _Application_default_instance_;
class AssignedToExperiment;
class AssignedToExperimentDefaultTypeInternal;
extern AssignedToExperimentDefaultTypeInternal _AssignedToExperiment_default_instance_;
class BitnessWarningClosed;
class BitnessWarningClosedDefaultTypeInternal;
extern BitnessWarningClosedDefaultTypeInternal _BitnessWarningClosed_default_instance_;
class BitnessWarningShown;
class BitnessWarningShownDefaultTypeInternal;
extern BitnessWarningShownDefaultTypeInternal _BitnessWarningShown_default_instance_;
class CertificateErrorOccurred;
class CertificateErrorOccurredDefaultTypeInternal;
extern CertificateErrorOccurredDefaultTypeInternal _CertificateErrorOccurred_default_instance_;
class ClientCrashed;
class ClientCrashedDefaultTypeInternal;
extern ClientCrashedDefaultTypeInternal _ClientCrashed_default_instance_;
class ClientInitiallyLaunched;
class ClientInitiallyLaunchedDefaultTypeInternal;
extern ClientInitiallyLaunchedDefaultTypeInternal _ClientInitiallyLaunched_default_instance_;
class ClientLaunched;
class ClientLaunchedDefaultTypeInternal;
extern ClientLaunchedDefaultTypeInternal _ClientLaunched_default_instance_;
class ClientOptions;
class ClientOptionsDefaultTypeInternal;
extern ClientOptionsDefaultTypeInternal _ClientOptions_default_instance_;
class ClientShutdown;
class ClientShutdownDefaultTypeInternal;
extern ClientShutdownDefaultTypeInternal _ClientShutdown_default_instance_;
class ClientUpdateCompleted;
class ClientUpdateCompletedDefaultTypeInternal;
extern ClientUpdateCompletedDefaultTypeInternal _ClientUpdateCompleted_default_instance_;
class ClientUpdateFailed;
class ClientUpdateFailedDefaultTypeInternal;
extern ClientUpdateFailedDefaultTypeInternal _ClientUpdateFailed_default_instance_;
class ClientUpdateStarted;
class ClientUpdateStartedDefaultTypeInternal;
extern ClientUpdateStartedDefaultTypeInternal _ClientUpdateStarted_default_instance_;
class CustomWineLaunched;
class CustomWineLaunchedDefaultTypeInternal;
extern CustomWineLaunchedDefaultTypeInternal _CustomWineLaunched_default_instance_;
class DevelopmentWineLaunched;
class DevelopmentWineLaunchedDefaultTypeInternal;
extern DevelopmentWineLaunchedDefaultTypeInternal _DevelopmentWineLaunched_default_instance_;
class DownloadInterrupted;
class DownloadInterruptedDefaultTypeInternal;
extern DownloadInterruptedDefaultTypeInternal _DownloadInterrupted_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class FileUpdateFailed;
class FileUpdateFailedDefaultTypeInternal;
extern FileUpdateFailedDefaultTypeInternal _FileUpdateFailed_default_instance_;
class Host;
class HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class IPAddress;
class IPAddressDefaultTypeInternal;
extern IPAddressDefaultTypeInternal _IPAddress_default_instance_;
class Installed;
class InstalledDefaultTypeInternal;
extern InstalledDefaultTypeInternal _Installed_default_instance_;
class LauncherUpdateAccepted;
class LauncherUpdateAcceptedDefaultTypeInternal;
extern LauncherUpdateAcceptedDefaultTypeInternal _LauncherUpdateAccepted_default_instance_;
class LauncherUpdateCancelled;
class LauncherUpdateCancelledDefaultTypeInternal;
extern LauncherUpdateCancelledDefaultTypeInternal _LauncherUpdateCancelled_default_instance_;
class LauncherUpdateDownloaded;
class LauncherUpdateDownloadedDefaultTypeInternal;
extern LauncherUpdateDownloadedDefaultTypeInternal _LauncherUpdateDownloaded_default_instance_;
class LauncherUpdateFailed;
class LauncherUpdateFailedDefaultTypeInternal;
extern LauncherUpdateFailedDefaultTypeInternal _LauncherUpdateFailed_default_instance_;
class LoginButtonClicked;
class LoginButtonClickedDefaultTypeInternal;
extern LoginButtonClickedDefaultTypeInternal _LoginButtonClicked_default_instance_;
class LoginCancelled;
class LoginCancelledDefaultTypeInternal;
extern LoginCancelledDefaultTypeInternal _LoginCancelled_default_instance_;
class LoginFailed;
class LoginFailedDefaultTypeInternal;
extern LoginFailedDefaultTypeInternal _LoginFailed_default_instance_;
class LoginFlowStarted;
class LoginFlowStartedDefaultTypeInternal;
extern LoginFlowStartedDefaultTypeInternal _LoginFlowStarted_default_instance_;
class OS;
class OSDefaultTypeInternal;
extern OSDefaultTypeInternal _OS_default_instance_;
class PlayButtonClicked;
class PlayButtonClickedDefaultTypeInternal;
extern PlayButtonClickedDefaultTypeInternal _PlayButtonClicked_default_instance_;
class ReleaseWineLaunched;
class ReleaseWineLaunchedDefaultTypeInternal;
extern ReleaseWineLaunchedDefaultTypeInternal _ReleaseWineLaunched_default_instance_;
class Settings;
class SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
class Shutdown;
class ShutdownDefaultTypeInternal;
extern ShutdownDefaultTypeInternal _Shutdown_default_instance_;
class Started;
class StartedDefaultTypeInternal;
extern StartedDefaultTypeInternal _Started_default_instance_;
class SystemBrowserOpened;
class SystemBrowserOpenedDefaultTypeInternal;
extern SystemBrowserOpenedDefaultTypeInternal _SystemBrowserOpened_default_instance_;
class UiSettings;
class UiSettingsDefaultTypeInternal;
extern UiSettingsDefaultTypeInternal _UiSettings_default_instance_;
class UnpackingBundlesCompleted;
class UnpackingBundlesCompletedDefaultTypeInternal;
extern UnpackingBundlesCompletedDefaultTypeInternal _UnpackingBundlesCompleted_default_instance_;
class UnpackingBundlesFailed;
class UnpackingBundlesFailedDefaultTypeInternal;
extern UnpackingBundlesFailedDefaultTypeInternal _UnpackingBundlesFailed_default_instance_;
class UnpackingBundlesStarted;
class UnpackingBundlesStartedDefaultTypeInternal;
extern UnpackingBundlesStartedDefaultTypeInternal _UnpackingBundlesStarted_default_instance_;
class UpdateStarted;
class UpdateStartedDefaultTypeInternal;
extern UpdateStartedDefaultTypeInternal _UpdateStarted_default_instance_;
class UserAdded;
class UserAddedDefaultTypeInternal;
extern UserAddedDefaultTypeInternal _UserAdded_default_instance_;
class UserRememberToggled;
class UserRememberToggledDefaultTypeInternal;
extern UserRememberToggledDefaultTypeInternal _UserRememberToggled_default_instance_;
class UsersOnServer;
class UsersOnServerDefaultTypeInternal;
extern UsersOnServerDefaultTypeInternal _UsersOnServer_default_instance_;
class UsersRemoved;
class UsersRemovedDefaultTypeInternal;
extern UsersRemovedDefaultTypeInternal _UsersRemoved_default_instance_;
class WebLoaded;
class WebLoadedDefaultTypeInternal;
extern WebLoadedDefaultTypeInternal _WebLoaded_default_instance_;
class WebPageLoaded;
class WebPageLoadedDefaultTypeInternal;
extern WebPageLoadedDefaultTypeInternal _WebPageLoaded_default_instance_;
}  // namespace eve_launcher
namespace google {
namespace protobuf {
template<> ::eve_launcher::Application* Arena::CreateMaybeMessage<::eve_launcher::Application>(Arena*);
template<> ::eve_launcher::AssignedToExperiment* Arena::CreateMaybeMessage<::eve_launcher::AssignedToExperiment>(Arena*);
template<> ::eve_launcher::BitnessWarningClosed* Arena::CreateMaybeMessage<::eve_launcher::BitnessWarningClosed>(Arena*);
template<> ::eve_launcher::BitnessWarningShown* Arena::CreateMaybeMessage<::eve_launcher::BitnessWarningShown>(Arena*);
template<> ::eve_launcher::CertificateErrorOccurred* Arena::CreateMaybeMessage<::eve_launcher::CertificateErrorOccurred>(Arena*);
template<> ::eve_launcher::ClientCrashed* Arena::CreateMaybeMessage<::eve_launcher::ClientCrashed>(Arena*);
template<> ::eve_launcher::ClientInitiallyLaunched* Arena::CreateMaybeMessage<::eve_launcher::ClientInitiallyLaunched>(Arena*);
template<> ::eve_launcher::ClientLaunched* Arena::CreateMaybeMessage<::eve_launcher::ClientLaunched>(Arena*);
template<> ::eve_launcher::ClientOptions* Arena::CreateMaybeMessage<::eve_launcher::ClientOptions>(Arena*);
template<> ::eve_launcher::ClientShutdown* Arena::CreateMaybeMessage<::eve_launcher::ClientShutdown>(Arena*);
template<> ::eve_launcher::ClientUpdateCompleted* Arena::CreateMaybeMessage<::eve_launcher::ClientUpdateCompleted>(Arena*);
template<> ::eve_launcher::ClientUpdateFailed* Arena::CreateMaybeMessage<::eve_launcher::ClientUpdateFailed>(Arena*);
template<> ::eve_launcher::ClientUpdateStarted* Arena::CreateMaybeMessage<::eve_launcher::ClientUpdateStarted>(Arena*);
template<> ::eve_launcher::CustomWineLaunched* Arena::CreateMaybeMessage<::eve_launcher::CustomWineLaunched>(Arena*);
template<> ::eve_launcher::DevelopmentWineLaunched* Arena::CreateMaybeMessage<::eve_launcher::DevelopmentWineLaunched>(Arena*);
template<> ::eve_launcher::DownloadInterrupted* Arena::CreateMaybeMessage<::eve_launcher::DownloadInterrupted>(Arena*);
template<> ::eve_launcher::Event* Arena::CreateMaybeMessage<::eve_launcher::Event>(Arena*);
template<> ::eve_launcher::FileUpdateFailed* Arena::CreateMaybeMessage<::eve_launcher::FileUpdateFailed>(Arena*);
template<> ::eve_launcher::Host* Arena::CreateMaybeMessage<::eve_launcher::Host>(Arena*);
template<> ::eve_launcher::IPAddress* Arena::CreateMaybeMessage<::eve_launcher::IPAddress>(Arena*);
template<> ::eve_launcher::Installed* Arena::CreateMaybeMessage<::eve_launcher::Installed>(Arena*);
template<> ::eve_launcher::LauncherUpdateAccepted* Arena::CreateMaybeMessage<::eve_launcher::LauncherUpdateAccepted>(Arena*);
template<> ::eve_launcher::LauncherUpdateCancelled* Arena::CreateMaybeMessage<::eve_launcher::LauncherUpdateCancelled>(Arena*);
template<> ::eve_launcher::LauncherUpdateDownloaded* Arena::CreateMaybeMessage<::eve_launcher::LauncherUpdateDownloaded>(Arena*);
template<> ::eve_launcher::LauncherUpdateFailed* Arena::CreateMaybeMessage<::eve_launcher::LauncherUpdateFailed>(Arena*);
template<> ::eve_launcher::LoginButtonClicked* Arena::CreateMaybeMessage<::eve_launcher::LoginButtonClicked>(Arena*);
template<> ::eve_launcher::LoginCancelled* Arena::CreateMaybeMessage<::eve_launcher::LoginCancelled>(Arena*);
template<> ::eve_launcher::LoginFailed* Arena::CreateMaybeMessage<::eve_launcher::LoginFailed>(Arena*);
template<> ::eve_launcher::LoginFlowStarted* Arena::CreateMaybeMessage<::eve_launcher::LoginFlowStarted>(Arena*);
template<> ::eve_launcher::OS* Arena::CreateMaybeMessage<::eve_launcher::OS>(Arena*);
template<> ::eve_launcher::PlayButtonClicked* Arena::CreateMaybeMessage<::eve_launcher::PlayButtonClicked>(Arena*);
template<> ::eve_launcher::ReleaseWineLaunched* Arena::CreateMaybeMessage<::eve_launcher::ReleaseWineLaunched>(Arena*);
template<> ::eve_launcher::Settings* Arena::CreateMaybeMessage<::eve_launcher::Settings>(Arena*);
template<> ::eve_launcher::Shutdown* Arena::CreateMaybeMessage<::eve_launcher::Shutdown>(Arena*);
template<> ::eve_launcher::Started* Arena::CreateMaybeMessage<::eve_launcher::Started>(Arena*);
template<> ::eve_launcher::SystemBrowserOpened* Arena::CreateMaybeMessage<::eve_launcher::SystemBrowserOpened>(Arena*);
template<> ::eve_launcher::UiSettings* Arena::CreateMaybeMessage<::eve_launcher::UiSettings>(Arena*);
template<> ::eve_launcher::UnpackingBundlesCompleted* Arena::CreateMaybeMessage<::eve_launcher::UnpackingBundlesCompleted>(Arena*);
template<> ::eve_launcher::UnpackingBundlesFailed* Arena::CreateMaybeMessage<::eve_launcher::UnpackingBundlesFailed>(Arena*);
template<> ::eve_launcher::UnpackingBundlesStarted* Arena::CreateMaybeMessage<::eve_launcher::UnpackingBundlesStarted>(Arena*);
template<> ::eve_launcher::UpdateStarted* Arena::CreateMaybeMessage<::eve_launcher::UpdateStarted>(Arena*);
template<> ::eve_launcher::UserAdded* Arena::CreateMaybeMessage<::eve_launcher::UserAdded>(Arena*);
template<> ::eve_launcher::UserRememberToggled* Arena::CreateMaybeMessage<::eve_launcher::UserRememberToggled>(Arena*);
template<> ::eve_launcher::UsersOnServer* Arena::CreateMaybeMessage<::eve_launcher::UsersOnServer>(Arena*);
template<> ::eve_launcher::UsersRemoved* Arena::CreateMaybeMessage<::eve_launcher::UsersRemoved>(Arena*);
template<> ::eve_launcher::WebLoaded* Arena::CreateMaybeMessage<::eve_launcher::WebLoaded>(Arena*);
template<> ::eve_launcher::WebPageLoaded* Arena::CreateMaybeMessage<::eve_launcher::WebPageLoaded>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace eve_launcher {

enum Application_BuildTag {
  Application_BuildTag_RELEASE = 0,
  Application_BuildTag_BETA = 1,
  Application_BuildTag_DEV = 2,
  Application_BuildTag_Application_BuildTag_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_BuildTag_Application_BuildTag_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_BuildTag_IsValid(int value);
const Application_BuildTag Application_BuildTag_BuildTag_MIN = Application_BuildTag_RELEASE;
const Application_BuildTag Application_BuildTag_BuildTag_MAX = Application_BuildTag_DEV;
const int Application_BuildTag_BuildTag_ARRAYSIZE = Application_BuildTag_BuildTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_BuildTag_descriptor();
inline const ::std::string& Application_BuildTag_Name(Application_BuildTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_BuildTag_descriptor(), value);
}
inline bool Application_BuildTag_Parse(
    const ::std::string& name, Application_BuildTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_BuildTag>(
    Application_BuildTag_descriptor(), name, value);
}
enum Application_Locale {
  Application_Locale_WORLD = 0,
  Application_Locale_CHINA = 1,
  Application_Locale_Application_Locale_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_Locale_Application_Locale_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_Locale_IsValid(int value);
const Application_Locale Application_Locale_Locale_MIN = Application_Locale_WORLD;
const Application_Locale Application_Locale_Locale_MAX = Application_Locale_CHINA;
const int Application_Locale_Locale_ARRAYSIZE = Application_Locale_Locale_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_Locale_descriptor();
inline const ::std::string& Application_Locale_Name(Application_Locale value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_Locale_descriptor(), value);
}
inline bool Application_Locale_Parse(
    const ::std::string& name, Application_Locale* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_Locale>(
    Application_Locale_descriptor(), name, value);
}
enum OS_Kind {
  OS_Kind_WINDOWS = 0,
  OS_Kind_UNKNOWN = 1,
  OS_Kind_LINUX = 2,
  OS_Kind_MAC = 3,
  OS_Kind_OS_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OS_Kind_OS_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OS_Kind_IsValid(int value);
const OS_Kind OS_Kind_Kind_MIN = OS_Kind_WINDOWS;
const OS_Kind OS_Kind_Kind_MAX = OS_Kind_MAC;
const int OS_Kind_Kind_ARRAYSIZE = OS_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* OS_Kind_descriptor();
inline const ::std::string& OS_Kind_Name(OS_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    OS_Kind_descriptor(), value);
}
inline bool OS_Kind_Parse(
    const ::std::string& name, OS_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OS_Kind>(
    OS_Kind_descriptor(), name, value);
}
enum WebLoaded_Platform {
  WebLoaded_Platform_UNKNOWN = 0,
  WebLoaded_Platform_NONE = 1,
  WebLoaded_Platform_STEAM = 2,
  WebLoaded_Platform_WebLoaded_Platform_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WebLoaded_Platform_WebLoaded_Platform_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WebLoaded_Platform_IsValid(int value);
const WebLoaded_Platform WebLoaded_Platform_Platform_MIN = WebLoaded_Platform_UNKNOWN;
const WebLoaded_Platform WebLoaded_Platform_Platform_MAX = WebLoaded_Platform_STEAM;
const int WebLoaded_Platform_Platform_ARRAYSIZE = WebLoaded_Platform_Platform_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebLoaded_Platform_descriptor();
inline const ::std::string& WebLoaded_Platform_Name(WebLoaded_Platform value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebLoaded_Platform_descriptor(), value);
}
inline bool WebLoaded_Platform_Parse(
    const ::std::string& name, WebLoaded_Platform* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebLoaded_Platform>(
    WebLoaded_Platform_descriptor(), name, value);
}
enum LoginFailed_LoginErrorType {
  LoginFailed_LoginErrorType_UNKNOWN = 0,
  LoginFailed_LoginErrorType_NETWORK_ERROR = 1,
  LoginFailed_LoginErrorType_TIMEOUT = 2,
  LoginFailed_LoginErrorType_LoginFailed_LoginErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginFailed_LoginErrorType_LoginFailed_LoginErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginFailed_LoginErrorType_IsValid(int value);
const LoginFailed_LoginErrorType LoginFailed_LoginErrorType_LoginErrorType_MIN = LoginFailed_LoginErrorType_UNKNOWN;
const LoginFailed_LoginErrorType LoginFailed_LoginErrorType_LoginErrorType_MAX = LoginFailed_LoginErrorType_TIMEOUT;
const int LoginFailed_LoginErrorType_LoginErrorType_ARRAYSIZE = LoginFailed_LoginErrorType_LoginErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginFailed_LoginErrorType_descriptor();
inline const ::std::string& LoginFailed_LoginErrorType_Name(LoginFailed_LoginErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginFailed_LoginErrorType_descriptor(), value);
}
inline bool LoginFailed_LoginErrorType_Parse(
    const ::std::string& name, LoginFailed_LoginErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginFailed_LoginErrorType>(
    LoginFailed_LoginErrorType_descriptor(), name, value);
}
enum UserAdded_RememberType {
  UserAdded_RememberType_UNKNOWN = 0,
  UserAdded_RememberType_NONE = 1,
  UserAdded_RememberType_SSO_REMEMBER = 2,
  UserAdded_RememberType_UI_ALWAYS_REMEMBER = 3,
  UserAdded_RememberType_UserAdded_RememberType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserAdded_RememberType_UserAdded_RememberType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserAdded_RememberType_IsValid(int value);
const UserAdded_RememberType UserAdded_RememberType_RememberType_MIN = UserAdded_RememberType_UNKNOWN;
const UserAdded_RememberType UserAdded_RememberType_RememberType_MAX = UserAdded_RememberType_UI_ALWAYS_REMEMBER;
const int UserAdded_RememberType_RememberType_ARRAYSIZE = UserAdded_RememberType_RememberType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserAdded_RememberType_descriptor();
inline const ::std::string& UserAdded_RememberType_Name(UserAdded_RememberType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserAdded_RememberType_descriptor(), value);
}
inline bool UserAdded_RememberType_Parse(
    const ::std::string& name, UserAdded_RememberType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserAdded_RememberType>(
    UserAdded_RememberType_descriptor(), name, value);
}
enum PlayButtonClicked_PlayButton {
  PlayButtonClicked_PlayButton_UNKNOWN = 0,
  PlayButtonClicked_PlayButton_SINGLE_USER = 1,
  PlayButtonClicked_PlayButton_PLAY_NOW = 2,
  PlayButtonClicked_PlayButton_LAUNCH_GROUP = 3,
  PlayButtonClicked_PlayButton_PlayButtonClicked_PlayButton_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PlayButtonClicked_PlayButton_PlayButtonClicked_PlayButton_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PlayButtonClicked_PlayButton_IsValid(int value);
const PlayButtonClicked_PlayButton PlayButtonClicked_PlayButton_PlayButton_MIN = PlayButtonClicked_PlayButton_UNKNOWN;
const PlayButtonClicked_PlayButton PlayButtonClicked_PlayButton_PlayButton_MAX = PlayButtonClicked_PlayButton_LAUNCH_GROUP;
const int PlayButtonClicked_PlayButton_PlayButton_ARRAYSIZE = PlayButtonClicked_PlayButton_PlayButton_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayButtonClicked_PlayButton_descriptor();
inline const ::std::string& PlayButtonClicked_PlayButton_Name(PlayButtonClicked_PlayButton value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayButtonClicked_PlayButton_descriptor(), value);
}
inline bool PlayButtonClicked_PlayButton_Parse(
    const ::std::string& name, PlayButtonClicked_PlayButton* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayButtonClicked_PlayButton>(
    PlayButtonClicked_PlayButton_descriptor(), name, value);
}
enum LoginFlowStarted_DisplayMethod {
  LoginFlowStarted_DisplayMethod_UNKNOWN = 0,
  LoginFlowStarted_DisplayMethod_EMBEDDED_WIDGET = 1,
  LoginFlowStarted_DisplayMethod_POPUP_WINDOW = 2,
  LoginFlowStarted_DisplayMethod_LoginFlowStarted_DisplayMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginFlowStarted_DisplayMethod_LoginFlowStarted_DisplayMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginFlowStarted_DisplayMethod_IsValid(int value);
const LoginFlowStarted_DisplayMethod LoginFlowStarted_DisplayMethod_DisplayMethod_MIN = LoginFlowStarted_DisplayMethod_UNKNOWN;
const LoginFlowStarted_DisplayMethod LoginFlowStarted_DisplayMethod_DisplayMethod_MAX = LoginFlowStarted_DisplayMethod_POPUP_WINDOW;
const int LoginFlowStarted_DisplayMethod_DisplayMethod_ARRAYSIZE = LoginFlowStarted_DisplayMethod_DisplayMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginFlowStarted_DisplayMethod_descriptor();
inline const ::std::string& LoginFlowStarted_DisplayMethod_Name(LoginFlowStarted_DisplayMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginFlowStarted_DisplayMethod_descriptor(), value);
}
inline bool LoginFlowStarted_DisplayMethod_Parse(
    const ::std::string& name, LoginFlowStarted_DisplayMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginFlowStarted_DisplayMethod>(
    LoginFlowStarted_DisplayMethod_descriptor(), name, value);
}
enum FileUpdateFailed_DownloadType {
  FileUpdateFailed_DownloadType_UNKNOWN = 0,
  FileUpdateFailed_DownloadType_LAUNCHER_BINARIES = 1,
  FileUpdateFailed_DownloadType_CLIENT_BINARIES = 2,
  FileUpdateFailed_DownloadType_CLIENT_PREFETCH = 3,
  FileUpdateFailed_DownloadType_CLIENT_FULLPAYLOAD = 4,
  FileUpdateFailed_DownloadType_WINE = 5,
  FileUpdateFailed_DownloadType_FileUpdateFailed_DownloadType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FileUpdateFailed_DownloadType_FileUpdateFailed_DownloadType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FileUpdateFailed_DownloadType_IsValid(int value);
const FileUpdateFailed_DownloadType FileUpdateFailed_DownloadType_DownloadType_MIN = FileUpdateFailed_DownloadType_UNKNOWN;
const FileUpdateFailed_DownloadType FileUpdateFailed_DownloadType_DownloadType_MAX = FileUpdateFailed_DownloadType_WINE;
const int FileUpdateFailed_DownloadType_DownloadType_ARRAYSIZE = FileUpdateFailed_DownloadType_DownloadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileUpdateFailed_DownloadType_descriptor();
inline const ::std::string& FileUpdateFailed_DownloadType_Name(FileUpdateFailed_DownloadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileUpdateFailed_DownloadType_descriptor(), value);
}
inline bool FileUpdateFailed_DownloadType_Parse(
    const ::std::string& name, FileUpdateFailed_DownloadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileUpdateFailed_DownloadType>(
    FileUpdateFailed_DownloadType_descriptor(), name, value);
}
enum UnpackingBundlesFailed_UnpackingStage {
  UnpackingBundlesFailed_UnpackingStage_UNKNOWN = 0,
  UnpackingBundlesFailed_UnpackingStage_VERIFY_CHUNK = 1,
  UnpackingBundlesFailed_UnpackingStage_FILE_READ = 2,
  UnpackingBundlesFailed_UnpackingStage_SIZE_VALIDATION = 3,
  UnpackingBundlesFailed_UnpackingStage_CHECKSUM = 4,
  UnpackingBundlesFailed_UnpackingStage_UnpackingBundlesFailed_UnpackingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UnpackingBundlesFailed_UnpackingStage_UnpackingBundlesFailed_UnpackingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UnpackingBundlesFailed_UnpackingStage_IsValid(int value);
const UnpackingBundlesFailed_UnpackingStage UnpackingBundlesFailed_UnpackingStage_UnpackingStage_MIN = UnpackingBundlesFailed_UnpackingStage_UNKNOWN;
const UnpackingBundlesFailed_UnpackingStage UnpackingBundlesFailed_UnpackingStage_UnpackingStage_MAX = UnpackingBundlesFailed_UnpackingStage_CHECKSUM;
const int UnpackingBundlesFailed_UnpackingStage_UnpackingStage_ARRAYSIZE = UnpackingBundlesFailed_UnpackingStage_UnpackingStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnpackingBundlesFailed_UnpackingStage_descriptor();
inline const ::std::string& UnpackingBundlesFailed_UnpackingStage_Name(UnpackingBundlesFailed_UnpackingStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnpackingBundlesFailed_UnpackingStage_descriptor(), value);
}
inline bool UnpackingBundlesFailed_UnpackingStage_Parse(
    const ::std::string& name, UnpackingBundlesFailed_UnpackingStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnpackingBundlesFailed_UnpackingStage>(
    UnpackingBundlesFailed_UnpackingStage_descriptor(), name, value);
}
enum Bitness {
  BITNESS_UNKNOWN = 0,
  BITNESS_32 = 1,
  BITNESS_64 = 2,
  Bitness_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Bitness_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Bitness_IsValid(int value);
const Bitness Bitness_MIN = BITNESS_UNKNOWN;
const Bitness Bitness_MAX = BITNESS_64;
const int Bitness_ARRAYSIZE = Bitness_MAX + 1;

const ::google::protobuf::EnumDescriptor* Bitness_descriptor();
inline const ::std::string& Bitness_Name(Bitness value) {
  return ::google::protobuf::internal::NameOfEnum(
    Bitness_descriptor(), value);
}
inline bool Bitness_Parse(
    const ::std::string& name, Bitness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Bitness>(
    Bitness_descriptor(), name, value);
}
// ===================================================================

class ClientOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientOptions) */ {
 public:
  ClientOptions();
  virtual ~ClientOptions();

  ClientOptions(const ClientOptions& from);

  inline ClientOptions& operator=(const ClientOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientOptions(ClientOptions&& from) noexcept
    : ClientOptions() {
    *this = ::std::move(from);
  }

  inline ClientOptions& operator=(ClientOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientOptions* internal_default_instance() {
    return reinterpret_cast<const ClientOptions*>(
               &_ClientOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClientOptions* other);
  friend void swap(ClientOptions& a, ClientOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientOptions* New() const final {
    return CreateMaybeMessage<ClientOptions>(NULL);
  }

  ClientOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientOptions& from);
  void MergeFrom(const ClientOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.Bitness bitness = 1;
  void clear_bitness();
  static const int kBitnessFieldNumber = 1;
  ::eve_launcher::Bitness bitness() const;
  void set_bitness(::eve_launcher::Bitness value);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int bitness_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Application : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Application) */ {
 public:
  Application();
  virtual ~Application();

  Application(const Application& from);

  inline Application& operator=(const Application& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Application(Application&& from) noexcept
    : Application() {
    *this = ::std::move(from);
  }

  inline Application& operator=(Application&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Application& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Application* internal_default_instance() {
    return reinterpret_cast<const Application*>(
               &_Application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Application* other);
  friend void swap(Application& a, Application& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Application* New() const final {
    return CreateMaybeMessage<Application>(NULL);
  }

  Application* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Application>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Application& from);
  void MergeFrom(const Application& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Application* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Application_BuildTag BuildTag;
  static const BuildTag RELEASE =
    Application_BuildTag_RELEASE;
  static const BuildTag BETA =
    Application_BuildTag_BETA;
  static const BuildTag DEV =
    Application_BuildTag_DEV;
  static inline bool BuildTag_IsValid(int value) {
    return Application_BuildTag_IsValid(value);
  }
  static const BuildTag BuildTag_MIN =
    Application_BuildTag_BuildTag_MIN;
  static const BuildTag BuildTag_MAX =
    Application_BuildTag_BuildTag_MAX;
  static const int BuildTag_ARRAYSIZE =
    Application_BuildTag_BuildTag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildTag_descriptor() {
    return Application_BuildTag_descriptor();
  }
  static inline const ::std::string& BuildTag_Name(BuildTag value) {
    return Application_BuildTag_Name(value);
  }
  static inline bool BuildTag_Parse(const ::std::string& name,
      BuildTag* value) {
    return Application_BuildTag_Parse(name, value);
  }

  typedef Application_Locale Locale;
  static const Locale WORLD =
    Application_Locale_WORLD;
  static const Locale CHINA =
    Application_Locale_CHINA;
  static inline bool Locale_IsValid(int value) {
    return Application_Locale_IsValid(value);
  }
  static const Locale Locale_MIN =
    Application_Locale_Locale_MIN;
  static const Locale Locale_MAX =
    Application_Locale_Locale_MAX;
  static const int Locale_ARRAYSIZE =
    Application_Locale_Locale_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Locale_descriptor() {
    return Application_Locale_descriptor();
  }
  static inline const ::std::string& Locale_Name(Locale value) {
    return Application_Locale_Name(value);
  }
  static inline bool Locale_Parse(const ::std::string& name,
      Locale* value) {
    return Application_Locale_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .eve_launcher.Application.BuildTag build_tag = 2;
  void clear_build_tag();
  static const int kBuildTagFieldNumber = 2;
  ::eve_launcher::Application_BuildTag build_tag() const;
  void set_build_tag(::eve_launcher::Application_BuildTag value);

  // .eve_launcher.Application.Locale locale = 3;
  void clear_locale();
  static const int kLocaleFieldNumber = 3;
  ::eve_launcher::Application_Locale locale() const;
  void set_locale(::eve_launcher::Application_Locale value);

  // @@protoc_insertion_point(class_scope:eve_launcher.Application)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  int build_tag_;
  int locale_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IPAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.IPAddress) */ {
 public:
  IPAddress();
  virtual ~IPAddress();

  IPAddress(const IPAddress& from);

  inline IPAddress& operator=(const IPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IPAddress(IPAddress&& from) noexcept
    : IPAddress() {
    *this = ::std::move(from);
  }

  inline IPAddress& operator=(IPAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAddress& default_instance();

  enum VersionCase {
    kV4 = 1,
    kV6 = 2,
    VERSION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IPAddress* internal_default_instance() {
    return reinterpret_cast<const IPAddress*>(
               &_IPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(IPAddress* other);
  friend void swap(IPAddress& a, IPAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IPAddress* New() const final {
    return CreateMaybeMessage<IPAddress>(NULL);
  }

  IPAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IPAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IPAddress& from);
  void MergeFrom(const IPAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed32 v4 = 1;
  private:
  bool has_v4() const;
  public:
  void clear_v4();
  static const int kV4FieldNumber = 1;
  ::google::protobuf::uint32 v4() const;
  void set_v4(::google::protobuf::uint32 value);

  // bytes v6 = 2;
  private:
  bool has_v6() const;
  public:
  void clear_v6();
  static const int kV6FieldNumber = 2;
  const ::std::string& v6() const;
  void set_v6(const ::std::string& value);
  #if LANG_CXX11
  void set_v6(::std::string&& value);
  #endif
  void set_v6(const char* value);
  void set_v6(const void* value, size_t size);
  ::std::string* mutable_v6();
  ::std::string* release_v6();
  void set_allocated_v6(::std::string* v6);

  void clear_version();
  VersionCase version_case() const;
  // @@protoc_insertion_point(class_scope:eve_launcher.IPAddress)
 private:
  void set_has_v4();
  void set_has_v6();

  inline bool has_version() const;
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union VersionUnion {
    VersionUnion() {}
    ::google::protobuf::uint32 v4_;
    ::google::protobuf::internal::ArenaStringPtr v6_;
  } version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.OS) */ {
 public:
  OS();
  virtual ~OS();

  OS(const OS& from);

  inline OS& operator=(const OS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OS(OS&& from) noexcept
    : OS() {
    *this = ::std::move(from);
  }

  inline OS& operator=(OS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OS* internal_default_instance() {
    return reinterpret_cast<const OS*>(
               &_OS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(OS* other);
  friend void swap(OS& a, OS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OS* New() const final {
    return CreateMaybeMessage<OS>(NULL);
  }

  OS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OS& from);
  void MergeFrom(const OS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OS_Kind Kind;
  static const Kind WINDOWS =
    OS_Kind_WINDOWS;
  static const Kind UNKNOWN =
    OS_Kind_UNKNOWN;
  static const Kind LINUX =
    OS_Kind_LINUX;
  static const Kind MAC =
    OS_Kind_MAC;
  static inline bool Kind_IsValid(int value) {
    return OS_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    OS_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    OS_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    OS_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return OS_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return OS_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return OS_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string buildVersion = 3;
  void clear_buildversion();
  static const int kBuildVersionFieldNumber = 3;
  const ::std::string& buildversion() const;
  void set_buildversion(const ::std::string& value);
  #if LANG_CXX11
  void set_buildversion(::std::string&& value);
  #endif
  void set_buildversion(const char* value);
  void set_buildversion(const char* value, size_t size);
  ::std::string* mutable_buildversion();
  ::std::string* release_buildversion();
  void set_allocated_buildversion(::std::string* buildversion);

  // string prettyProductName = 4;
  void clear_prettyproductname();
  static const int kPrettyProductNameFieldNumber = 4;
  const ::std::string& prettyproductname() const;
  void set_prettyproductname(const ::std::string& value);
  #if LANG_CXX11
  void set_prettyproductname(::std::string&& value);
  #endif
  void set_prettyproductname(const char* value);
  void set_prettyproductname(const char* value, size_t size);
  ::std::string* mutable_prettyproductname();
  ::std::string* release_prettyproductname();
  void set_allocated_prettyproductname(::std::string* prettyproductname);

  // string processorArchitecture = 6;
  void clear_processorarchitecture();
  static const int kProcessorArchitectureFieldNumber = 6;
  const ::std::string& processorarchitecture() const;
  void set_processorarchitecture(const ::std::string& value);
  #if LANG_CXX11
  void set_processorarchitecture(::std::string&& value);
  #endif
  void set_processorarchitecture(const char* value);
  void set_processorarchitecture(const char* value, size_t size);
  ::std::string* mutable_processorarchitecture();
  ::std::string* release_processorarchitecture();
  void set_allocated_processorarchitecture(::std::string* processorarchitecture);

  // .eve_launcher.OS.Kind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::eve_launcher::OS_Kind kind() const;
  void set_kind(::eve_launcher::OS_Kind value);

  // .eve_launcher.Bitness bitness = 5;
  void clear_bitness();
  static const int kBitnessFieldNumber = 5;
  ::eve_launcher::Bitness bitness() const;
  void set_bitness(::eve_launcher::Bitness value);

  // @@protoc_insertion_point(class_scope:eve_launcher.OS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr buildversion_;
  ::google::protobuf::internal::ArenaStringPtr prettyproductname_;
  ::google::protobuf::internal::ArenaStringPtr processorarchitecture_;
  int kind_;
  int bitness_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Host : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Host) */ {
 public:
  Host();
  virtual ~Host();

  Host(const Host& from);

  inline Host& operator=(const Host& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Host(Host&& from) noexcept
    : Host() {
    *this = ::std::move(from);
  }

  inline Host& operator=(Host&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Host& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Host* internal_default_instance() {
    return reinterpret_cast<const Host*>(
               &_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Host* other);
  friend void swap(Host& a, Host& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Host* New() const final {
    return CreateMaybeMessage<Host>(NULL);
  }

  Host* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Host>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Host& from);
  void MergeFrom(const Host& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Host* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes md5_hash = 1;
  void clear_md5_hash();
  static const int kMd5HashFieldNumber = 1;
  const ::std::string& md5_hash() const;
  void set_md5_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_md5_hash(::std::string&& value);
  #endif
  void set_md5_hash(const char* value);
  void set_md5_hash(const void* value, size_t size);
  ::std::string* mutable_md5_hash();
  ::std::string* release_md5_hash();
  void set_allocated_md5_hash(::std::string* md5_hash);

  // bytes mac_address = 2;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 2;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const void* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // .eve_launcher.OS os = 4;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 4;
  private:
  const ::eve_launcher::OS& _internal_os() const;
  public:
  const ::eve_launcher::OS& os() const;
  ::eve_launcher::OS* release_os();
  ::eve_launcher::OS* mutable_os();
  void set_allocated_os(::eve_launcher::OS* os);

  // @@protoc_insertion_point(class_scope:eve_launcher.Host)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr md5_hash_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::eve_launcher::OS* os_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UsersOnServer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UsersOnServer) */ {
 public:
  UsersOnServer();
  virtual ~UsersOnServer();

  UsersOnServer(const UsersOnServer& from);

  inline UsersOnServer& operator=(const UsersOnServer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UsersOnServer(UsersOnServer&& from) noexcept
    : UsersOnServer() {
    *this = ::std::move(from);
  }

  inline UsersOnServer& operator=(UsersOnServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UsersOnServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsersOnServer* internal_default_instance() {
    return reinterpret_cast<const UsersOnServer*>(
               &_UsersOnServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(UsersOnServer* other);
  friend void swap(UsersOnServer& a, UsersOnServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UsersOnServer* New() const final {
    return CreateMaybeMessage<UsersOnServer>(NULL);
  }

  UsersOnServer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UsersOnServer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UsersOnServer& from);
  void MergeFrom(const UsersOnServer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersOnServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eve_launcher.user.Identifier user_ids = 2;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 2;
  ::eve_launcher::user::Identifier* mutable_user_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
      mutable_user_ids();
  const ::eve_launcher::user::Identifier& user_ids(int index) const;
  ::eve_launcher::user::Identifier* add_user_ids();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
      user_ids() const;

  // string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:eve_launcher.UsersOnServer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier > user_ids_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Settings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Settings) */ {
 public:
  Settings();
  virtual ~Settings();

  Settings(const Settings& from);

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(Settings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Settings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Settings* other);
  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Settings* New() const final {
    return CreateMaybeMessage<Settings>(NULL);
  }

  Settings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Settings& from);
  void MergeFrom(const Settings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Settings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string language = 1;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // bool download_everything = 2;
  void clear_download_everything();
  static const int kDownloadEverythingFieldNumber = 2;
  bool download_everything() const;
  void set_download_everything(bool value);

  // bool run_clients_with_logging = 3;
  void clear_run_clients_with_logging();
  static const int kRunClientsWithLoggingFieldNumber = 3;
  bool run_clients_with_logging() const;
  void set_run_clients_with_logging(bool value);

  // bool run_clients_with_dx9 = 4;
  void clear_run_clients_with_dx9();
  static const int kRunClientsWithDx9FieldNumber = 4;
  bool run_clients_with_dx9() const;
  void set_run_clients_with_dx9(bool value);

  // bool minimize_to_tray_on_close = 5;
  void clear_minimize_to_tray_on_close();
  static const int kMinimizeToTrayOnCloseFieldNumber = 5;
  bool minimize_to_tray_on_close() const;
  void set_minimize_to_tray_on_close(bool value);

  // bool ignore_certification_errors = 6;
  void clear_ignore_certification_errors();
  static const int kIgnoreCertificationErrorsFieldNumber = 6;
  bool ignore_certification_errors() const;
  void set_ignore_certification_errors(bool value);

  // bool use_system_configuration_for_proxy = 7;
  void clear_use_system_configuration_for_proxy();
  static const int kUseSystemConfigurationForProxyFieldNumber = 7;
  bool use_system_configuration_for_proxy() const;
  void set_use_system_configuration_for_proxy(bool value);

  // bool enable_high_dpi_scaling = 8;
  void clear_enable_high_dpi_scaling();
  static const int kEnableHighDpiScalingFieldNumber = 8;
  bool enable_high_dpi_scaling() const;
  void set_enable_high_dpi_scaling(bool value);

  // bool enable_hardware_rendering = 9;
  void clear_enable_hardware_rendering();
  static const int kEnableHardwareRenderingFieldNumber = 9;
  bool enable_hardware_rendering() const;
  void set_enable_hardware_rendering(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.Settings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  bool download_everything_;
  bool run_clients_with_logging_;
  bool run_clients_with_dx9_;
  bool minimize_to_tray_on_close_;
  bool ignore_certification_errors_;
  bool use_system_configuration_for_proxy_;
  bool enable_high_dpi_scaling_;
  bool enable_hardware_rendering_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes md5_session = 3;
  void clear_md5_session();
  static const int kMd5SessionFieldNumber = 3;
  const ::std::string& md5_session() const;
  void set_md5_session(const ::std::string& value);
  #if LANG_CXX11
  void set_md5_session(::std::string&& value);
  #endif
  void set_md5_session(const char* value);
  void set_md5_session(const void* value, size_t size);
  ::std::string* mutable_md5_session();
  ::std::string* release_md5_session();
  void set_allocated_md5_session(::std::string* md5_session);

  // bytes operatingSystemUuid = 5;
  void clear_operatingsystemuuid();
  static const int kOperatingSystemUuidFieldNumber = 5;
  const ::std::string& operatingsystemuuid() const;
  void set_operatingsystemuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_operatingsystemuuid(::std::string&& value);
  #endif
  void set_operatingsystemuuid(const char* value);
  void set_operatingsystemuuid(const void* value, size_t size);
  ::std::string* mutable_operatingsystemuuid();
  ::std::string* release_operatingsystemuuid();
  void set_allocated_operatingsystemuuid(::std::string* operatingsystemuuid);

  // .google.protobuf.Any payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_payload() const;
  public:
  const ::google::protobuf::Any& payload() const;
  ::google::protobuf::Any* release_payload();
  ::google::protobuf::Any* mutable_payload();
  void set_allocated_payload(::google::protobuf::Any* payload);

  // .eve_launcher.Application application = 4;
  bool has_application() const;
  void clear_application();
  static const int kApplicationFieldNumber = 4;
  private:
  const ::eve_launcher::Application& _internal_application() const;
  public:
  const ::eve_launcher::Application& application() const;
  ::eve_launcher::Application* release_application();
  ::eve_launcher::Application* mutable_application();
  void set_allocated_application(::eve_launcher::Application* application);

  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:eve_launcher.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr md5_session_;
  ::google::protobuf::internal::ArenaStringPtr operatingsystemuuid_;
  ::google::protobuf::Any* payload_;
  ::eve_launcher::Application* application_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Installed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Installed) */ {
 public:
  Installed();
  virtual ~Installed();

  Installed(const Installed& from);

  inline Installed& operator=(const Installed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Installed(Installed&& from) noexcept
    : Installed() {
    *this = ::std::move(from);
  }

  inline Installed& operator=(Installed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Installed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Installed* internal_default_instance() {
    return reinterpret_cast<const Installed*>(
               &_Installed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Installed* other);
  friend void swap(Installed& a, Installed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Installed* New() const final {
    return CreateMaybeMessage<Installed>(NULL);
  }

  Installed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Installed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Installed& from);
  void MergeFrom(const Installed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Installed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eve_launcher.Installed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Started : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Started) */ {
 public:
  Started();
  virtual ~Started();

  Started(const Started& from);

  inline Started& operator=(const Started& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Started(Started&& from) noexcept
    : Started() {
    *this = ::std::move(from);
  }

  inline Started& operator=(Started&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Started& default_instance();

  enum ProviderCase {
    kNoInstallerProvider = 6,
    kInstallerProvider = 7,
    PROVIDER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Started* internal_default_instance() {
    return reinterpret_cast<const Started*>(
               &_Started_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Started* other);
  friend void swap(Started& a, Started& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Started* New() const final {
    return CreateMaybeMessage<Started>(NULL);
  }

  Started* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Started>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Started& from);
  void MergeFrom(const Started& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Started* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.Host host = 2;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 2;
  private:
  const ::eve_launcher::Host& _internal_host() const;
  public:
  const ::eve_launcher::Host& host() const;
  ::eve_launcher::Host* release_host();
  ::eve_launcher::Host* mutable_host();
  void set_allocated_host(::eve_launcher::Host* host);

  // .google.protobuf.Timestamp process_start_time = 4;
  bool has_process_start_time() const;
  void clear_process_start_time();
  static const int kProcessStartTimeFieldNumber = 4;
  private:
  const ::google::protobuf::Timestamp& _internal_process_start_time() const;
  public:
  const ::google::protobuf::Timestamp& process_start_time() const;
  ::google::protobuf::Timestamp* release_process_start_time();
  ::google::protobuf::Timestamp* mutable_process_start_time();
  void set_allocated_process_start_time(::google::protobuf::Timestamp* process_start_time);

  // .eve_launcher.Settings settings = 5;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 5;
  private:
  const ::eve_launcher::Settings& _internal_settings() const;
  public:
  const ::eve_launcher::Settings& settings() const;
  ::eve_launcher::Settings* release_settings();
  ::eve_launcher::Settings* mutable_settings();
  void set_allocated_settings(::eve_launcher::Settings* settings);

  // bool started_by_updater = 8;
  void clear_started_by_updater();
  static const int kStartedByUpdaterFieldNumber = 8;
  bool started_by_updater() const;
  void set_started_by_updater(bool value);

  // bool no_installer_provider = 6;
  private:
  bool has_no_installer_provider() const;
  public:
  void clear_no_installer_provider();
  static const int kNoInstallerProviderFieldNumber = 6;
  bool no_installer_provider() const;
  void set_no_installer_provider(bool value);

  // string installer_provider = 7;
  private:
  bool has_installer_provider() const;
  public:
  void clear_installer_provider();
  static const int kInstallerProviderFieldNumber = 7;
  const ::std::string& installer_provider() const;
  void set_installer_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_installer_provider(::std::string&& value);
  #endif
  void set_installer_provider(const char* value);
  void set_installer_provider(const char* value, size_t size);
  ::std::string* mutable_installer_provider();
  ::std::string* release_installer_provider();
  void set_allocated_installer_provider(::std::string* installer_provider);

  void clear_provider();
  ProviderCase provider_case() const;
  // @@protoc_insertion_point(class_scope:eve_launcher.Started)
 private:
  void set_has_no_installer_provider();
  void set_has_installer_provider();

  inline bool has_provider() const;
  inline void clear_has_provider();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::Host* host_;
  ::google::protobuf::Timestamp* process_start_time_;
  ::eve_launcher::Settings* settings_;
  bool started_by_updater_;
  union ProviderUnion {
    ProviderUnion() {}
    bool no_installer_provider_;
    ::google::protobuf::internal::ArenaStringPtr installer_provider_;
  } provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UpdateStarted) */ {
 public:
  UpdateStarted();
  virtual ~UpdateStarted();

  UpdateStarted(const UpdateStarted& from);

  inline UpdateStarted& operator=(const UpdateStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateStarted(UpdateStarted&& from) noexcept
    : UpdateStarted() {
    *this = ::std::move(from);
  }

  inline UpdateStarted& operator=(UpdateStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateStarted* internal_default_instance() {
    return reinterpret_cast<const UpdateStarted*>(
               &_UpdateStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(UpdateStarted* other);
  friend void swap(UpdateStarted& a, UpdateStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateStarted* New() const final {
    return CreateMaybeMessage<UpdateStarted>(NULL);
  }

  UpdateStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateStarted& from);
  void MergeFrom(const UpdateStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 2;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 2;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // @@protoc_insertion_point(class_scope:eve_launcher.UpdateStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shutdown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.Shutdown) */ {
 public:
  Shutdown();
  virtual ~Shutdown();

  Shutdown(const Shutdown& from);

  inline Shutdown& operator=(const Shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shutdown(Shutdown&& from) noexcept
    : Shutdown() {
    *this = ::std::move(from);
  }

  inline Shutdown& operator=(Shutdown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Shutdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shutdown* internal_default_instance() {
    return reinterpret_cast<const Shutdown*>(
               &_Shutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Shutdown* other);
  friend void swap(Shutdown& a, Shutdown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shutdown* New() const final {
    return CreateMaybeMessage<Shutdown>(NULL);
  }

  Shutdown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shutdown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shutdown& from);
  void MergeFrom(const Shutdown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shutdown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eve_launcher.UsersOnServer pinned_users = 4;
  int pinned_users_size() const;
  void clear_pinned_users();
  static const int kPinnedUsersFieldNumber = 4;
  ::eve_launcher::UsersOnServer* mutable_pinned_users(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
      mutable_pinned_users();
  const ::eve_launcher::UsersOnServer& pinned_users(int index) const;
  ::eve_launcher::UsersOnServer* add_pinned_users();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
      pinned_users() const;

  // repeated .eve_launcher.UsersOnServer not_pinned_users = 5;
  int not_pinned_users_size() const;
  void clear_not_pinned_users();
  static const int kNotPinnedUsersFieldNumber = 5;
  ::eve_launcher::UsersOnServer* mutable_not_pinned_users(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
      mutable_not_pinned_users();
  const ::eve_launcher::UsersOnServer& not_pinned_users(int index) const;
  ::eve_launcher::UsersOnServer* add_not_pinned_users();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
      not_pinned_users() const;

  // int32 clients_running = 2;
  void clear_clients_running();
  static const int kClientsRunningFieldNumber = 2;
  ::google::protobuf::int32 clients_running() const;
  void set_clients_running(::google::protobuf::int32 value);

  // int32 clients_started = 3;
  void clear_clients_started();
  static const int kClientsStartedFieldNumber = 3;
  ::google::protobuf::int32 clients_started() const;
  void set_clients_started(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.Shutdown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer > pinned_users_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer > not_pinned_users_;
  ::google::protobuf::int32 clients_running_;
  ::google::protobuf::int32 clients_started_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientInitiallyLaunched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientInitiallyLaunched) */ {
 public:
  ClientInitiallyLaunched();
  virtual ~ClientInitiallyLaunched();

  ClientInitiallyLaunched(const ClientInitiallyLaunched& from);

  inline ClientInitiallyLaunched& operator=(const ClientInitiallyLaunched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientInitiallyLaunched(ClientInitiallyLaunched&& from) noexcept
    : ClientInitiallyLaunched() {
    *this = ::std::move(from);
  }

  inline ClientInitiallyLaunched& operator=(ClientInitiallyLaunched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInitiallyLaunched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientInitiallyLaunched* internal_default_instance() {
    return reinterpret_cast<const ClientInitiallyLaunched*>(
               &_ClientInitiallyLaunched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ClientInitiallyLaunched* other);
  friend void swap(ClientInitiallyLaunched& a, ClientInitiallyLaunched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientInitiallyLaunched* New() const final {
    return CreateMaybeMessage<ClientInitiallyLaunched>(NULL);
  }

  ClientInitiallyLaunched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientInitiallyLaunched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientInitiallyLaunched& from);
  void MergeFrom(const ClientInitiallyLaunched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInitiallyLaunched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // .eve_launcher.ClientOptions client_options = 3;
  bool has_client_options() const;
  void clear_client_options();
  static const int kClientOptionsFieldNumber = 3;
  private:
  const ::eve_launcher::ClientOptions& _internal_client_options() const;
  public:
  const ::eve_launcher::ClientOptions& client_options() const;
  ::eve_launcher::ClientOptions* release_client_options();
  ::eve_launcher::ClientOptions* mutable_client_options();
  void set_allocated_client_options(::eve_launcher::ClientOptions* client_options);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientInitiallyLaunched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::eve_launcher::ClientOptions* client_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientLaunched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientLaunched) */ {
 public:
  ClientLaunched();
  virtual ~ClientLaunched();

  ClientLaunched(const ClientLaunched& from);

  inline ClientLaunched& operator=(const ClientLaunched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientLaunched(ClientLaunched&& from) noexcept
    : ClientLaunched() {
    *this = ::std::move(from);
  }

  inline ClientLaunched& operator=(ClientLaunched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLaunched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientLaunched* internal_default_instance() {
    return reinterpret_cast<const ClientLaunched*>(
               &_ClientLaunched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ClientLaunched* other);
  friend void swap(ClientLaunched& a, ClientLaunched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientLaunched* New() const final {
    return CreateMaybeMessage<ClientLaunched>(NULL);
  }

  ClientLaunched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientLaunched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientLaunched& from);
  void MergeFrom(const ClientLaunched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientLaunched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // .eve_launcher.ClientOptions client_options = 3;
  bool has_client_options() const;
  void clear_client_options();
  static const int kClientOptionsFieldNumber = 3;
  private:
  const ::eve_launcher::ClientOptions& _internal_client_options() const;
  public:
  const ::eve_launcher::ClientOptions& client_options() const;
  ::eve_launcher::ClientOptions* release_client_options();
  ::eve_launcher::ClientOptions* mutable_client_options();
  void set_allocated_client_options(::eve_launcher::ClientOptions* client_options);

  // .eve_launcher.user.Identifier user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  private:
  const ::eve_launcher::user::Identifier& _internal_user_id() const;
  public:
  const ::eve_launcher::user::Identifier& user_id() const;
  ::eve_launcher::user::Identifier* release_user_id();
  ::eve_launcher::user::Identifier* mutable_user_id();
  void set_allocated_user_id(::eve_launcher::user::Identifier* user_id);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientLaunched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::eve_launcher::ClientOptions* client_options_;
  ::eve_launcher::user::Identifier* user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientCrashed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientCrashed) */ {
 public:
  ClientCrashed();
  virtual ~ClientCrashed();

  ClientCrashed(const ClientCrashed& from);

  inline ClientCrashed& operator=(const ClientCrashed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientCrashed(ClientCrashed&& from) noexcept
    : ClientCrashed() {
    *this = ::std::move(from);
  }

  inline ClientCrashed& operator=(ClientCrashed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCrashed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientCrashed* internal_default_instance() {
    return reinterpret_cast<const ClientCrashed*>(
               &_ClientCrashed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ClientCrashed* other);
  friend void swap(ClientCrashed& a, ClientCrashed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientCrashed* New() const final {
    return CreateMaybeMessage<ClientCrashed>(NULL);
  }

  ClientCrashed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientCrashed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientCrashed& from);
  void MergeFrom(const ClientCrashed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCrashed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.user.Identifier user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  private:
  const ::eve_launcher::user::Identifier& _internal_user_id() const;
  public:
  const ::eve_launcher::user::Identifier& user_id() const;
  ::eve_launcher::user::Identifier* release_user_id();
  ::eve_launcher::user::Identifier* mutable_user_id();
  void set_allocated_user_id(::eve_launcher::user::Identifier* user_id);

  // int32 exit_code = 3;
  void clear_exit_code();
  static const int kExitCodeFieldNumber = 3;
  ::google::protobuf::int32 exit_code() const;
  void set_exit_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientCrashed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::eve_launcher::user::Identifier* user_id_;
  ::google::protobuf::int32 exit_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientShutdown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientShutdown) */ {
 public:
  ClientShutdown();
  virtual ~ClientShutdown();

  ClientShutdown(const ClientShutdown& from);

  inline ClientShutdown& operator=(const ClientShutdown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientShutdown(ClientShutdown&& from) noexcept
    : ClientShutdown() {
    *this = ::std::move(from);
  }

  inline ClientShutdown& operator=(ClientShutdown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientShutdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientShutdown* internal_default_instance() {
    return reinterpret_cast<const ClientShutdown*>(
               &_ClientShutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ClientShutdown* other);
  friend void swap(ClientShutdown& a, ClientShutdown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientShutdown* New() const final {
    return CreateMaybeMessage<ClientShutdown>(NULL);
  }

  ClientShutdown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientShutdown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientShutdown& from);
  void MergeFrom(const ClientShutdown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientShutdown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.user.Identifier user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  private:
  const ::eve_launcher::user::Identifier& _internal_user_id() const;
  public:
  const ::eve_launcher::user::Identifier& user_id() const;
  ::eve_launcher::user::Identifier* release_user_id();
  ::eve_launcher::user::Identifier* mutable_user_id();
  void set_allocated_user_id(::eve_launcher::user::Identifier* user_id);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientShutdown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::eve_launcher::user::Identifier* user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseWineLaunched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ReleaseWineLaunched) */ {
 public:
  ReleaseWineLaunched();
  virtual ~ReleaseWineLaunched();

  ReleaseWineLaunched(const ReleaseWineLaunched& from);

  inline ReleaseWineLaunched& operator=(const ReleaseWineLaunched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseWineLaunched(ReleaseWineLaunched&& from) noexcept
    : ReleaseWineLaunched() {
    *this = ::std::move(from);
  }

  inline ReleaseWineLaunched& operator=(ReleaseWineLaunched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseWineLaunched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseWineLaunched* internal_default_instance() {
    return reinterpret_cast<const ReleaseWineLaunched*>(
               &_ReleaseWineLaunched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ReleaseWineLaunched* other);
  friend void swap(ReleaseWineLaunched& a, ReleaseWineLaunched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseWineLaunched* New() const final {
    return CreateMaybeMessage<ReleaseWineLaunched>(NULL);
  }

  ReleaseWineLaunched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseWineLaunched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReleaseWineLaunched& from);
  void MergeFrom(const ReleaseWineLaunched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseWineLaunched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // string wine_build = 3;
  void clear_wine_build();
  static const int kWineBuildFieldNumber = 3;
  const ::std::string& wine_build() const;
  void set_wine_build(const ::std::string& value);
  #if LANG_CXX11
  void set_wine_build(::std::string&& value);
  #endif
  void set_wine_build(const char* value);
  void set_wine_build(const char* value, size_t size);
  ::std::string* mutable_wine_build();
  ::std::string* release_wine_build();
  void set_allocated_wine_build(::std::string* wine_build);

  // .eve_launcher.OS os = 4;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 4;
  private:
  const ::eve_launcher::OS& _internal_os() const;
  public:
  const ::eve_launcher::OS& os() const;
  ::eve_launcher::OS* release_os();
  ::eve_launcher::OS* mutable_os();
  void set_allocated_os(::eve_launcher::OS* os);

  // .eve_launcher.graphics.DirectXMode directx_mode = 5;
  void clear_directx_mode();
  static const int kDirectxModeFieldNumber = 5;
  ::eve_launcher::graphics::DirectXMode directx_mode() const;
  void set_directx_mode(::eve_launcher::graphics::DirectXMode value);

  // @@protoc_insertion_point(class_scope:eve_launcher.ReleaseWineLaunched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::google::protobuf::internal::ArenaStringPtr wine_build_;
  ::eve_launcher::OS* os_;
  int directx_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DevelopmentWineLaunched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.DevelopmentWineLaunched) */ {
 public:
  DevelopmentWineLaunched();
  virtual ~DevelopmentWineLaunched();

  DevelopmentWineLaunched(const DevelopmentWineLaunched& from);

  inline DevelopmentWineLaunched& operator=(const DevelopmentWineLaunched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DevelopmentWineLaunched(DevelopmentWineLaunched&& from) noexcept
    : DevelopmentWineLaunched() {
    *this = ::std::move(from);
  }

  inline DevelopmentWineLaunched& operator=(DevelopmentWineLaunched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DevelopmentWineLaunched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DevelopmentWineLaunched* internal_default_instance() {
    return reinterpret_cast<const DevelopmentWineLaunched*>(
               &_DevelopmentWineLaunched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DevelopmentWineLaunched* other);
  friend void swap(DevelopmentWineLaunched& a, DevelopmentWineLaunched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DevelopmentWineLaunched* New() const final {
    return CreateMaybeMessage<DevelopmentWineLaunched>(NULL);
  }

  DevelopmentWineLaunched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DevelopmentWineLaunched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DevelopmentWineLaunched& from);
  void MergeFrom(const DevelopmentWineLaunched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevelopmentWineLaunched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // string wine_branch = 3;
  void clear_wine_branch();
  static const int kWineBranchFieldNumber = 3;
  const ::std::string& wine_branch() const;
  void set_wine_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_wine_branch(::std::string&& value);
  #endif
  void set_wine_branch(const char* value);
  void set_wine_branch(const char* value, size_t size);
  ::std::string* mutable_wine_branch();
  ::std::string* release_wine_branch();
  void set_allocated_wine_branch(::std::string* wine_branch);

  // string wine_build = 4;
  void clear_wine_build();
  static const int kWineBuildFieldNumber = 4;
  const ::std::string& wine_build() const;
  void set_wine_build(const ::std::string& value);
  #if LANG_CXX11
  void set_wine_build(::std::string&& value);
  #endif
  void set_wine_build(const char* value);
  void set_wine_build(const char* value, size_t size);
  ::std::string* mutable_wine_build();
  ::std::string* release_wine_build();
  void set_allocated_wine_build(::std::string* wine_build);

  // .eve_launcher.OS os = 5;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 5;
  private:
  const ::eve_launcher::OS& _internal_os() const;
  public:
  const ::eve_launcher::OS& os() const;
  ::eve_launcher::OS* release_os();
  ::eve_launcher::OS* mutable_os();
  void set_allocated_os(::eve_launcher::OS* os);

  // .eve_launcher.graphics.DirectXMode directx_mode = 6;
  void clear_directx_mode();
  static const int kDirectxModeFieldNumber = 6;
  ::eve_launcher::graphics::DirectXMode directx_mode() const;
  void set_directx_mode(::eve_launcher::graphics::DirectXMode value);

  // @@protoc_insertion_point(class_scope:eve_launcher.DevelopmentWineLaunched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::google::protobuf::internal::ArenaStringPtr wine_branch_;
  ::google::protobuf::internal::ArenaStringPtr wine_build_;
  ::eve_launcher::OS* os_;
  int directx_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomWineLaunched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.CustomWineLaunched) */ {
 public:
  CustomWineLaunched();
  virtual ~CustomWineLaunched();

  CustomWineLaunched(const CustomWineLaunched& from);

  inline CustomWineLaunched& operator=(const CustomWineLaunched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomWineLaunched(CustomWineLaunched&& from) noexcept
    : CustomWineLaunched() {
    *this = ::std::move(from);
  }

  inline CustomWineLaunched& operator=(CustomWineLaunched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomWineLaunched& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomWineLaunched* internal_default_instance() {
    return reinterpret_cast<const CustomWineLaunched*>(
               &_CustomWineLaunched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CustomWineLaunched* other);
  friend void swap(CustomWineLaunched& a, CustomWineLaunched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomWineLaunched* New() const final {
    return CreateMaybeMessage<CustomWineLaunched>(NULL);
  }

  CustomWineLaunched* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomWineLaunched>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomWineLaunched& from);
  void MergeFrom(const CustomWineLaunched& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomWineLaunched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // .eve_launcher.OS os = 3;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 3;
  private:
  const ::eve_launcher::OS& _internal_os() const;
  public:
  const ::eve_launcher::OS& os() const;
  ::eve_launcher::OS* release_os();
  ::eve_launcher::OS* mutable_os();
  void set_allocated_os(::eve_launcher::OS* os);

  // .eve_launcher.graphics.DirectXMode directx_mode = 4;
  void clear_directx_mode();
  static const int kDirectxModeFieldNumber = 4;
  ::eve_launcher::graphics::DirectXMode directx_mode() const;
  void set_directx_mode(::eve_launcher::graphics::DirectXMode value);

  // @@protoc_insertion_point(class_scope:eve_launcher.CustomWineLaunched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::eve_launcher::OS* os_;
  int directx_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientUpdateStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientUpdateStarted) */ {
 public:
  ClientUpdateStarted();
  virtual ~ClientUpdateStarted();

  ClientUpdateStarted(const ClientUpdateStarted& from);

  inline ClientUpdateStarted& operator=(const ClientUpdateStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientUpdateStarted(ClientUpdateStarted&& from) noexcept
    : ClientUpdateStarted() {
    *this = ::std::move(from);
  }

  inline ClientUpdateStarted& operator=(ClientUpdateStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientUpdateStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientUpdateStarted* internal_default_instance() {
    return reinterpret_cast<const ClientUpdateStarted*>(
               &_ClientUpdateStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ClientUpdateStarted* other);
  friend void swap(ClientUpdateStarted& a, ClientUpdateStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientUpdateStarted* New() const final {
    return CreateMaybeMessage<ClientUpdateStarted>(NULL);
  }

  ClientUpdateStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientUpdateStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientUpdateStarted& from);
  void MergeFrom(const ClientUpdateStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientUpdateStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // string target_version = 3;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 3;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientUpdateStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientUpdateCompleted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientUpdateCompleted) */ {
 public:
  ClientUpdateCompleted();
  virtual ~ClientUpdateCompleted();

  ClientUpdateCompleted(const ClientUpdateCompleted& from);

  inline ClientUpdateCompleted& operator=(const ClientUpdateCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientUpdateCompleted(ClientUpdateCompleted&& from) noexcept
    : ClientUpdateCompleted() {
    *this = ::std::move(from);
  }

  inline ClientUpdateCompleted& operator=(ClientUpdateCompleted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientUpdateCompleted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientUpdateCompleted* internal_default_instance() {
    return reinterpret_cast<const ClientUpdateCompleted*>(
               &_ClientUpdateCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ClientUpdateCompleted* other);
  friend void swap(ClientUpdateCompleted& a, ClientUpdateCompleted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientUpdateCompleted* New() const final {
    return CreateMaybeMessage<ClientUpdateCompleted>(NULL);
  }

  ClientUpdateCompleted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientUpdateCompleted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientUpdateCompleted& from);
  void MergeFrom(const ClientUpdateCompleted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientUpdateCompleted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 2;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 2;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // string target_version = 4;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 4;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // uint64 bytes_downloaded = 5;
  void clear_bytes_downloaded();
  static const int kBytesDownloadedFieldNumber = 5;
  ::google::protobuf::uint64 bytes_downloaded() const;
  void set_bytes_downloaded(::google::protobuf::uint64 value);

  // float download_speed = 3;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 3;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientUpdateCompleted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  ::google::protobuf::uint64 bytes_downloaded_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientUpdateFailed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.ClientUpdateFailed) */ {
 public:
  ClientUpdateFailed();
  virtual ~ClientUpdateFailed();

  ClientUpdateFailed(const ClientUpdateFailed& from);

  inline ClientUpdateFailed& operator=(const ClientUpdateFailed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientUpdateFailed(ClientUpdateFailed&& from) noexcept
    : ClientUpdateFailed() {
    *this = ::std::move(from);
  }

  inline ClientUpdateFailed& operator=(ClientUpdateFailed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientUpdateFailed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientUpdateFailed* internal_default_instance() {
    return reinterpret_cast<const ClientUpdateFailed*>(
               &_ClientUpdateFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ClientUpdateFailed* other);
  friend void swap(ClientUpdateFailed& a, ClientUpdateFailed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientUpdateFailed* New() const final {
    return CreateMaybeMessage<ClientUpdateFailed>(NULL);
  }

  ClientUpdateFailed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientUpdateFailed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientUpdateFailed& from);
  void MergeFrom(const ClientUpdateFailed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientUpdateFailed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_server = 3;
  void clear_target_server();
  static const int kTargetServerFieldNumber = 3;
  const ::std::string& target_server() const;
  void set_target_server(const ::std::string& value);
  #if LANG_CXX11
  void set_target_server(::std::string&& value);
  #endif
  void set_target_server(const char* value);
  void set_target_server(const char* value, size_t size);
  ::std::string* mutable_target_server();
  ::std::string* release_target_server();
  void set_allocated_target_server(::std::string* target_server);

  // uint32 error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::google::protobuf::uint32 error_code() const;
  void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.ClientUpdateFailed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_server_;
  ::google::protobuf::uint32 error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WebLoaded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.WebLoaded) */ {
 public:
  WebLoaded();
  virtual ~WebLoaded();

  WebLoaded(const WebLoaded& from);

  inline WebLoaded& operator=(const WebLoaded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WebLoaded(WebLoaded&& from) noexcept
    : WebLoaded() {
    *this = ::std::move(from);
  }

  inline WebLoaded& operator=(WebLoaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebLoaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WebLoaded* internal_default_instance() {
    return reinterpret_cast<const WebLoaded*>(
               &_WebLoaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(WebLoaded* other);
  friend void swap(WebLoaded& a, WebLoaded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WebLoaded* New() const final {
    return CreateMaybeMessage<WebLoaded>(NULL);
  }

  WebLoaded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WebLoaded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WebLoaded& from);
  void MergeFrom(const WebLoaded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebLoaded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WebLoaded_Platform Platform;
  static const Platform UNKNOWN =
    WebLoaded_Platform_UNKNOWN;
  static const Platform NONE =
    WebLoaded_Platform_NONE;
  static const Platform STEAM =
    WebLoaded_Platform_STEAM;
  static inline bool Platform_IsValid(int value) {
    return WebLoaded_Platform_IsValid(value);
  }
  static const Platform Platform_MIN =
    WebLoaded_Platform_Platform_MIN;
  static const Platform Platform_MAX =
    WebLoaded_Platform_Platform_MAX;
  static const int Platform_ARRAYSIZE =
    WebLoaded_Platform_Platform_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Platform_descriptor() {
    return WebLoaded_Platform_descriptor();
  }
  static inline const ::std::string& Platform_Name(Platform value) {
    return WebLoaded_Platform_Name(value);
  }
  static inline bool Platform_Parse(const ::std::string& name,
      Platform* value) {
    return WebLoaded_Platform_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .eve_launcher.UsersOnServer users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  ::eve_launcher::UsersOnServer* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
      mutable_users();
  const ::eve_launcher::UsersOnServer& users(int index) const;
  ::eve_launcher::UsersOnServer* add_users();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
      users() const;

  // .eve_launcher.WebLoaded.Platform launcher_started_from = 2;
  void clear_launcher_started_from();
  static const int kLauncherStartedFromFieldNumber = 2;
  ::eve_launcher::WebLoaded_Platform launcher_started_from() const;
  void set_launcher_started_from(::eve_launcher::WebLoaded_Platform value);

  // @@protoc_insertion_point(class_scope:eve_launcher.WebLoaded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer > users_;
  int launcher_started_from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginCancelled : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LoginCancelled) */ {
 public:
  LoginCancelled();
  virtual ~LoginCancelled();

  LoginCancelled(const LoginCancelled& from);

  inline LoginCancelled& operator=(const LoginCancelled& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginCancelled(LoginCancelled&& from) noexcept
    : LoginCancelled() {
    *this = ::std::move(from);
  }

  inline LoginCancelled& operator=(LoginCancelled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginCancelled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginCancelled* internal_default_instance() {
    return reinterpret_cast<const LoginCancelled*>(
               &_LoginCancelled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(LoginCancelled* other);
  friend void swap(LoginCancelled& a, LoginCancelled& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginCancelled* New() const final {
    return CreateMaybeMessage<LoginCancelled>(NULL);
  }

  LoginCancelled* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginCancelled>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginCancelled& from);
  void MergeFrom(const LoginCancelled& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginCancelled* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eve_launcher.LoginCancelled)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginFailed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LoginFailed) */ {
 public:
  LoginFailed();
  virtual ~LoginFailed();

  LoginFailed(const LoginFailed& from);

  inline LoginFailed& operator=(const LoginFailed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginFailed(LoginFailed&& from) noexcept
    : LoginFailed() {
    *this = ::std::move(from);
  }

  inline LoginFailed& operator=(LoginFailed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginFailed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginFailed* internal_default_instance() {
    return reinterpret_cast<const LoginFailed*>(
               &_LoginFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(LoginFailed* other);
  friend void swap(LoginFailed& a, LoginFailed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginFailed* New() const final {
    return CreateMaybeMessage<LoginFailed>(NULL);
  }

  LoginFailed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginFailed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginFailed& from);
  void MergeFrom(const LoginFailed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginFailed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginFailed_LoginErrorType LoginErrorType;
  static const LoginErrorType UNKNOWN =
    LoginFailed_LoginErrorType_UNKNOWN;
  static const LoginErrorType NETWORK_ERROR =
    LoginFailed_LoginErrorType_NETWORK_ERROR;
  static const LoginErrorType TIMEOUT =
    LoginFailed_LoginErrorType_TIMEOUT;
  static inline bool LoginErrorType_IsValid(int value) {
    return LoginFailed_LoginErrorType_IsValid(value);
  }
  static const LoginErrorType LoginErrorType_MIN =
    LoginFailed_LoginErrorType_LoginErrorType_MIN;
  static const LoginErrorType LoginErrorType_MAX =
    LoginFailed_LoginErrorType_LoginErrorType_MAX;
  static const int LoginErrorType_ARRAYSIZE =
    LoginFailed_LoginErrorType_LoginErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoginErrorType_descriptor() {
    return LoginFailed_LoginErrorType_descriptor();
  }
  static inline const ::std::string& LoginErrorType_Name(LoginErrorType value) {
    return LoginFailed_LoginErrorType_Name(value);
  }
  static inline bool LoginErrorType_Parse(const ::std::string& name,
      LoginErrorType* value) {
    return LoginFailed_LoginErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.LoginFailed.LoginErrorType error_type = 2;
  void clear_error_type();
  static const int kErrorTypeFieldNumber = 2;
  ::eve_launcher::LoginFailed_LoginErrorType error_type() const;
  void set_error_type(::eve_launcher::LoginFailed_LoginErrorType value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LoginFailed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  int error_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserAdded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UserAdded) */ {
 public:
  UserAdded();
  virtual ~UserAdded();

  UserAdded(const UserAdded& from);

  inline UserAdded& operator=(const UserAdded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserAdded(UserAdded&& from) noexcept
    : UserAdded() {
    *this = ::std::move(from);
  }

  inline UserAdded& operator=(UserAdded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAdded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserAdded* internal_default_instance() {
    return reinterpret_cast<const UserAdded*>(
               &_UserAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(UserAdded* other);
  friend void swap(UserAdded& a, UserAdded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserAdded* New() const final {
    return CreateMaybeMessage<UserAdded>(NULL);
  }

  UserAdded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserAdded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserAdded& from);
  void MergeFrom(const UserAdded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAdded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserAdded_RememberType RememberType;
  static const RememberType UNKNOWN =
    UserAdded_RememberType_UNKNOWN;
  static const RememberType NONE =
    UserAdded_RememberType_NONE;
  static const RememberType SSO_REMEMBER =
    UserAdded_RememberType_SSO_REMEMBER;
  static const RememberType UI_ALWAYS_REMEMBER =
    UserAdded_RememberType_UI_ALWAYS_REMEMBER;
  static inline bool RememberType_IsValid(int value) {
    return UserAdded_RememberType_IsValid(value);
  }
  static const RememberType RememberType_MIN =
    UserAdded_RememberType_RememberType_MIN;
  static const RememberType RememberType_MAX =
    UserAdded_RememberType_RememberType_MAX;
  static const int RememberType_ARRAYSIZE =
    UserAdded_RememberType_RememberType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RememberType_descriptor() {
    return UserAdded_RememberType_descriptor();
  }
  static inline const ::std::string& RememberType_Name(RememberType value) {
    return UserAdded_RememberType_Name(value);
  }
  static inline bool RememberType_Parse(const ::std::string& name,
      RememberType* value) {
    return UserAdded_RememberType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string server = 2;
  void clear_server();
  static const int kServerFieldNumber = 2;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.user.Identifier user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  private:
  const ::eve_launcher::user::Identifier& _internal_user_id() const;
  public:
  const ::eve_launcher::user::Identifier& user_id() const;
  ::eve_launcher::user::Identifier* release_user_id();
  ::eve_launcher::user::Identifier* mutable_user_id();
  void set_allocated_user_id(::eve_launcher::user::Identifier* user_id);

  // .eve_launcher.UserAdded.RememberType remember_type = 3;
  void clear_remember_type();
  static const int kRememberTypeFieldNumber = 3;
  ::eve_launcher::UserAdded_RememberType remember_type() const;
  void set_remember_type(::eve_launcher::UserAdded_RememberType value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UserAdded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::eve_launcher::user::Identifier* user_id_;
  int remember_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UsersRemoved : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UsersRemoved) */ {
 public:
  UsersRemoved();
  virtual ~UsersRemoved();

  UsersRemoved(const UsersRemoved& from);

  inline UsersRemoved& operator=(const UsersRemoved& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UsersRemoved(UsersRemoved&& from) noexcept
    : UsersRemoved() {
    *this = ::std::move(from);
  }

  inline UsersRemoved& operator=(UsersRemoved&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UsersRemoved& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsersRemoved* internal_default_instance() {
    return reinterpret_cast<const UsersRemoved*>(
               &_UsersRemoved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(UsersRemoved* other);
  friend void swap(UsersRemoved& a, UsersRemoved& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UsersRemoved* New() const final {
    return CreateMaybeMessage<UsersRemoved>(NULL);
  }

  UsersRemoved* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UsersRemoved>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UsersRemoved& from);
  void MergeFrom(const UsersRemoved& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersRemoved* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eve_launcher.user.Identifier user_ids = 1;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 1;
  ::eve_launcher::user::Identifier* mutable_user_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
      mutable_user_ids();
  const ::eve_launcher::user::Identifier& user_ids(int index) const;
  ::eve_launcher::user::Identifier* add_user_ids();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
      user_ids() const;

  // string server = 2;
  void clear_server();
  static const int kServerFieldNumber = 2;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:eve_launcher.UsersRemoved)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier > user_ids_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayButtonClicked : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.PlayButtonClicked) */ {
 public:
  PlayButtonClicked();
  virtual ~PlayButtonClicked();

  PlayButtonClicked(const PlayButtonClicked& from);

  inline PlayButtonClicked& operator=(const PlayButtonClicked& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayButtonClicked(PlayButtonClicked&& from) noexcept
    : PlayButtonClicked() {
    *this = ::std::move(from);
  }

  inline PlayButtonClicked& operator=(PlayButtonClicked&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayButtonClicked& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayButtonClicked* internal_default_instance() {
    return reinterpret_cast<const PlayButtonClicked*>(
               &_PlayButtonClicked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(PlayButtonClicked* other);
  friend void swap(PlayButtonClicked& a, PlayButtonClicked& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayButtonClicked* New() const final {
    return CreateMaybeMessage<PlayButtonClicked>(NULL);
  }

  PlayButtonClicked* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayButtonClicked>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayButtonClicked& from);
  void MergeFrom(const PlayButtonClicked& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayButtonClicked* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlayButtonClicked_PlayButton PlayButton;
  static const PlayButton UNKNOWN =
    PlayButtonClicked_PlayButton_UNKNOWN;
  static const PlayButton SINGLE_USER =
    PlayButtonClicked_PlayButton_SINGLE_USER;
  static const PlayButton PLAY_NOW =
    PlayButtonClicked_PlayButton_PLAY_NOW;
  static const PlayButton LAUNCH_GROUP =
    PlayButtonClicked_PlayButton_LAUNCH_GROUP;
  static inline bool PlayButton_IsValid(int value) {
    return PlayButtonClicked_PlayButton_IsValid(value);
  }
  static const PlayButton PlayButton_MIN =
    PlayButtonClicked_PlayButton_PlayButton_MIN;
  static const PlayButton PlayButton_MAX =
    PlayButtonClicked_PlayButton_PlayButton_MAX;
  static const int PlayButton_ARRAYSIZE =
    PlayButtonClicked_PlayButton_PlayButton_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlayButton_descriptor() {
    return PlayButtonClicked_PlayButton_descriptor();
  }
  static inline const ::std::string& PlayButton_Name(PlayButton value) {
    return PlayButtonClicked_PlayButton_Name(value);
  }
  static inline bool PlayButton_Parse(const ::std::string& name,
      PlayButton* value) {
    return PlayButtonClicked_PlayButton_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .eve_launcher.user.Identifier user_ids = 3;
  int user_ids_size() const;
  void clear_user_ids();
  static const int kUserIdsFieldNumber = 3;
  ::eve_launcher::user::Identifier* mutable_user_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
      mutable_user_ids();
  const ::eve_launcher::user::Identifier& user_ids(int index) const;
  ::eve_launcher::user::Identifier* add_user_ids();
  const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
      user_ids() const;

  // string server = 2;
  void clear_server();
  static const int kServerFieldNumber = 2;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.PlayButtonClicked.PlayButton source_button = 1;
  void clear_source_button();
  static const int kSourceButtonFieldNumber = 1;
  ::eve_launcher::PlayButtonClicked_PlayButton source_button() const;
  void set_source_button(::eve_launcher::PlayButtonClicked_PlayButton value);

  // @@protoc_insertion_point(class_scope:eve_launcher.PlayButtonClicked)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier > user_ids_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  int source_button_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginButtonClicked : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LoginButtonClicked) */ {
 public:
  LoginButtonClicked();
  virtual ~LoginButtonClicked();

  LoginButtonClicked(const LoginButtonClicked& from);

  inline LoginButtonClicked& operator=(const LoginButtonClicked& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginButtonClicked(LoginButtonClicked&& from) noexcept
    : LoginButtonClicked() {
    *this = ::std::move(from);
  }

  inline LoginButtonClicked& operator=(LoginButtonClicked&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginButtonClicked& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginButtonClicked* internal_default_instance() {
    return reinterpret_cast<const LoginButtonClicked*>(
               &_LoginButtonClicked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(LoginButtonClicked* other);
  friend void swap(LoginButtonClicked& a, LoginButtonClicked& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginButtonClicked* New() const final {
    return CreateMaybeMessage<LoginButtonClicked>(NULL);
  }

  LoginButtonClicked* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginButtonClicked>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginButtonClicked& from);
  void MergeFrom(const LoginButtonClicked& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginButtonClicked* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:eve_launcher.LoginButtonClicked)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BitnessWarningShown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.BitnessWarningShown) */ {
 public:
  BitnessWarningShown();
  virtual ~BitnessWarningShown();

  BitnessWarningShown(const BitnessWarningShown& from);

  inline BitnessWarningShown& operator=(const BitnessWarningShown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitnessWarningShown(BitnessWarningShown&& from) noexcept
    : BitnessWarningShown() {
    *this = ::std::move(from);
  }

  inline BitnessWarningShown& operator=(BitnessWarningShown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BitnessWarningShown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitnessWarningShown* internal_default_instance() {
    return reinterpret_cast<const BitnessWarningShown*>(
               &_BitnessWarningShown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(BitnessWarningShown* other);
  friend void swap(BitnessWarningShown& a, BitnessWarningShown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitnessWarningShown* New() const final {
    return CreateMaybeMessage<BitnessWarningShown>(NULL);
  }

  BitnessWarningShown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitnessWarningShown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitnessWarningShown& from);
  void MergeFrom(const BitnessWarningShown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitnessWarningShown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eve_launcher.BitnessWarningShown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BitnessWarningClosed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.BitnessWarningClosed) */ {
 public:
  BitnessWarningClosed();
  virtual ~BitnessWarningClosed();

  BitnessWarningClosed(const BitnessWarningClosed& from);

  inline BitnessWarningClosed& operator=(const BitnessWarningClosed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitnessWarningClosed(BitnessWarningClosed&& from) noexcept
    : BitnessWarningClosed() {
    *this = ::std::move(from);
  }

  inline BitnessWarningClosed& operator=(BitnessWarningClosed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BitnessWarningClosed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitnessWarningClosed* internal_default_instance() {
    return reinterpret_cast<const BitnessWarningClosed*>(
               &_BitnessWarningClosed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(BitnessWarningClosed* other);
  friend void swap(BitnessWarningClosed& a, BitnessWarningClosed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitnessWarningClosed* New() const final {
    return CreateMaybeMessage<BitnessWarningClosed>(NULL);
  }

  BitnessWarningClosed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitnessWarningClosed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitnessWarningClosed& from);
  void MergeFrom(const BitnessWarningClosed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitnessWarningClosed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eve_launcher.BitnessWarningClosed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WebPageLoaded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.WebPageLoaded) */ {
 public:
  WebPageLoaded();
  virtual ~WebPageLoaded();

  WebPageLoaded(const WebPageLoaded& from);

  inline WebPageLoaded& operator=(const WebPageLoaded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WebPageLoaded(WebPageLoaded&& from) noexcept
    : WebPageLoaded() {
    *this = ::std::move(from);
  }

  inline WebPageLoaded& operator=(WebPageLoaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebPageLoaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WebPageLoaded* internal_default_instance() {
    return reinterpret_cast<const WebPageLoaded*>(
               &_WebPageLoaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(WebPageLoaded* other);
  friend void swap(WebPageLoaded& a, WebPageLoaded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WebPageLoaded* New() const final {
    return CreateMaybeMessage<WebPageLoaded>(NULL);
  }

  WebPageLoaded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WebPageLoaded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WebPageLoaded& from);
  void MergeFrom(const WebPageLoaded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebPageLoaded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string start_url = 1;
  void clear_start_url();
  static const int kStartUrlFieldNumber = 1;
  const ::std::string& start_url() const;
  void set_start_url(const ::std::string& value);
  #if LANG_CXX11
  void set_start_url(::std::string&& value);
  #endif
  void set_start_url(const char* value);
  void set_start_url(const char* value, size_t size);
  ::std::string* mutable_start_url();
  ::std::string* release_start_url();
  void set_allocated_start_url(::std::string* start_url);

  // string finish_url = 2;
  void clear_finish_url();
  static const int kFinishUrlFieldNumber = 2;
  const ::std::string& finish_url() const;
  void set_finish_url(const ::std::string& value);
  #if LANG_CXX11
  void set_finish_url(::std::string&& value);
  #endif
  void set_finish_url(const char* value);
  void set_finish_url(const char* value, size_t size);
  ::std::string* mutable_finish_url();
  ::std::string* release_finish_url();
  void set_allocated_finish_url(::std::string* finish_url);

  // uint32 load_duration_milliseconds = 3;
  void clear_load_duration_milliseconds();
  static const int kLoadDurationMillisecondsFieldNumber = 3;
  ::google::protobuf::uint32 load_duration_milliseconds() const;
  void set_load_duration_milliseconds(::google::protobuf::uint32 value);

  // bool success = 4;
  void clear_success();
  static const int kSuccessFieldNumber = 4;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.WebPageLoaded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_url_;
  ::google::protobuf::internal::ArenaStringPtr finish_url_;
  ::google::protobuf::uint32 load_duration_milliseconds_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssignedToExperiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.AssignedToExperiment) */ {
 public:
  AssignedToExperiment();
  virtual ~AssignedToExperiment();

  AssignedToExperiment(const AssignedToExperiment& from);

  inline AssignedToExperiment& operator=(const AssignedToExperiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssignedToExperiment(AssignedToExperiment&& from) noexcept
    : AssignedToExperiment() {
    *this = ::std::move(from);
  }

  inline AssignedToExperiment& operator=(AssignedToExperiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignedToExperiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignedToExperiment* internal_default_instance() {
    return reinterpret_cast<const AssignedToExperiment*>(
               &_AssignedToExperiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(AssignedToExperiment* other);
  friend void swap(AssignedToExperiment& a, AssignedToExperiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssignedToExperiment* New() const final {
    return CreateMaybeMessage<AssignedToExperiment>(NULL);
  }

  AssignedToExperiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssignedToExperiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssignedToExperiment& from);
  void MergeFrom(const AssignedToExperiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignedToExperiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string group = 2;
  void clear_group();
  static const int kGroupFieldNumber = 2;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // @@protoc_insertion_point(class_scope:eve_launcher.AssignedToExperiment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginFlowStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LoginFlowStarted) */ {
 public:
  LoginFlowStarted();
  virtual ~LoginFlowStarted();

  LoginFlowStarted(const LoginFlowStarted& from);

  inline LoginFlowStarted& operator=(const LoginFlowStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginFlowStarted(LoginFlowStarted&& from) noexcept
    : LoginFlowStarted() {
    *this = ::std::move(from);
  }

  inline LoginFlowStarted& operator=(LoginFlowStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginFlowStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginFlowStarted* internal_default_instance() {
    return reinterpret_cast<const LoginFlowStarted*>(
               &_LoginFlowStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(LoginFlowStarted* other);
  friend void swap(LoginFlowStarted& a, LoginFlowStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginFlowStarted* New() const final {
    return CreateMaybeMessage<LoginFlowStarted>(NULL);
  }

  LoginFlowStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginFlowStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginFlowStarted& from);
  void MergeFrom(const LoginFlowStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginFlowStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginFlowStarted_DisplayMethod DisplayMethod;
  static const DisplayMethod UNKNOWN =
    LoginFlowStarted_DisplayMethod_UNKNOWN;
  static const DisplayMethod EMBEDDED_WIDGET =
    LoginFlowStarted_DisplayMethod_EMBEDDED_WIDGET;
  static const DisplayMethod POPUP_WINDOW =
    LoginFlowStarted_DisplayMethod_POPUP_WINDOW;
  static inline bool DisplayMethod_IsValid(int value) {
    return LoginFlowStarted_DisplayMethod_IsValid(value);
  }
  static const DisplayMethod DisplayMethod_MIN =
    LoginFlowStarted_DisplayMethod_DisplayMethod_MIN;
  static const DisplayMethod DisplayMethod_MAX =
    LoginFlowStarted_DisplayMethod_DisplayMethod_MAX;
  static const int DisplayMethod_ARRAYSIZE =
    LoginFlowStarted_DisplayMethod_DisplayMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DisplayMethod_descriptor() {
    return LoginFlowStarted_DisplayMethod_descriptor();
  }
  static inline const ::std::string& DisplayMethod_Name(DisplayMethod value) {
    return LoginFlowStarted_DisplayMethod_Name(value);
  }
  static inline bool DisplayMethod_Parse(const ::std::string& name,
      DisplayMethod* value) {
    return LoginFlowStarted_DisplayMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.LoginFlowStarted.DisplayMethod display_method = 1;
  void clear_display_method();
  static const int kDisplayMethodFieldNumber = 1;
  ::eve_launcher::LoginFlowStarted_DisplayMethod display_method() const;
  void set_display_method(::eve_launcher::LoginFlowStarted_DisplayMethod value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LoginFlowStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int display_method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemBrowserOpened : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.SystemBrowserOpened) */ {
 public:
  SystemBrowserOpened();
  virtual ~SystemBrowserOpened();

  SystemBrowserOpened(const SystemBrowserOpened& from);

  inline SystemBrowserOpened& operator=(const SystemBrowserOpened& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemBrowserOpened(SystemBrowserOpened&& from) noexcept
    : SystemBrowserOpened() {
    *this = ::std::move(from);
  }

  inline SystemBrowserOpened& operator=(SystemBrowserOpened&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemBrowserOpened& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemBrowserOpened* internal_default_instance() {
    return reinterpret_cast<const SystemBrowserOpened*>(
               &_SystemBrowserOpened_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(SystemBrowserOpened* other);
  friend void swap(SystemBrowserOpened& a, SystemBrowserOpened& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemBrowserOpened* New() const final {
    return CreateMaybeMessage<SystemBrowserOpened>(NULL);
  }

  SystemBrowserOpened* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemBrowserOpened>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SystemBrowserOpened& from);
  void MergeFrom(const SystemBrowserOpened& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemBrowserOpened* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string medium = 2;
  void clear_medium();
  static const int kMediumFieldNumber = 2;
  const ::std::string& medium() const;
  void set_medium(const ::std::string& value);
  #if LANG_CXX11
  void set_medium(::std::string&& value);
  #endif
  void set_medium(const char* value);
  void set_medium(const char* value, size_t size);
  ::std::string* mutable_medium();
  ::std::string* release_medium();
  void set_allocated_medium(::std::string* medium);

  // @@protoc_insertion_point(class_scope:eve_launcher.SystemBrowserOpened)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr medium_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileUpdateFailed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.FileUpdateFailed) */ {
 public:
  FileUpdateFailed();
  virtual ~FileUpdateFailed();

  FileUpdateFailed(const FileUpdateFailed& from);

  inline FileUpdateFailed& operator=(const FileUpdateFailed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileUpdateFailed(FileUpdateFailed&& from) noexcept
    : FileUpdateFailed() {
    *this = ::std::move(from);
  }

  inline FileUpdateFailed& operator=(FileUpdateFailed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileUpdateFailed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileUpdateFailed* internal_default_instance() {
    return reinterpret_cast<const FileUpdateFailed*>(
               &_FileUpdateFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(FileUpdateFailed* other);
  friend void swap(FileUpdateFailed& a, FileUpdateFailed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileUpdateFailed* New() const final {
    return CreateMaybeMessage<FileUpdateFailed>(NULL);
  }

  FileUpdateFailed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileUpdateFailed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileUpdateFailed& from);
  void MergeFrom(const FileUpdateFailed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileUpdateFailed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileUpdateFailed_DownloadType DownloadType;
  static const DownloadType UNKNOWN =
    FileUpdateFailed_DownloadType_UNKNOWN;
  static const DownloadType LAUNCHER_BINARIES =
    FileUpdateFailed_DownloadType_LAUNCHER_BINARIES;
  static const DownloadType CLIENT_BINARIES =
    FileUpdateFailed_DownloadType_CLIENT_BINARIES;
  static const DownloadType CLIENT_PREFETCH =
    FileUpdateFailed_DownloadType_CLIENT_PREFETCH;
  static const DownloadType CLIENT_FULLPAYLOAD =
    FileUpdateFailed_DownloadType_CLIENT_FULLPAYLOAD;
  static const DownloadType WINE =
    FileUpdateFailed_DownloadType_WINE;
  static inline bool DownloadType_IsValid(int value) {
    return FileUpdateFailed_DownloadType_IsValid(value);
  }
  static const DownloadType DownloadType_MIN =
    FileUpdateFailed_DownloadType_DownloadType_MIN;
  static const DownloadType DownloadType_MAX =
    FileUpdateFailed_DownloadType_DownloadType_MAX;
  static const int DownloadType_ARRAYSIZE =
    FileUpdateFailed_DownloadType_DownloadType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DownloadType_descriptor() {
    return FileUpdateFailed_DownloadType_descriptor();
  }
  static inline const ::std::string& DownloadType_Name(DownloadType value) {
    return FileUpdateFailed_DownloadType_Name(value);
  }
  static inline bool DownloadType_Parse(const ::std::string& name,
      DownloadType* value) {
    return FileUpdateFailed_DownloadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string url = 3;
  void clear_url();
  static const int kUrlFieldNumber = 3;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // uint32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 error_code() const;
  void set_error_code(::google::protobuf::uint32 value);

  // bool rescheduled = 2;
  void clear_rescheduled();
  static const int kRescheduledFieldNumber = 2;
  bool rescheduled() const;
  void set_rescheduled(bool value);

  // .eve_launcher.FileUpdateFailed.DownloadType download_type = 4;
  void clear_download_type();
  static const int kDownloadTypeFieldNumber = 4;
  ::eve_launcher::FileUpdateFailed_DownloadType download_type() const;
  void set_download_type(::eve_launcher::FileUpdateFailed_DownloadType value);

  // float download_speed = 5;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 5;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.FileUpdateFailed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint32 error_code_;
  bool rescheduled_;
  int download_type_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DownloadInterrupted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.DownloadInterrupted) */ {
 public:
  DownloadInterrupted();
  virtual ~DownloadInterrupted();

  DownloadInterrupted(const DownloadInterrupted& from);

  inline DownloadInterrupted& operator=(const DownloadInterrupted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DownloadInterrupted(DownloadInterrupted&& from) noexcept
    : DownloadInterrupted() {
    *this = ::std::move(from);
  }

  inline DownloadInterrupted& operator=(DownloadInterrupted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadInterrupted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadInterrupted* internal_default_instance() {
    return reinterpret_cast<const DownloadInterrupted*>(
               &_DownloadInterrupted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(DownloadInterrupted* other);
  friend void swap(DownloadInterrupted& a, DownloadInterrupted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DownloadInterrupted* New() const final {
    return CreateMaybeMessage<DownloadInterrupted>(NULL);
  }

  DownloadInterrupted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DownloadInterrupted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DownloadInterrupted& from);
  void MergeFrom(const DownloadInterrupted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadInterrupted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 2;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 2;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // uint64 bytes_downloaded = 3;
  void clear_bytes_downloaded();
  static const int kBytesDownloadedFieldNumber = 3;
  ::google::protobuf::uint64 bytes_downloaded() const;
  void set_bytes_downloaded(::google::protobuf::uint64 value);

  // float download_speed = 1;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 1;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.DownloadInterrupted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  ::google::protobuf::uint64 bytes_downloaded_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LauncherUpdateDownloaded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LauncherUpdateDownloaded) */ {
 public:
  LauncherUpdateDownloaded();
  virtual ~LauncherUpdateDownloaded();

  LauncherUpdateDownloaded(const LauncherUpdateDownloaded& from);

  inline LauncherUpdateDownloaded& operator=(const LauncherUpdateDownloaded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LauncherUpdateDownloaded(LauncherUpdateDownloaded&& from) noexcept
    : LauncherUpdateDownloaded() {
    *this = ::std::move(from);
  }

  inline LauncherUpdateDownloaded& operator=(LauncherUpdateDownloaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LauncherUpdateDownloaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LauncherUpdateDownloaded* internal_default_instance() {
    return reinterpret_cast<const LauncherUpdateDownloaded*>(
               &_LauncherUpdateDownloaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(LauncherUpdateDownloaded* other);
  friend void swap(LauncherUpdateDownloaded& a, LauncherUpdateDownloaded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LauncherUpdateDownloaded* New() const final {
    return CreateMaybeMessage<LauncherUpdateDownloaded>(NULL);
  }

  LauncherUpdateDownloaded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LauncherUpdateDownloaded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LauncherUpdateDownloaded& from);
  void MergeFrom(const LauncherUpdateDownloaded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LauncherUpdateDownloaded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 1;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 1;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // float download_speed = 2;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 2;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LauncherUpdateDownloaded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LauncherUpdateFailed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LauncherUpdateFailed) */ {
 public:
  LauncherUpdateFailed();
  virtual ~LauncherUpdateFailed();

  LauncherUpdateFailed(const LauncherUpdateFailed& from);

  inline LauncherUpdateFailed& operator=(const LauncherUpdateFailed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LauncherUpdateFailed(LauncherUpdateFailed&& from) noexcept
    : LauncherUpdateFailed() {
    *this = ::std::move(from);
  }

  inline LauncherUpdateFailed& operator=(LauncherUpdateFailed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LauncherUpdateFailed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LauncherUpdateFailed* internal_default_instance() {
    return reinterpret_cast<const LauncherUpdateFailed*>(
               &_LauncherUpdateFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(LauncherUpdateFailed* other);
  friend void swap(LauncherUpdateFailed& a, LauncherUpdateFailed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LauncherUpdateFailed* New() const final {
    return CreateMaybeMessage<LauncherUpdateFailed>(NULL);
  }

  LauncherUpdateFailed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LauncherUpdateFailed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LauncherUpdateFailed& from);
  void MergeFrom(const LauncherUpdateFailed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LauncherUpdateFailed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 2;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 2;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // uint32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::uint32 error_code() const;
  void set_error_code(::google::protobuf::uint32 value);

  // float download_speed = 3;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 3;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LauncherUpdateFailed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  ::google::protobuf::uint32 error_code_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UiSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UiSettings) */ {
 public:
  UiSettings();
  virtual ~UiSettings();

  UiSettings(const UiSettings& from);

  inline UiSettings& operator=(const UiSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UiSettings(UiSettings&& from) noexcept
    : UiSettings() {
    *this = ::std::move(from);
  }

  inline UiSettings& operator=(UiSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UiSettings* internal_default_instance() {
    return reinterpret_cast<const UiSettings*>(
               &_UiSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(UiSettings* other);
  friend void swap(UiSettings& a, UiSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UiSettings* New() const final {
    return CreateMaybeMessage<UiSettings>(NULL);
  }

  UiSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UiSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UiSettings& from);
  void MergeFrom(const UiSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UiSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 startup_delay_seconds = 3;
  void clear_startup_delay_seconds();
  static const int kStartupDelaySecondsFieldNumber = 3;
  ::google::protobuf::uint32 startup_delay_seconds() const;
  void set_startup_delay_seconds(::google::protobuf::uint32 value);

  // bool settings_changed = 1;
  void clear_settings_changed();
  static const int kSettingsChangedFieldNumber = 1;
  bool settings_changed() const;
  void set_settings_changed(bool value);

  // bool start_client_on_login = 2;
  void clear_start_client_on_login();
  static const int kStartClientOnLoginFieldNumber = 2;
  bool start_client_on_login() const;
  void set_start_client_on_login(bool value);

  // bool remember_accounts = 4;
  void clear_remember_accounts();
  static const int kRememberAccountsFieldNumber = 4;
  bool remember_accounts() const;
  void set_remember_accounts(bool value);

  // bool debug_logs_enabled = 5;
  void clear_debug_logs_enabled();
  static const int kDebugLogsEnabledFieldNumber = 5;
  bool debug_logs_enabled() const;
  void set_debug_logs_enabled(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UiSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 startup_delay_seconds_;
  bool settings_changed_;
  bool start_client_on_login_;
  bool remember_accounts_;
  bool debug_logs_enabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRememberToggled : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UserRememberToggled) */ {
 public:
  UserRememberToggled();
  virtual ~UserRememberToggled();

  UserRememberToggled(const UserRememberToggled& from);

  inline UserRememberToggled& operator=(const UserRememberToggled& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRememberToggled(UserRememberToggled&& from) noexcept
    : UserRememberToggled() {
    *this = ::std::move(from);
  }

  inline UserRememberToggled& operator=(UserRememberToggled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRememberToggled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRememberToggled* internal_default_instance() {
    return reinterpret_cast<const UserRememberToggled*>(
               &_UserRememberToggled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(UserRememberToggled* other);
  friend void swap(UserRememberToggled& a, UserRememberToggled& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRememberToggled* New() const final {
    return CreateMaybeMessage<UserRememberToggled>(NULL);
  }

  UserRememberToggled* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRememberToggled>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRememberToggled& from);
  void MergeFrom(const UserRememberToggled& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRememberToggled* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string server = 2;
  void clear_server();
  static const int kServerFieldNumber = 2;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  #if LANG_CXX11
  void set_server(::std::string&& value);
  #endif
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // .eve_launcher.user.Identifier user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  private:
  const ::eve_launcher::user::Identifier& _internal_user_id() const;
  public:
  const ::eve_launcher::user::Identifier& user_id() const;
  ::eve_launcher::user::Identifier* release_user_id();
  ::eve_launcher::user::Identifier* mutable_user_id();
  void set_allocated_user_id(::eve_launcher::user::Identifier* user_id);

  // bool remember_enabled = 3;
  void clear_remember_enabled();
  static const int kRememberEnabledFieldNumber = 3;
  bool remember_enabled() const;
  void set_remember_enabled(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UserRememberToggled)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::eve_launcher::user::Identifier* user_id_;
  bool remember_enabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LauncherUpdateCancelled : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LauncherUpdateCancelled) */ {
 public:
  LauncherUpdateCancelled();
  virtual ~LauncherUpdateCancelled();

  LauncherUpdateCancelled(const LauncherUpdateCancelled& from);

  inline LauncherUpdateCancelled& operator=(const LauncherUpdateCancelled& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LauncherUpdateCancelled(LauncherUpdateCancelled&& from) noexcept
    : LauncherUpdateCancelled() {
    *this = ::std::move(from);
  }

  inline LauncherUpdateCancelled& operator=(LauncherUpdateCancelled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LauncherUpdateCancelled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LauncherUpdateCancelled* internal_default_instance() {
    return reinterpret_cast<const LauncherUpdateCancelled*>(
               &_LauncherUpdateCancelled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(LauncherUpdateCancelled* other);
  friend void swap(LauncherUpdateCancelled& a, LauncherUpdateCancelled& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LauncherUpdateCancelled* New() const final {
    return CreateMaybeMessage<LauncherUpdateCancelled>(NULL);
  }

  LauncherUpdateCancelled* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LauncherUpdateCancelled>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LauncherUpdateCancelled& from);
  void MergeFrom(const LauncherUpdateCancelled& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LauncherUpdateCancelled* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 1;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 1;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // float download_speed = 2;
  void clear_download_speed();
  static const int kDownloadSpeedFieldNumber = 2;
  float download_speed() const;
  void set_download_speed(float value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LauncherUpdateCancelled)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  float download_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LauncherUpdateAccepted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.LauncherUpdateAccepted) */ {
 public:
  LauncherUpdateAccepted();
  virtual ~LauncherUpdateAccepted();

  LauncherUpdateAccepted(const LauncherUpdateAccepted& from);

  inline LauncherUpdateAccepted& operator=(const LauncherUpdateAccepted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LauncherUpdateAccepted(LauncherUpdateAccepted&& from) noexcept
    : LauncherUpdateAccepted() {
    *this = ::std::move(from);
  }

  inline LauncherUpdateAccepted& operator=(LauncherUpdateAccepted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LauncherUpdateAccepted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LauncherUpdateAccepted* internal_default_instance() {
    return reinterpret_cast<const LauncherUpdateAccepted*>(
               &_LauncherUpdateAccepted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(LauncherUpdateAccepted* other);
  friend void swap(LauncherUpdateAccepted& a, LauncherUpdateAccepted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LauncherUpdateAccepted* New() const final {
    return CreateMaybeMessage<LauncherUpdateAccepted>(NULL);
  }

  LauncherUpdateAccepted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LauncherUpdateAccepted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LauncherUpdateAccepted& from);
  void MergeFrom(const LauncherUpdateAccepted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LauncherUpdateAccepted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_version = 1;
  void clear_target_version();
  static const int kTargetVersionFieldNumber = 1;
  const ::std::string& target_version() const;
  void set_target_version(const ::std::string& value);
  #if LANG_CXX11
  void set_target_version(::std::string&& value);
  #endif
  void set_target_version(const char* value);
  void set_target_version(const char* value, size_t size);
  ::std::string* mutable_target_version();
  ::std::string* release_target_version();
  void set_allocated_target_version(::std::string* target_version);

  // bool automatic = 2;
  void clear_automatic();
  static const int kAutomaticFieldNumber = 2;
  bool automatic() const;
  void set_automatic(bool value);

  // bool updater_started = 3;
  void clear_updater_started();
  static const int kUpdaterStartedFieldNumber = 3;
  bool updater_started() const;
  void set_updater_started(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.LauncherUpdateAccepted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_version_;
  bool automatic_;
  bool updater_started_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CertificateErrorOccurred : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.CertificateErrorOccurred) */ {
 public:
  CertificateErrorOccurred();
  virtual ~CertificateErrorOccurred();

  CertificateErrorOccurred(const CertificateErrorOccurred& from);

  inline CertificateErrorOccurred& operator=(const CertificateErrorOccurred& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CertificateErrorOccurred(CertificateErrorOccurred&& from) noexcept
    : CertificateErrorOccurred() {
    *this = ::std::move(from);
  }

  inline CertificateErrorOccurred& operator=(CertificateErrorOccurred&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CertificateErrorOccurred& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CertificateErrorOccurred* internal_default_instance() {
    return reinterpret_cast<const CertificateErrorOccurred*>(
               &_CertificateErrorOccurred_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(CertificateErrorOccurred* other);
  friend void swap(CertificateErrorOccurred& a, CertificateErrorOccurred& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CertificateErrorOccurred* New() const final {
    return CreateMaybeMessage<CertificateErrorOccurred>(NULL);
  }

  CertificateErrorOccurred* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CertificateErrorOccurred>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CertificateErrorOccurred& from);
  void MergeFrom(const CertificateErrorOccurred& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateErrorOccurred* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // .eve_launcher.IPAddress host_ip = 2;
  bool has_host_ip() const;
  void clear_host_ip();
  static const int kHostIpFieldNumber = 2;
  private:
  const ::eve_launcher::IPAddress& _internal_host_ip() const;
  public:
  const ::eve_launcher::IPAddress& host_ip() const;
  ::eve_launcher::IPAddress* release_host_ip();
  ::eve_launcher::IPAddress* mutable_host_ip();
  void set_allocated_host_ip(::eve_launcher::IPAddress* host_ip);

  // int32 error_code = 3;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // bool user_prompted = 4;
  void clear_user_prompted();
  static const int kUserPromptedFieldNumber = 4;
  bool user_prompted() const;
  void set_user_prompted(bool value);

  // bool user_ignored = 5;
  void clear_user_ignored();
  static const int kUserIgnoredFieldNumber = 5;
  bool user_ignored() const;
  void set_user_ignored(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.CertificateErrorOccurred)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::eve_launcher::IPAddress* host_ip_;
  ::google::protobuf::int32 error_code_;
  bool user_prompted_;
  bool user_ignored_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnpackingBundlesStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UnpackingBundlesStarted) */ {
 public:
  UnpackingBundlesStarted();
  virtual ~UnpackingBundlesStarted();

  UnpackingBundlesStarted(const UnpackingBundlesStarted& from);

  inline UnpackingBundlesStarted& operator=(const UnpackingBundlesStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnpackingBundlesStarted(UnpackingBundlesStarted&& from) noexcept
    : UnpackingBundlesStarted() {
    *this = ::std::move(from);
  }

  inline UnpackingBundlesStarted& operator=(UnpackingBundlesStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnpackingBundlesStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnpackingBundlesStarted* internal_default_instance() {
    return reinterpret_cast<const UnpackingBundlesStarted*>(
               &_UnpackingBundlesStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(UnpackingBundlesStarted* other);
  friend void swap(UnpackingBundlesStarted& a, UnpackingBundlesStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnpackingBundlesStarted* New() const final {
    return CreateMaybeMessage<UnpackingBundlesStarted>(NULL);
  }

  UnpackingBundlesStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnpackingBundlesStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnpackingBundlesStarted& from);
  void MergeFrom(const UnpackingBundlesStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpackingBundlesStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 bundle_count = 1;
  void clear_bundle_count();
  static const int kBundleCountFieldNumber = 1;
  ::google::protobuf::uint32 bundle_count() const;
  void set_bundle_count(::google::protobuf::uint32 value);

  // uint32 file_count = 2;
  void clear_file_count();
  static const int kFileCountFieldNumber = 2;
  ::google::protobuf::uint32 file_count() const;
  void set_file_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UnpackingBundlesStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 bundle_count_;
  ::google::protobuf::uint32 file_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnpackingBundlesFailed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UnpackingBundlesFailed) */ {
 public:
  UnpackingBundlesFailed();
  virtual ~UnpackingBundlesFailed();

  UnpackingBundlesFailed(const UnpackingBundlesFailed& from);

  inline UnpackingBundlesFailed& operator=(const UnpackingBundlesFailed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnpackingBundlesFailed(UnpackingBundlesFailed&& from) noexcept
    : UnpackingBundlesFailed() {
    *this = ::std::move(from);
  }

  inline UnpackingBundlesFailed& operator=(UnpackingBundlesFailed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnpackingBundlesFailed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnpackingBundlesFailed* internal_default_instance() {
    return reinterpret_cast<const UnpackingBundlesFailed*>(
               &_UnpackingBundlesFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(UnpackingBundlesFailed* other);
  friend void swap(UnpackingBundlesFailed& a, UnpackingBundlesFailed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnpackingBundlesFailed* New() const final {
    return CreateMaybeMessage<UnpackingBundlesFailed>(NULL);
  }

  UnpackingBundlesFailed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnpackingBundlesFailed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnpackingBundlesFailed& from);
  void MergeFrom(const UnpackingBundlesFailed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpackingBundlesFailed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UnpackingBundlesFailed_UnpackingStage UnpackingStage;
  static const UnpackingStage UNKNOWN =
    UnpackingBundlesFailed_UnpackingStage_UNKNOWN;
  static const UnpackingStage VERIFY_CHUNK =
    UnpackingBundlesFailed_UnpackingStage_VERIFY_CHUNK;
  static const UnpackingStage FILE_READ =
    UnpackingBundlesFailed_UnpackingStage_FILE_READ;
  static const UnpackingStage SIZE_VALIDATION =
    UnpackingBundlesFailed_UnpackingStage_SIZE_VALIDATION;
  static const UnpackingStage CHECKSUM =
    UnpackingBundlesFailed_UnpackingStage_CHECKSUM;
  static inline bool UnpackingStage_IsValid(int value) {
    return UnpackingBundlesFailed_UnpackingStage_IsValid(value);
  }
  static const UnpackingStage UnpackingStage_MIN =
    UnpackingBundlesFailed_UnpackingStage_UnpackingStage_MIN;
  static const UnpackingStage UnpackingStage_MAX =
    UnpackingBundlesFailed_UnpackingStage_UnpackingStage_MAX;
  static const int UnpackingStage_ARRAYSIZE =
    UnpackingBundlesFailed_UnpackingStage_UnpackingStage_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UnpackingStage_descriptor() {
    return UnpackingBundlesFailed_UnpackingStage_descriptor();
  }
  static inline const ::std::string& UnpackingStage_Name(UnpackingStage value) {
    return UnpackingBundlesFailed_UnpackingStage_Name(value);
  }
  static inline bool UnpackingStage_Parse(const ::std::string& name,
      UnpackingStage* value) {
    return UnpackingBundlesFailed_UnpackingStage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string file_name = 1;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // .eve_launcher.UnpackingBundlesFailed.UnpackingStage stage = 2;
  void clear_stage();
  static const int kStageFieldNumber = 2;
  ::eve_launcher::UnpackingBundlesFailed_UnpackingStage stage() const;
  void set_stage(::eve_launcher::UnpackingBundlesFailed_UnpackingStage value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UnpackingBundlesFailed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  int stage_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnpackingBundlesCompleted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.UnpackingBundlesCompleted) */ {
 public:
  UnpackingBundlesCompleted();
  virtual ~UnpackingBundlesCompleted();

  UnpackingBundlesCompleted(const UnpackingBundlesCompleted& from);

  inline UnpackingBundlesCompleted& operator=(const UnpackingBundlesCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnpackingBundlesCompleted(UnpackingBundlesCompleted&& from) noexcept
    : UnpackingBundlesCompleted() {
    *this = ::std::move(from);
  }

  inline UnpackingBundlesCompleted& operator=(UnpackingBundlesCompleted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnpackingBundlesCompleted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnpackingBundlesCompleted* internal_default_instance() {
    return reinterpret_cast<const UnpackingBundlesCompleted*>(
               &_UnpackingBundlesCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(UnpackingBundlesCompleted* other);
  friend void swap(UnpackingBundlesCompleted& a, UnpackingBundlesCompleted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnpackingBundlesCompleted* New() const final {
    return CreateMaybeMessage<UnpackingBundlesCompleted>(NULL);
  }

  UnpackingBundlesCompleted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnpackingBundlesCompleted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnpackingBundlesCompleted& from);
  void MergeFrom(const UnpackingBundlesCompleted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpackingBundlesCompleted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 bundle_count = 1;
  void clear_bundle_count();
  static const int kBundleCountFieldNumber = 1;
  ::google::protobuf::uint32 bundle_count() const;
  void set_bundle_count(::google::protobuf::uint32 value);

  // uint32 file_count = 2;
  void clear_file_count();
  static const int kFileCountFieldNumber = 2;
  ::google::protobuf::uint32 file_count() const;
  void set_file_count(::google::protobuf::uint32 value);

  // uint64 extracted_byte_size = 3;
  void clear_extracted_byte_size();
  static const int kExtractedByteSizeFieldNumber = 3;
  ::google::protobuf::uint64 extracted_byte_size() const;
  void set_extracted_byte_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.UnpackingBundlesCompleted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 bundle_count_;
  ::google::protobuf::uint32 file_count_;
  ::google::protobuf::uint64 extracted_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2flauncher_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientOptions

// .eve_launcher.Bitness bitness = 1;
inline void ClientOptions::clear_bitness() {
  bitness_ = 0;
}
inline ::eve_launcher::Bitness ClientOptions::bitness() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientOptions.bitness)
  return static_cast< ::eve_launcher::Bitness >(bitness_);
}
inline void ClientOptions::set_bitness(::eve_launcher::Bitness value) {
  
  bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ClientOptions.bitness)
}

// -------------------------------------------------------------------

// Application

// string version = 1;
inline void Application::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Application::version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Application.version)
  return version_.GetNoArena();
}
inline void Application::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Application.version)
}
#if LANG_CXX11
inline void Application::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Application.version)
}
#endif
inline void Application::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Application.version)
}
inline void Application::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Application.version)
}
inline ::std::string* Application::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Application.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Application::release_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.Application.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Application::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Application.version)
}

// .eve_launcher.Application.BuildTag build_tag = 2;
inline void Application::clear_build_tag() {
  build_tag_ = 0;
}
inline ::eve_launcher::Application_BuildTag Application::build_tag() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Application.build_tag)
  return static_cast< ::eve_launcher::Application_BuildTag >(build_tag_);
}
inline void Application::set_build_tag(::eve_launcher::Application_BuildTag value) {
  
  build_tag_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Application.build_tag)
}

// .eve_launcher.Application.Locale locale = 3;
inline void Application::clear_locale() {
  locale_ = 0;
}
inline ::eve_launcher::Application_Locale Application::locale() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Application.locale)
  return static_cast< ::eve_launcher::Application_Locale >(locale_);
}
inline void Application::set_locale(::eve_launcher::Application_Locale value) {
  
  locale_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Application.locale)
}

// -------------------------------------------------------------------

// IPAddress

// fixed32 v4 = 1;
inline bool IPAddress::has_v4() const {
  return version_case() == kV4;
}
inline void IPAddress::set_has_v4() {
  _oneof_case_[0] = kV4;
}
inline void IPAddress::clear_v4() {
  if (has_v4()) {
    version_.v4_ = 0u;
    clear_has_version();
  }
}
inline ::google::protobuf::uint32 IPAddress::v4() const {
  // @@protoc_insertion_point(field_get:eve_launcher.IPAddress.v4)
  if (has_v4()) {
    return version_.v4_;
  }
  return 0u;
}
inline void IPAddress::set_v4(::google::protobuf::uint32 value) {
  if (!has_v4()) {
    clear_version();
    set_has_v4();
  }
  version_.v4_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.IPAddress.v4)
}

// bytes v6 = 2;
inline bool IPAddress::has_v6() const {
  return version_case() == kV6;
}
inline void IPAddress::set_has_v6() {
  _oneof_case_[0] = kV6;
}
inline void IPAddress::clear_v6() {
  if (has_v6()) {
    version_.v6_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_version();
  }
}
inline const ::std::string& IPAddress::v6() const {
  // @@protoc_insertion_point(field_get:eve_launcher.IPAddress.v6)
  if (has_v6()) {
    return version_.v6_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void IPAddress::set_v6(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.IPAddress.v6)
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.IPAddress.v6)
}
#if LANG_CXX11
inline void IPAddress::set_v6(::std::string&& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.IPAddress.v6)
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.IPAddress.v6)
}
#endif
inline void IPAddress::set_v6(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.IPAddress.v6)
}
inline void IPAddress::set_v6(const void* value, size_t size) {
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.IPAddress.v6)
}
inline ::std::string* IPAddress::mutable_v6() {
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.IPAddress.v6)
  return version_.v6_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IPAddress::release_v6() {
  // @@protoc_insertion_point(field_release:eve_launcher.IPAddress.v6)
  if (has_v6()) {
    clear_has_version();
    return version_.v6_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void IPAddress::set_allocated_v6(::std::string* v6) {
  if (!has_v6()) {
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_version();
  if (v6 != NULL) {
    set_has_v6();
    version_.v6_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), v6);
  }
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.IPAddress.v6)
}

inline bool IPAddress::has_version() const {
  return version_case() != VERSION_NOT_SET;
}
inline void IPAddress::clear_has_version() {
  _oneof_case_[0] = VERSION_NOT_SET;
}
inline IPAddress::VersionCase IPAddress::version_case() const {
  return IPAddress::VersionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OS

// .eve_launcher.OS.Kind kind = 1;
inline void OS::clear_kind() {
  kind_ = 0;
}
inline ::eve_launcher::OS_Kind OS::kind() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.kind)
  return static_cast< ::eve_launcher::OS_Kind >(kind_);
}
inline void OS::set_kind(::eve_launcher::OS_Kind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.OS.kind)
}

// string version = 2;
inline void OS::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.version)
  return version_.GetNoArena();
}
inline void OS::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.OS.version)
}
#if LANG_CXX11
inline void OS::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.OS.version)
}
#endif
inline void OS::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.OS.version)
}
inline void OS::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.OS.version)
}
inline ::std::string* OS::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.OS.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.OS.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.OS.version)
}

// string buildVersion = 3;
inline void OS::clear_buildversion() {
  buildversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::buildversion() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.buildVersion)
  return buildversion_.GetNoArena();
}
inline void OS::set_buildversion(const ::std::string& value) {
  
  buildversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.OS.buildVersion)
}
#if LANG_CXX11
inline void OS::set_buildversion(::std::string&& value) {
  
  buildversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.OS.buildVersion)
}
#endif
inline void OS::set_buildversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  buildversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.OS.buildVersion)
}
inline void OS::set_buildversion(const char* value, size_t size) {
  
  buildversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.OS.buildVersion)
}
inline ::std::string* OS::mutable_buildversion() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.OS.buildVersion)
  return buildversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_buildversion() {
  // @@protoc_insertion_point(field_release:eve_launcher.OS.buildVersion)
  
  return buildversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_buildversion(::std::string* buildversion) {
  if (buildversion != NULL) {
    
  } else {
    
  }
  buildversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buildversion);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.OS.buildVersion)
}

// string prettyProductName = 4;
inline void OS::clear_prettyproductname() {
  prettyproductname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::prettyproductname() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.prettyProductName)
  return prettyproductname_.GetNoArena();
}
inline void OS::set_prettyproductname(const ::std::string& value) {
  
  prettyproductname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.OS.prettyProductName)
}
#if LANG_CXX11
inline void OS::set_prettyproductname(::std::string&& value) {
  
  prettyproductname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.OS.prettyProductName)
}
#endif
inline void OS::set_prettyproductname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prettyproductname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.OS.prettyProductName)
}
inline void OS::set_prettyproductname(const char* value, size_t size) {
  
  prettyproductname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.OS.prettyProductName)
}
inline ::std::string* OS::mutable_prettyproductname() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.OS.prettyProductName)
  return prettyproductname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_prettyproductname() {
  // @@protoc_insertion_point(field_release:eve_launcher.OS.prettyProductName)
  
  return prettyproductname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_prettyproductname(::std::string* prettyproductname) {
  if (prettyproductname != NULL) {
    
  } else {
    
  }
  prettyproductname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prettyproductname);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.OS.prettyProductName)
}

// .eve_launcher.Bitness bitness = 5;
inline void OS::clear_bitness() {
  bitness_ = 0;
}
inline ::eve_launcher::Bitness OS::bitness() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.bitness)
  return static_cast< ::eve_launcher::Bitness >(bitness_);
}
inline void OS::set_bitness(::eve_launcher::Bitness value) {
  
  bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.OS.bitness)
}

// string processorArchitecture = 6;
inline void OS::clear_processorarchitecture() {
  processorarchitecture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::processorarchitecture() const {
  // @@protoc_insertion_point(field_get:eve_launcher.OS.processorArchitecture)
  return processorarchitecture_.GetNoArena();
}
inline void OS::set_processorarchitecture(const ::std::string& value) {
  
  processorarchitecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.OS.processorArchitecture)
}
#if LANG_CXX11
inline void OS::set_processorarchitecture(::std::string&& value) {
  
  processorarchitecture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.OS.processorArchitecture)
}
#endif
inline void OS::set_processorarchitecture(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  processorarchitecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.OS.processorArchitecture)
}
inline void OS::set_processorarchitecture(const char* value, size_t size) {
  
  processorarchitecture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.OS.processorArchitecture)
}
inline ::std::string* OS::mutable_processorarchitecture() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.OS.processorArchitecture)
  return processorarchitecture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_processorarchitecture() {
  // @@protoc_insertion_point(field_release:eve_launcher.OS.processorArchitecture)
  
  return processorarchitecture_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_processorarchitecture(::std::string* processorarchitecture) {
  if (processorarchitecture != NULL) {
    
  } else {
    
  }
  processorarchitecture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processorarchitecture);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.OS.processorArchitecture)
}

// -------------------------------------------------------------------

// Host

// bytes md5_hash = 1;
inline void Host::clear_md5_hash() {
  md5_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Host::md5_hash() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Host.md5_hash)
  return md5_hash_.GetNoArena();
}
inline void Host::set_md5_hash(const ::std::string& value) {
  
  md5_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Host.md5_hash)
}
#if LANG_CXX11
inline void Host::set_md5_hash(::std::string&& value) {
  
  md5_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Host.md5_hash)
}
#endif
inline void Host::set_md5_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  md5_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Host.md5_hash)
}
inline void Host::set_md5_hash(const void* value, size_t size) {
  
  md5_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Host.md5_hash)
}
inline ::std::string* Host::mutable_md5_hash() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Host.md5_hash)
  return md5_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Host::release_md5_hash() {
  // @@protoc_insertion_point(field_release:eve_launcher.Host.md5_hash)
  
  return md5_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Host::set_allocated_md5_hash(::std::string* md5_hash) {
  if (md5_hash != NULL) {
    
  } else {
    
  }
  md5_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5_hash);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Host.md5_hash)
}

// bytes mac_address = 2;
inline void Host::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Host::mac_address() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Host.mac_address)
  return mac_address_.GetNoArena();
}
inline void Host::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Host.mac_address)
}
#if LANG_CXX11
inline void Host::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Host.mac_address)
}
#endif
inline void Host::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Host.mac_address)
}
inline void Host::set_mac_address(const void* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Host.mac_address)
}
inline ::std::string* Host::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Host.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Host::release_mac_address() {
  // @@protoc_insertion_point(field_release:eve_launcher.Host.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Host::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Host.mac_address)
}

// .eve_launcher.OS os = 4;
inline bool Host::has_os() const {
  return this != internal_default_instance() && os_ != NULL;
}
inline void Host::clear_os() {
  if (GetArenaNoVirtual() == NULL && os_ != NULL) {
    delete os_;
  }
  os_ = NULL;
}
inline const ::eve_launcher::OS& Host::_internal_os() const {
  return *os_;
}
inline const ::eve_launcher::OS& Host::os() const {
  const ::eve_launcher::OS* p = os_;
  // @@protoc_insertion_point(field_get:eve_launcher.Host.os)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::OS*>(
      &::eve_launcher::_OS_default_instance_);
}
inline ::eve_launcher::OS* Host::release_os() {
  // @@protoc_insertion_point(field_release:eve_launcher.Host.os)
  
  ::eve_launcher::OS* temp = os_;
  os_ = NULL;
  return temp;
}
inline ::eve_launcher::OS* Host::mutable_os() {
  
  if (os_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::OS>(GetArenaNoVirtual());
    os_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Host.os)
  return os_;
}
inline void Host::set_allocated_os(::eve_launcher::OS* os) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete os_;
  }
  if (os) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      os = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Host.os)
}

// -------------------------------------------------------------------

// UsersOnServer

// string server = 1;
inline void UsersOnServer::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UsersOnServer::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UsersOnServer.server)
  return server_.GetNoArena();
}
inline void UsersOnServer::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UsersOnServer.server)
}
#if LANG_CXX11
inline void UsersOnServer::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UsersOnServer.server)
}
#endif
inline void UsersOnServer::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UsersOnServer.server)
}
inline void UsersOnServer::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UsersOnServer.server)
}
inline ::std::string* UsersOnServer::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UsersOnServer.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UsersOnServer::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.UsersOnServer.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UsersOnServer::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UsersOnServer.server)
}

// repeated .eve_launcher.user.Identifier user_ids = 2;
inline int UsersOnServer::user_ids_size() const {
  return user_ids_.size();
}
inline ::eve_launcher::user::Identifier* UsersOnServer::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.UsersOnServer.user_ids)
  return user_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
UsersOnServer::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.UsersOnServer.user_ids)
  return &user_ids_;
}
inline const ::eve_launcher::user::Identifier& UsersOnServer::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.UsersOnServer.user_ids)
  return user_ids_.Get(index);
}
inline ::eve_launcher::user::Identifier* UsersOnServer::add_user_ids() {
  // @@protoc_insertion_point(field_add:eve_launcher.UsersOnServer.user_ids)
  return user_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
UsersOnServer::user_ids() const {
  // @@protoc_insertion_point(field_list:eve_launcher.UsersOnServer.user_ids)
  return user_ids_;
}

// -------------------------------------------------------------------

// Settings

// string language = 1;
inline void Settings::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Settings::language() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.language)
  return language_.GetNoArena();
}
inline void Settings::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.language)
}
#if LANG_CXX11
inline void Settings::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Settings.language)
}
#endif
inline void Settings::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Settings.language)
}
inline void Settings::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Settings.language)
}
inline ::std::string* Settings::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Settings.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Settings::release_language() {
  // @@protoc_insertion_point(field_release:eve_launcher.Settings.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Settings::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Settings.language)
}

// bool download_everything = 2;
inline void Settings::clear_download_everything() {
  download_everything_ = false;
}
inline bool Settings::download_everything() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.download_everything)
  return download_everything_;
}
inline void Settings::set_download_everything(bool value) {
  
  download_everything_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.download_everything)
}

// bool run_clients_with_logging = 3;
inline void Settings::clear_run_clients_with_logging() {
  run_clients_with_logging_ = false;
}
inline bool Settings::run_clients_with_logging() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.run_clients_with_logging)
  return run_clients_with_logging_;
}
inline void Settings::set_run_clients_with_logging(bool value) {
  
  run_clients_with_logging_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.run_clients_with_logging)
}

// bool run_clients_with_dx9 = 4;
inline void Settings::clear_run_clients_with_dx9() {
  run_clients_with_dx9_ = false;
}
inline bool Settings::run_clients_with_dx9() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.run_clients_with_dx9)
  return run_clients_with_dx9_;
}
inline void Settings::set_run_clients_with_dx9(bool value) {
  
  run_clients_with_dx9_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.run_clients_with_dx9)
}

// bool minimize_to_tray_on_close = 5;
inline void Settings::clear_minimize_to_tray_on_close() {
  minimize_to_tray_on_close_ = false;
}
inline bool Settings::minimize_to_tray_on_close() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.minimize_to_tray_on_close)
  return minimize_to_tray_on_close_;
}
inline void Settings::set_minimize_to_tray_on_close(bool value) {
  
  minimize_to_tray_on_close_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.minimize_to_tray_on_close)
}

// bool ignore_certification_errors = 6;
inline void Settings::clear_ignore_certification_errors() {
  ignore_certification_errors_ = false;
}
inline bool Settings::ignore_certification_errors() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.ignore_certification_errors)
  return ignore_certification_errors_;
}
inline void Settings::set_ignore_certification_errors(bool value) {
  
  ignore_certification_errors_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.ignore_certification_errors)
}

// bool use_system_configuration_for_proxy = 7;
inline void Settings::clear_use_system_configuration_for_proxy() {
  use_system_configuration_for_proxy_ = false;
}
inline bool Settings::use_system_configuration_for_proxy() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.use_system_configuration_for_proxy)
  return use_system_configuration_for_proxy_;
}
inline void Settings::set_use_system_configuration_for_proxy(bool value) {
  
  use_system_configuration_for_proxy_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.use_system_configuration_for_proxy)
}

// bool enable_high_dpi_scaling = 8;
inline void Settings::clear_enable_high_dpi_scaling() {
  enable_high_dpi_scaling_ = false;
}
inline bool Settings::enable_high_dpi_scaling() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.enable_high_dpi_scaling)
  return enable_high_dpi_scaling_;
}
inline void Settings::set_enable_high_dpi_scaling(bool value) {
  
  enable_high_dpi_scaling_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.enable_high_dpi_scaling)
}

// bool enable_hardware_rendering = 9;
inline void Settings::clear_enable_hardware_rendering() {
  enable_hardware_rendering_ = false;
}
inline bool Settings::enable_hardware_rendering() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Settings.enable_hardware_rendering)
  return enable_hardware_rendering_;
}
inline void Settings::set_enable_hardware_rendering(bool value) {
  
  enable_hardware_rendering_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Settings.enable_hardware_rendering)
}

// -------------------------------------------------------------------

// Event

// .google.protobuf.Any payload = 2;
inline bool Event::has_payload() const {
  return this != internal_default_instance() && payload_ != NULL;
}
inline const ::google::protobuf::Any& Event::_internal_payload() const {
  return *payload_;
}
inline const ::google::protobuf::Any& Event::payload() const {
  const ::google::protobuf::Any* p = payload_;
  // @@protoc_insertion_point(field_get:eve_launcher.Event.payload)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Event::release_payload() {
  // @@protoc_insertion_point(field_release:eve_launcher.Event.payload)
  
  ::google::protobuf::Any* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* Event::mutable_payload() {
  
  if (payload_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Event.payload)
  return payload_;
}
inline void Event::set_allocated_payload(::google::protobuf::Any* payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(payload_);
  }
  if (payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Event.payload)
}

// bytes md5_session = 3;
inline void Event::clear_md5_session() {
  md5_session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::md5_session() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Event.md5_session)
  return md5_session_.GetNoArena();
}
inline void Event::set_md5_session(const ::std::string& value) {
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Event.md5_session)
}
#if LANG_CXX11
inline void Event::set_md5_session(::std::string&& value) {
  
  md5_session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Event.md5_session)
}
#endif
inline void Event::set_md5_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Event.md5_session)
}
inline void Event::set_md5_session(const void* value, size_t size) {
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Event.md5_session)
}
inline ::std::string* Event::mutable_md5_session() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Event.md5_session)
  return md5_session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_md5_session() {
  // @@protoc_insertion_point(field_release:eve_launcher.Event.md5_session)
  
  return md5_session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_md5_session(::std::string* md5_session) {
  if (md5_session != NULL) {
    
  } else {
    
  }
  md5_session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5_session);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Event.md5_session)
}

// .eve_launcher.Application application = 4;
inline bool Event::has_application() const {
  return this != internal_default_instance() && application_ != NULL;
}
inline void Event::clear_application() {
  if (GetArenaNoVirtual() == NULL && application_ != NULL) {
    delete application_;
  }
  application_ = NULL;
}
inline const ::eve_launcher::Application& Event::_internal_application() const {
  return *application_;
}
inline const ::eve_launcher::Application& Event::application() const {
  const ::eve_launcher::Application* p = application_;
  // @@protoc_insertion_point(field_get:eve_launcher.Event.application)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::Application*>(
      &::eve_launcher::_Application_default_instance_);
}
inline ::eve_launcher::Application* Event::release_application() {
  // @@protoc_insertion_point(field_release:eve_launcher.Event.application)
  
  ::eve_launcher::Application* temp = application_;
  application_ = NULL;
  return temp;
}
inline ::eve_launcher::Application* Event::mutable_application() {
  
  if (application_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::Application>(GetArenaNoVirtual());
    application_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Event.application)
  return application_;
}
inline void Event::set_allocated_application(::eve_launcher::Application* application) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete application_;
  }
  if (application) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      application = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    
  } else {
    
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Event.application)
}

// bytes operatingSystemUuid = 5;
inline void Event::clear_operatingsystemuuid() {
  operatingsystemuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::operatingsystemuuid() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Event.operatingSystemUuid)
  return operatingsystemuuid_.GetNoArena();
}
inline void Event::set_operatingsystemuuid(const ::std::string& value) {
  
  operatingsystemuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Event.operatingSystemUuid)
}
#if LANG_CXX11
inline void Event::set_operatingsystemuuid(::std::string&& value) {
  
  operatingsystemuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Event.operatingSystemUuid)
}
#endif
inline void Event::set_operatingsystemuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operatingsystemuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Event.operatingSystemUuid)
}
inline void Event::set_operatingsystemuuid(const void* value, size_t size) {
  
  operatingsystemuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Event.operatingSystemUuid)
}
inline ::std::string* Event::mutable_operatingsystemuuid() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.Event.operatingSystemUuid)
  return operatingsystemuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_operatingsystemuuid() {
  // @@protoc_insertion_point(field_release:eve_launcher.Event.operatingSystemUuid)
  
  return operatingsystemuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_operatingsystemuuid(::std::string* operatingsystemuuid) {
  if (operatingsystemuuid != NULL) {
    
  } else {
    
  }
  operatingsystemuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operatingsystemuuid);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Event.operatingSystemUuid)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool Event::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& Event::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& Event::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:eve_launcher.Event.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Event::release_timestamp() {
  // @@protoc_insertion_point(field_release:eve_launcher.Event.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Event::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Event.timestamp)
  return timestamp_;
}
inline void Event::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Event.timestamp)
}

// -------------------------------------------------------------------

// Installed

// -------------------------------------------------------------------

// Started

// .eve_launcher.Host host = 2;
inline bool Started::has_host() const {
  return this != internal_default_instance() && host_ != NULL;
}
inline void Started::clear_host() {
  if (GetArenaNoVirtual() == NULL && host_ != NULL) {
    delete host_;
  }
  host_ = NULL;
}
inline const ::eve_launcher::Host& Started::_internal_host() const {
  return *host_;
}
inline const ::eve_launcher::Host& Started::host() const {
  const ::eve_launcher::Host* p = host_;
  // @@protoc_insertion_point(field_get:eve_launcher.Started.host)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::Host*>(
      &::eve_launcher::_Host_default_instance_);
}
inline ::eve_launcher::Host* Started::release_host() {
  // @@protoc_insertion_point(field_release:eve_launcher.Started.host)
  
  ::eve_launcher::Host* temp = host_;
  host_ = NULL;
  return temp;
}
inline ::eve_launcher::Host* Started::mutable_host() {
  
  if (host_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::Host>(GetArenaNoVirtual());
    host_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Started.host)
  return host_;
}
inline void Started::set_allocated_host(::eve_launcher::Host* host) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_;
  }
  if (host) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host, submessage_arena);
    }
    
  } else {
    
  }
  host_ = host;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Started.host)
}

// .google.protobuf.Timestamp process_start_time = 4;
inline bool Started::has_process_start_time() const {
  return this != internal_default_instance() && process_start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Started::_internal_process_start_time() const {
  return *process_start_time_;
}
inline const ::google::protobuf::Timestamp& Started::process_start_time() const {
  const ::google::protobuf::Timestamp* p = process_start_time_;
  // @@protoc_insertion_point(field_get:eve_launcher.Started.process_start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Started::release_process_start_time() {
  // @@protoc_insertion_point(field_release:eve_launcher.Started.process_start_time)
  
  ::google::protobuf::Timestamp* temp = process_start_time_;
  process_start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Started::mutable_process_start_time() {
  
  if (process_start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    process_start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Started.process_start_time)
  return process_start_time_;
}
inline void Started::set_allocated_process_start_time(::google::protobuf::Timestamp* process_start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(process_start_time_);
  }
  if (process_start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(process_start_time)->GetArena();
    if (message_arena != submessage_arena) {
      process_start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, process_start_time, submessage_arena);
    }
    
  } else {
    
  }
  process_start_time_ = process_start_time;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Started.process_start_time)
}

// .eve_launcher.Settings settings = 5;
inline bool Started::has_settings() const {
  return this != internal_default_instance() && settings_ != NULL;
}
inline void Started::clear_settings() {
  if (GetArenaNoVirtual() == NULL && settings_ != NULL) {
    delete settings_;
  }
  settings_ = NULL;
}
inline const ::eve_launcher::Settings& Started::_internal_settings() const {
  return *settings_;
}
inline const ::eve_launcher::Settings& Started::settings() const {
  const ::eve_launcher::Settings* p = settings_;
  // @@protoc_insertion_point(field_get:eve_launcher.Started.settings)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::Settings*>(
      &::eve_launcher::_Settings_default_instance_);
}
inline ::eve_launcher::Settings* Started::release_settings() {
  // @@protoc_insertion_point(field_release:eve_launcher.Started.settings)
  
  ::eve_launcher::Settings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline ::eve_launcher::Settings* Started::mutable_settings() {
  
  if (settings_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::Settings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Started.settings)
  return settings_;
}
inline void Started::set_allocated_settings(::eve_launcher::Settings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete settings_;
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Started.settings)
}

// bool no_installer_provider = 6;
inline bool Started::has_no_installer_provider() const {
  return provider_case() == kNoInstallerProvider;
}
inline void Started::set_has_no_installer_provider() {
  _oneof_case_[0] = kNoInstallerProvider;
}
inline void Started::clear_no_installer_provider() {
  if (has_no_installer_provider()) {
    provider_.no_installer_provider_ = false;
    clear_has_provider();
  }
}
inline bool Started::no_installer_provider() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Started.no_installer_provider)
  if (has_no_installer_provider()) {
    return provider_.no_installer_provider_;
  }
  return false;
}
inline void Started::set_no_installer_provider(bool value) {
  if (!has_no_installer_provider()) {
    clear_provider();
    set_has_no_installer_provider();
  }
  provider_.no_installer_provider_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Started.no_installer_provider)
}

// string installer_provider = 7;
inline bool Started::has_installer_provider() const {
  return provider_case() == kInstallerProvider;
}
inline void Started::set_has_installer_provider() {
  _oneof_case_[0] = kInstallerProvider;
}
inline void Started::clear_installer_provider() {
  if (has_installer_provider()) {
    provider_.installer_provider_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_provider();
  }
}
inline const ::std::string& Started::installer_provider() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Started.installer_provider)
  if (has_installer_provider()) {
    return provider_.installer_provider_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Started::set_installer_provider(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.Started.installer_provider)
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.Started.installer_provider)
}
#if LANG_CXX11
inline void Started::set_installer_provider(::std::string&& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.Started.installer_provider)
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.Started.installer_provider)
}
#endif
inline void Started::set_installer_provider(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.Started.installer_provider)
}
inline void Started::set_installer_provider(const char* value, size_t size) {
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.Started.installer_provider)
}
inline ::std::string* Started::mutable_installer_provider() {
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.Started.installer_provider)
  return provider_.installer_provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Started::release_installer_provider() {
  // @@protoc_insertion_point(field_release:eve_launcher.Started.installer_provider)
  if (has_installer_provider()) {
    clear_has_provider();
    return provider_.installer_provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Started::set_allocated_installer_provider(::std::string* installer_provider) {
  if (!has_installer_provider()) {
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_provider();
  if (installer_provider != NULL) {
    set_has_installer_provider();
    provider_.installer_provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), installer_provider);
  }
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.Started.installer_provider)
}

// bool started_by_updater = 8;
inline void Started::clear_started_by_updater() {
  started_by_updater_ = false;
}
inline bool Started::started_by_updater() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Started.started_by_updater)
  return started_by_updater_;
}
inline void Started::set_started_by_updater(bool value) {
  
  started_by_updater_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Started.started_by_updater)
}

inline bool Started::has_provider() const {
  return provider_case() != PROVIDER_NOT_SET;
}
inline void Started::clear_has_provider() {
  _oneof_case_[0] = PROVIDER_NOT_SET;
}
inline Started::ProviderCase Started::provider_case() const {
  return Started::ProviderCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateStarted

// string target_version = 2;
inline void UpdateStarted::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateStarted::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UpdateStarted.target_version)
  return target_version_.GetNoArena();
}
inline void UpdateStarted::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UpdateStarted.target_version)
}
#if LANG_CXX11
inline void UpdateStarted::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UpdateStarted.target_version)
}
#endif
inline void UpdateStarted::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UpdateStarted.target_version)
}
inline void UpdateStarted::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UpdateStarted.target_version)
}
inline ::std::string* UpdateStarted::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UpdateStarted.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateStarted::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.UpdateStarted.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateStarted::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UpdateStarted.target_version)
}

// -------------------------------------------------------------------

// Shutdown

// int32 clients_running = 2;
inline void Shutdown::clear_clients_running() {
  clients_running_ = 0;
}
inline ::google::protobuf::int32 Shutdown::clients_running() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Shutdown.clients_running)
  return clients_running_;
}
inline void Shutdown::set_clients_running(::google::protobuf::int32 value) {
  
  clients_running_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Shutdown.clients_running)
}

// int32 clients_started = 3;
inline void Shutdown::clear_clients_started() {
  clients_started_ = 0;
}
inline ::google::protobuf::int32 Shutdown::clients_started() const {
  // @@protoc_insertion_point(field_get:eve_launcher.Shutdown.clients_started)
  return clients_started_;
}
inline void Shutdown::set_clients_started(::google::protobuf::int32 value) {
  
  clients_started_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.Shutdown.clients_started)
}

// repeated .eve_launcher.UsersOnServer pinned_users = 4;
inline int Shutdown::pinned_users_size() const {
  return pinned_users_.size();
}
inline void Shutdown::clear_pinned_users() {
  pinned_users_.Clear();
}
inline ::eve_launcher::UsersOnServer* Shutdown::mutable_pinned_users(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.Shutdown.pinned_users)
  return pinned_users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
Shutdown::mutable_pinned_users() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.Shutdown.pinned_users)
  return &pinned_users_;
}
inline const ::eve_launcher::UsersOnServer& Shutdown::pinned_users(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.Shutdown.pinned_users)
  return pinned_users_.Get(index);
}
inline ::eve_launcher::UsersOnServer* Shutdown::add_pinned_users() {
  // @@protoc_insertion_point(field_add:eve_launcher.Shutdown.pinned_users)
  return pinned_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
Shutdown::pinned_users() const {
  // @@protoc_insertion_point(field_list:eve_launcher.Shutdown.pinned_users)
  return pinned_users_;
}

// repeated .eve_launcher.UsersOnServer not_pinned_users = 5;
inline int Shutdown::not_pinned_users_size() const {
  return not_pinned_users_.size();
}
inline void Shutdown::clear_not_pinned_users() {
  not_pinned_users_.Clear();
}
inline ::eve_launcher::UsersOnServer* Shutdown::mutable_not_pinned_users(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.Shutdown.not_pinned_users)
  return not_pinned_users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
Shutdown::mutable_not_pinned_users() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.Shutdown.not_pinned_users)
  return &not_pinned_users_;
}
inline const ::eve_launcher::UsersOnServer& Shutdown::not_pinned_users(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.Shutdown.not_pinned_users)
  return not_pinned_users_.Get(index);
}
inline ::eve_launcher::UsersOnServer* Shutdown::add_not_pinned_users() {
  // @@protoc_insertion_point(field_add:eve_launcher.Shutdown.not_pinned_users)
  return not_pinned_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
Shutdown::not_pinned_users() const {
  // @@protoc_insertion_point(field_list:eve_launcher.Shutdown.not_pinned_users)
  return not_pinned_users_;
}

// -------------------------------------------------------------------

// ClientInitiallyLaunched

// string target_server = 2;
inline void ClientInitiallyLaunched::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientInitiallyLaunched::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientInitiallyLaunched.target_server)
  return target_server_.GetNoArena();
}
inline void ClientInitiallyLaunched::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientInitiallyLaunched.target_server)
}
#if LANG_CXX11
inline void ClientInitiallyLaunched::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientInitiallyLaunched.target_server)
}
#endif
inline void ClientInitiallyLaunched::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientInitiallyLaunched.target_server)
}
inline void ClientInitiallyLaunched::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientInitiallyLaunched.target_server)
}
inline ::std::string* ClientInitiallyLaunched::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientInitiallyLaunched.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientInitiallyLaunched::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientInitiallyLaunched.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientInitiallyLaunched::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientInitiallyLaunched.target_server)
}

// .eve_launcher.ClientOptions client_options = 3;
inline bool ClientInitiallyLaunched::has_client_options() const {
  return this != internal_default_instance() && client_options_ != NULL;
}
inline void ClientInitiallyLaunched::clear_client_options() {
  if (GetArenaNoVirtual() == NULL && client_options_ != NULL) {
    delete client_options_;
  }
  client_options_ = NULL;
}
inline const ::eve_launcher::ClientOptions& ClientInitiallyLaunched::_internal_client_options() const {
  return *client_options_;
}
inline const ::eve_launcher::ClientOptions& ClientInitiallyLaunched::client_options() const {
  const ::eve_launcher::ClientOptions* p = client_options_;
  // @@protoc_insertion_point(field_get:eve_launcher.ClientInitiallyLaunched.client_options)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::ClientOptions*>(
      &::eve_launcher::_ClientOptions_default_instance_);
}
inline ::eve_launcher::ClientOptions* ClientInitiallyLaunched::release_client_options() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientInitiallyLaunched.client_options)
  
  ::eve_launcher::ClientOptions* temp = client_options_;
  client_options_ = NULL;
  return temp;
}
inline ::eve_launcher::ClientOptions* ClientInitiallyLaunched::mutable_client_options() {
  
  if (client_options_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::ClientOptions>(GetArenaNoVirtual());
    client_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientInitiallyLaunched.client_options)
  return client_options_;
}
inline void ClientInitiallyLaunched::set_allocated_client_options(::eve_launcher::ClientOptions* client_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_options_;
  }
  if (client_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_options, submessage_arena);
    }
    
  } else {
    
  }
  client_options_ = client_options;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientInitiallyLaunched.client_options)
}

// -------------------------------------------------------------------

// ClientLaunched

// string target_server = 2;
inline void ClientLaunched::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientLaunched::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientLaunched.target_server)
  return target_server_.GetNoArena();
}
inline void ClientLaunched::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientLaunched.target_server)
}
#if LANG_CXX11
inline void ClientLaunched::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientLaunched.target_server)
}
#endif
inline void ClientLaunched::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientLaunched.target_server)
}
inline void ClientLaunched::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientLaunched.target_server)
}
inline ::std::string* ClientLaunched::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientLaunched.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientLaunched::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientLaunched.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientLaunched::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientLaunched.target_server)
}

// .eve_launcher.ClientOptions client_options = 3;
inline bool ClientLaunched::has_client_options() const {
  return this != internal_default_instance() && client_options_ != NULL;
}
inline void ClientLaunched::clear_client_options() {
  if (GetArenaNoVirtual() == NULL && client_options_ != NULL) {
    delete client_options_;
  }
  client_options_ = NULL;
}
inline const ::eve_launcher::ClientOptions& ClientLaunched::_internal_client_options() const {
  return *client_options_;
}
inline const ::eve_launcher::ClientOptions& ClientLaunched::client_options() const {
  const ::eve_launcher::ClientOptions* p = client_options_;
  // @@protoc_insertion_point(field_get:eve_launcher.ClientLaunched.client_options)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::ClientOptions*>(
      &::eve_launcher::_ClientOptions_default_instance_);
}
inline ::eve_launcher::ClientOptions* ClientLaunched::release_client_options() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientLaunched.client_options)
  
  ::eve_launcher::ClientOptions* temp = client_options_;
  client_options_ = NULL;
  return temp;
}
inline ::eve_launcher::ClientOptions* ClientLaunched::mutable_client_options() {
  
  if (client_options_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::ClientOptions>(GetArenaNoVirtual());
    client_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientLaunched.client_options)
  return client_options_;
}
inline void ClientLaunched::set_allocated_client_options(::eve_launcher::ClientOptions* client_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_options_;
  }
  if (client_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_options, submessage_arena);
    }
    
  } else {
    
  }
  client_options_ = client_options;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientLaunched.client_options)
}

// .eve_launcher.user.Identifier user_id = 4;
inline bool ClientLaunched::has_user_id() const {
  return this != internal_default_instance() && user_id_ != NULL;
}
inline const ::eve_launcher::user::Identifier& ClientLaunched::_internal_user_id() const {
  return *user_id_;
}
inline const ::eve_launcher::user::Identifier& ClientLaunched::user_id() const {
  const ::eve_launcher::user::Identifier* p = user_id_;
  // @@protoc_insertion_point(field_get:eve_launcher.ClientLaunched.user_id)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::user::Identifier*>(
      &::eve_launcher::user::_Identifier_default_instance_);
}
inline ::eve_launcher::user::Identifier* ClientLaunched::release_user_id() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientLaunched.user_id)
  
  ::eve_launcher::user::Identifier* temp = user_id_;
  user_id_ = NULL;
  return temp;
}
inline ::eve_launcher::user::Identifier* ClientLaunched::mutable_user_id() {
  
  if (user_id_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::user::Identifier>(GetArenaNoVirtual());
    user_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientLaunched.user_id)
  return user_id_;
}
inline void ClientLaunched::set_allocated_user_id(::eve_launcher::user::Identifier* user_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_id_);
  }
  if (user_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_id, submessage_arena);
    }
    
  } else {
    
  }
  user_id_ = user_id;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientLaunched.user_id)
}

// -------------------------------------------------------------------

// ClientCrashed

// string server = 1;
inline void ClientCrashed::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientCrashed::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientCrashed.server)
  return server_.GetNoArena();
}
inline void ClientCrashed::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientCrashed.server)
}
#if LANG_CXX11
inline void ClientCrashed::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientCrashed.server)
}
#endif
inline void ClientCrashed::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientCrashed.server)
}
inline void ClientCrashed::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientCrashed.server)
}
inline ::std::string* ClientCrashed::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientCrashed.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientCrashed::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientCrashed.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientCrashed::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientCrashed.server)
}

// .eve_launcher.user.Identifier user_id = 2;
inline bool ClientCrashed::has_user_id() const {
  return this != internal_default_instance() && user_id_ != NULL;
}
inline const ::eve_launcher::user::Identifier& ClientCrashed::_internal_user_id() const {
  return *user_id_;
}
inline const ::eve_launcher::user::Identifier& ClientCrashed::user_id() const {
  const ::eve_launcher::user::Identifier* p = user_id_;
  // @@protoc_insertion_point(field_get:eve_launcher.ClientCrashed.user_id)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::user::Identifier*>(
      &::eve_launcher::user::_Identifier_default_instance_);
}
inline ::eve_launcher::user::Identifier* ClientCrashed::release_user_id() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientCrashed.user_id)
  
  ::eve_launcher::user::Identifier* temp = user_id_;
  user_id_ = NULL;
  return temp;
}
inline ::eve_launcher::user::Identifier* ClientCrashed::mutable_user_id() {
  
  if (user_id_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::user::Identifier>(GetArenaNoVirtual());
    user_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientCrashed.user_id)
  return user_id_;
}
inline void ClientCrashed::set_allocated_user_id(::eve_launcher::user::Identifier* user_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_id_);
  }
  if (user_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_id, submessage_arena);
    }
    
  } else {
    
  }
  user_id_ = user_id;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientCrashed.user_id)
}

// int32 exit_code = 3;
inline void ClientCrashed::clear_exit_code() {
  exit_code_ = 0;
}
inline ::google::protobuf::int32 ClientCrashed::exit_code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientCrashed.exit_code)
  return exit_code_;
}
inline void ClientCrashed::set_exit_code(::google::protobuf::int32 value) {
  
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ClientCrashed.exit_code)
}

// -------------------------------------------------------------------

// ClientShutdown

// string server = 1;
inline void ClientShutdown::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientShutdown::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientShutdown.server)
  return server_.GetNoArena();
}
inline void ClientShutdown::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientShutdown.server)
}
#if LANG_CXX11
inline void ClientShutdown::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientShutdown.server)
}
#endif
inline void ClientShutdown::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientShutdown.server)
}
inline void ClientShutdown::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientShutdown.server)
}
inline ::std::string* ClientShutdown::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientShutdown.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientShutdown::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientShutdown.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientShutdown::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientShutdown.server)
}

// .eve_launcher.user.Identifier user_id = 2;
inline bool ClientShutdown::has_user_id() const {
  return this != internal_default_instance() && user_id_ != NULL;
}
inline const ::eve_launcher::user::Identifier& ClientShutdown::_internal_user_id() const {
  return *user_id_;
}
inline const ::eve_launcher::user::Identifier& ClientShutdown::user_id() const {
  const ::eve_launcher::user::Identifier* p = user_id_;
  // @@protoc_insertion_point(field_get:eve_launcher.ClientShutdown.user_id)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::user::Identifier*>(
      &::eve_launcher::user::_Identifier_default_instance_);
}
inline ::eve_launcher::user::Identifier* ClientShutdown::release_user_id() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientShutdown.user_id)
  
  ::eve_launcher::user::Identifier* temp = user_id_;
  user_id_ = NULL;
  return temp;
}
inline ::eve_launcher::user::Identifier* ClientShutdown::mutable_user_id() {
  
  if (user_id_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::user::Identifier>(GetArenaNoVirtual());
    user_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientShutdown.user_id)
  return user_id_;
}
inline void ClientShutdown::set_allocated_user_id(::eve_launcher::user::Identifier* user_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_id_);
  }
  if (user_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_id, submessage_arena);
    }
    
  } else {
    
  }
  user_id_ = user_id;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientShutdown.user_id)
}

// -------------------------------------------------------------------

// ReleaseWineLaunched

// string target_server = 2;
inline void ReleaseWineLaunched::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReleaseWineLaunched::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ReleaseWineLaunched.target_server)
  return target_server_.GetNoArena();
}
inline void ReleaseWineLaunched::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ReleaseWineLaunched.target_server)
}
#if LANG_CXX11
inline void ReleaseWineLaunched::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ReleaseWineLaunched.target_server)
}
#endif
inline void ReleaseWineLaunched::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ReleaseWineLaunched.target_server)
}
inline void ReleaseWineLaunched::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ReleaseWineLaunched.target_server)
}
inline ::std::string* ReleaseWineLaunched::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ReleaseWineLaunched.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReleaseWineLaunched::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ReleaseWineLaunched.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReleaseWineLaunched::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ReleaseWineLaunched.target_server)
}

// string wine_build = 3;
inline void ReleaseWineLaunched::clear_wine_build() {
  wine_build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReleaseWineLaunched::wine_build() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ReleaseWineLaunched.wine_build)
  return wine_build_.GetNoArena();
}
inline void ReleaseWineLaunched::set_wine_build(const ::std::string& value) {
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ReleaseWineLaunched.wine_build)
}
#if LANG_CXX11
inline void ReleaseWineLaunched::set_wine_build(::std::string&& value) {
  
  wine_build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ReleaseWineLaunched.wine_build)
}
#endif
inline void ReleaseWineLaunched::set_wine_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ReleaseWineLaunched.wine_build)
}
inline void ReleaseWineLaunched::set_wine_build(const char* value, size_t size) {
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ReleaseWineLaunched.wine_build)
}
inline ::std::string* ReleaseWineLaunched::mutable_wine_build() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ReleaseWineLaunched.wine_build)
  return wine_build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReleaseWineLaunched::release_wine_build() {
  // @@protoc_insertion_point(field_release:eve_launcher.ReleaseWineLaunched.wine_build)
  
  return wine_build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReleaseWineLaunched::set_allocated_wine_build(::std::string* wine_build) {
  if (wine_build != NULL) {
    
  } else {
    
  }
  wine_build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wine_build);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ReleaseWineLaunched.wine_build)
}

// .eve_launcher.OS os = 4;
inline bool ReleaseWineLaunched::has_os() const {
  return this != internal_default_instance() && os_ != NULL;
}
inline void ReleaseWineLaunched::clear_os() {
  if (GetArenaNoVirtual() == NULL && os_ != NULL) {
    delete os_;
  }
  os_ = NULL;
}
inline const ::eve_launcher::OS& ReleaseWineLaunched::_internal_os() const {
  return *os_;
}
inline const ::eve_launcher::OS& ReleaseWineLaunched::os() const {
  const ::eve_launcher::OS* p = os_;
  // @@protoc_insertion_point(field_get:eve_launcher.ReleaseWineLaunched.os)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::OS*>(
      &::eve_launcher::_OS_default_instance_);
}
inline ::eve_launcher::OS* ReleaseWineLaunched::release_os() {
  // @@protoc_insertion_point(field_release:eve_launcher.ReleaseWineLaunched.os)
  
  ::eve_launcher::OS* temp = os_;
  os_ = NULL;
  return temp;
}
inline ::eve_launcher::OS* ReleaseWineLaunched::mutable_os() {
  
  if (os_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::OS>(GetArenaNoVirtual());
    os_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.ReleaseWineLaunched.os)
  return os_;
}
inline void ReleaseWineLaunched::set_allocated_os(::eve_launcher::OS* os) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete os_;
  }
  if (os) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      os = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ReleaseWineLaunched.os)
}

// .eve_launcher.graphics.DirectXMode directx_mode = 5;
inline void ReleaseWineLaunched::clear_directx_mode() {
  directx_mode_ = 0;
}
inline ::eve_launcher::graphics::DirectXMode ReleaseWineLaunched::directx_mode() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ReleaseWineLaunched.directx_mode)
  return static_cast< ::eve_launcher::graphics::DirectXMode >(directx_mode_);
}
inline void ReleaseWineLaunched::set_directx_mode(::eve_launcher::graphics::DirectXMode value) {
  
  directx_mode_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ReleaseWineLaunched.directx_mode)
}

// -------------------------------------------------------------------

// DevelopmentWineLaunched

// string target_server = 2;
inline void DevelopmentWineLaunched::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DevelopmentWineLaunched::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DevelopmentWineLaunched.target_server)
  return target_server_.GetNoArena();
}
inline void DevelopmentWineLaunched::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.DevelopmentWineLaunched.target_server)
}
#if LANG_CXX11
inline void DevelopmentWineLaunched::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.DevelopmentWineLaunched.target_server)
}
#endif
inline void DevelopmentWineLaunched::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.DevelopmentWineLaunched.target_server)
}
inline void DevelopmentWineLaunched::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.DevelopmentWineLaunched.target_server)
}
inline ::std::string* DevelopmentWineLaunched::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.DevelopmentWineLaunched.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevelopmentWineLaunched::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.DevelopmentWineLaunched.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevelopmentWineLaunched::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.DevelopmentWineLaunched.target_server)
}

// string wine_branch = 3;
inline void DevelopmentWineLaunched::clear_wine_branch() {
  wine_branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DevelopmentWineLaunched::wine_branch() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DevelopmentWineLaunched.wine_branch)
  return wine_branch_.GetNoArena();
}
inline void DevelopmentWineLaunched::set_wine_branch(const ::std::string& value) {
  
  wine_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.DevelopmentWineLaunched.wine_branch)
}
#if LANG_CXX11
inline void DevelopmentWineLaunched::set_wine_branch(::std::string&& value) {
  
  wine_branch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.DevelopmentWineLaunched.wine_branch)
}
#endif
inline void DevelopmentWineLaunched::set_wine_branch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wine_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.DevelopmentWineLaunched.wine_branch)
}
inline void DevelopmentWineLaunched::set_wine_branch(const char* value, size_t size) {
  
  wine_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.DevelopmentWineLaunched.wine_branch)
}
inline ::std::string* DevelopmentWineLaunched::mutable_wine_branch() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.DevelopmentWineLaunched.wine_branch)
  return wine_branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevelopmentWineLaunched::release_wine_branch() {
  // @@protoc_insertion_point(field_release:eve_launcher.DevelopmentWineLaunched.wine_branch)
  
  return wine_branch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevelopmentWineLaunched::set_allocated_wine_branch(::std::string* wine_branch) {
  if (wine_branch != NULL) {
    
  } else {
    
  }
  wine_branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wine_branch);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.DevelopmentWineLaunched.wine_branch)
}

// string wine_build = 4;
inline void DevelopmentWineLaunched::clear_wine_build() {
  wine_build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DevelopmentWineLaunched::wine_build() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DevelopmentWineLaunched.wine_build)
  return wine_build_.GetNoArena();
}
inline void DevelopmentWineLaunched::set_wine_build(const ::std::string& value) {
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.DevelopmentWineLaunched.wine_build)
}
#if LANG_CXX11
inline void DevelopmentWineLaunched::set_wine_build(::std::string&& value) {
  
  wine_build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.DevelopmentWineLaunched.wine_build)
}
#endif
inline void DevelopmentWineLaunched::set_wine_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.DevelopmentWineLaunched.wine_build)
}
inline void DevelopmentWineLaunched::set_wine_build(const char* value, size_t size) {
  
  wine_build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.DevelopmentWineLaunched.wine_build)
}
inline ::std::string* DevelopmentWineLaunched::mutable_wine_build() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.DevelopmentWineLaunched.wine_build)
  return wine_build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevelopmentWineLaunched::release_wine_build() {
  // @@protoc_insertion_point(field_release:eve_launcher.DevelopmentWineLaunched.wine_build)
  
  return wine_build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevelopmentWineLaunched::set_allocated_wine_build(::std::string* wine_build) {
  if (wine_build != NULL) {
    
  } else {
    
  }
  wine_build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wine_build);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.DevelopmentWineLaunched.wine_build)
}

// .eve_launcher.OS os = 5;
inline bool DevelopmentWineLaunched::has_os() const {
  return this != internal_default_instance() && os_ != NULL;
}
inline void DevelopmentWineLaunched::clear_os() {
  if (GetArenaNoVirtual() == NULL && os_ != NULL) {
    delete os_;
  }
  os_ = NULL;
}
inline const ::eve_launcher::OS& DevelopmentWineLaunched::_internal_os() const {
  return *os_;
}
inline const ::eve_launcher::OS& DevelopmentWineLaunched::os() const {
  const ::eve_launcher::OS* p = os_;
  // @@protoc_insertion_point(field_get:eve_launcher.DevelopmentWineLaunched.os)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::OS*>(
      &::eve_launcher::_OS_default_instance_);
}
inline ::eve_launcher::OS* DevelopmentWineLaunched::release_os() {
  // @@protoc_insertion_point(field_release:eve_launcher.DevelopmentWineLaunched.os)
  
  ::eve_launcher::OS* temp = os_;
  os_ = NULL;
  return temp;
}
inline ::eve_launcher::OS* DevelopmentWineLaunched::mutable_os() {
  
  if (os_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::OS>(GetArenaNoVirtual());
    os_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.DevelopmentWineLaunched.os)
  return os_;
}
inline void DevelopmentWineLaunched::set_allocated_os(::eve_launcher::OS* os) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete os_;
  }
  if (os) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      os = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.DevelopmentWineLaunched.os)
}

// .eve_launcher.graphics.DirectXMode directx_mode = 6;
inline void DevelopmentWineLaunched::clear_directx_mode() {
  directx_mode_ = 0;
}
inline ::eve_launcher::graphics::DirectXMode DevelopmentWineLaunched::directx_mode() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DevelopmentWineLaunched.directx_mode)
  return static_cast< ::eve_launcher::graphics::DirectXMode >(directx_mode_);
}
inline void DevelopmentWineLaunched::set_directx_mode(::eve_launcher::graphics::DirectXMode value) {
  
  directx_mode_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.DevelopmentWineLaunched.directx_mode)
}

// -------------------------------------------------------------------

// CustomWineLaunched

// string target_server = 2;
inline void CustomWineLaunched::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomWineLaunched::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CustomWineLaunched.target_server)
  return target_server_.GetNoArena();
}
inline void CustomWineLaunched::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.CustomWineLaunched.target_server)
}
#if LANG_CXX11
inline void CustomWineLaunched::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.CustomWineLaunched.target_server)
}
#endif
inline void CustomWineLaunched::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.CustomWineLaunched.target_server)
}
inline void CustomWineLaunched::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.CustomWineLaunched.target_server)
}
inline ::std::string* CustomWineLaunched::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.CustomWineLaunched.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomWineLaunched::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.CustomWineLaunched.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomWineLaunched::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.CustomWineLaunched.target_server)
}

// .eve_launcher.OS os = 3;
inline bool CustomWineLaunched::has_os() const {
  return this != internal_default_instance() && os_ != NULL;
}
inline void CustomWineLaunched::clear_os() {
  if (GetArenaNoVirtual() == NULL && os_ != NULL) {
    delete os_;
  }
  os_ = NULL;
}
inline const ::eve_launcher::OS& CustomWineLaunched::_internal_os() const {
  return *os_;
}
inline const ::eve_launcher::OS& CustomWineLaunched::os() const {
  const ::eve_launcher::OS* p = os_;
  // @@protoc_insertion_point(field_get:eve_launcher.CustomWineLaunched.os)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::OS*>(
      &::eve_launcher::_OS_default_instance_);
}
inline ::eve_launcher::OS* CustomWineLaunched::release_os() {
  // @@protoc_insertion_point(field_release:eve_launcher.CustomWineLaunched.os)
  
  ::eve_launcher::OS* temp = os_;
  os_ = NULL;
  return temp;
}
inline ::eve_launcher::OS* CustomWineLaunched::mutable_os() {
  
  if (os_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::OS>(GetArenaNoVirtual());
    os_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.CustomWineLaunched.os)
  return os_;
}
inline void CustomWineLaunched::set_allocated_os(::eve_launcher::OS* os) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete os_;
  }
  if (os) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      os = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.CustomWineLaunched.os)
}

// .eve_launcher.graphics.DirectXMode directx_mode = 4;
inline void CustomWineLaunched::clear_directx_mode() {
  directx_mode_ = 0;
}
inline ::eve_launcher::graphics::DirectXMode CustomWineLaunched::directx_mode() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CustomWineLaunched.directx_mode)
  return static_cast< ::eve_launcher::graphics::DirectXMode >(directx_mode_);
}
inline void CustomWineLaunched::set_directx_mode(::eve_launcher::graphics::DirectXMode value) {
  
  directx_mode_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.CustomWineLaunched.directx_mode)
}

// -------------------------------------------------------------------

// ClientUpdateStarted

// string target_server = 2;
inline void ClientUpdateStarted::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientUpdateStarted::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateStarted.target_server)
  return target_server_.GetNoArena();
}
inline void ClientUpdateStarted::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateStarted.target_server)
}
#if LANG_CXX11
inline void ClientUpdateStarted::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientUpdateStarted.target_server)
}
#endif
inline void ClientUpdateStarted::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientUpdateStarted.target_server)
}
inline void ClientUpdateStarted::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientUpdateStarted.target_server)
}
inline ::std::string* ClientUpdateStarted::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientUpdateStarted.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientUpdateStarted::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientUpdateStarted.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientUpdateStarted::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientUpdateStarted.target_server)
}

// string target_version = 3;
inline void ClientUpdateStarted::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientUpdateStarted::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateStarted.target_version)
  return target_version_.GetNoArena();
}
inline void ClientUpdateStarted::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateStarted.target_version)
}
#if LANG_CXX11
inline void ClientUpdateStarted::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientUpdateStarted.target_version)
}
#endif
inline void ClientUpdateStarted::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientUpdateStarted.target_version)
}
inline void ClientUpdateStarted::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientUpdateStarted.target_version)
}
inline ::std::string* ClientUpdateStarted::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientUpdateStarted.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientUpdateStarted::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientUpdateStarted.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientUpdateStarted::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientUpdateStarted.target_version)
}

// -------------------------------------------------------------------

// ClientUpdateCompleted

// string target_server = 2;
inline void ClientUpdateCompleted::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientUpdateCompleted::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateCompleted.target_server)
  return target_server_.GetNoArena();
}
inline void ClientUpdateCompleted::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateCompleted.target_server)
}
#if LANG_CXX11
inline void ClientUpdateCompleted::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientUpdateCompleted.target_server)
}
#endif
inline void ClientUpdateCompleted::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientUpdateCompleted.target_server)
}
inline void ClientUpdateCompleted::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientUpdateCompleted.target_server)
}
inline ::std::string* ClientUpdateCompleted::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientUpdateCompleted.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientUpdateCompleted::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientUpdateCompleted.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientUpdateCompleted::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientUpdateCompleted.target_server)
}

// float download_speed = 3;
inline void ClientUpdateCompleted::clear_download_speed() {
  download_speed_ = 0;
}
inline float ClientUpdateCompleted::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateCompleted.download_speed)
  return download_speed_;
}
inline void ClientUpdateCompleted::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateCompleted.download_speed)
}

// string target_version = 4;
inline void ClientUpdateCompleted::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientUpdateCompleted::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateCompleted.target_version)
  return target_version_.GetNoArena();
}
inline void ClientUpdateCompleted::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateCompleted.target_version)
}
#if LANG_CXX11
inline void ClientUpdateCompleted::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientUpdateCompleted.target_version)
}
#endif
inline void ClientUpdateCompleted::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientUpdateCompleted.target_version)
}
inline void ClientUpdateCompleted::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientUpdateCompleted.target_version)
}
inline ::std::string* ClientUpdateCompleted::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientUpdateCompleted.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientUpdateCompleted::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientUpdateCompleted.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientUpdateCompleted::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientUpdateCompleted.target_version)
}

// uint64 bytes_downloaded = 5;
inline void ClientUpdateCompleted::clear_bytes_downloaded() {
  bytes_downloaded_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ClientUpdateCompleted::bytes_downloaded() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateCompleted.bytes_downloaded)
  return bytes_downloaded_;
}
inline void ClientUpdateCompleted::set_bytes_downloaded(::google::protobuf::uint64 value) {
  
  bytes_downloaded_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateCompleted.bytes_downloaded)
}

// -------------------------------------------------------------------

// ClientUpdateFailed

// uint32 error_code = 2;
inline void ClientUpdateFailed::clear_error_code() {
  error_code_ = 0u;
}
inline ::google::protobuf::uint32 ClientUpdateFailed::error_code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateFailed.error_code)
  return error_code_;
}
inline void ClientUpdateFailed::set_error_code(::google::protobuf::uint32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateFailed.error_code)
}

// string target_server = 3;
inline void ClientUpdateFailed::clear_target_server() {
  target_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientUpdateFailed::target_server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.ClientUpdateFailed.target_server)
  return target_server_.GetNoArena();
}
inline void ClientUpdateFailed::set_target_server(const ::std::string& value) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.ClientUpdateFailed.target_server)
}
#if LANG_CXX11
inline void ClientUpdateFailed::set_target_server(::std::string&& value) {
  
  target_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.ClientUpdateFailed.target_server)
}
#endif
inline void ClientUpdateFailed::set_target_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.ClientUpdateFailed.target_server)
}
inline void ClientUpdateFailed::set_target_server(const char* value, size_t size) {
  
  target_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.ClientUpdateFailed.target_server)
}
inline ::std::string* ClientUpdateFailed::mutable_target_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.ClientUpdateFailed.target_server)
  return target_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientUpdateFailed::release_target_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.ClientUpdateFailed.target_server)
  
  return target_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientUpdateFailed::set_allocated_target_server(::std::string* target_server) {
  if (target_server != NULL) {
    
  } else {
    
  }
  target_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.ClientUpdateFailed.target_server)
}

// -------------------------------------------------------------------

// WebLoaded

// repeated .eve_launcher.UsersOnServer users = 1;
inline int WebLoaded::users_size() const {
  return users_.size();
}
inline void WebLoaded::clear_users() {
  users_.Clear();
}
inline ::eve_launcher::UsersOnServer* WebLoaded::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.WebLoaded.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >*
WebLoaded::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.WebLoaded.users)
  return &users_;
}
inline const ::eve_launcher::UsersOnServer& WebLoaded::users(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebLoaded.users)
  return users_.Get(index);
}
inline ::eve_launcher::UsersOnServer* WebLoaded::add_users() {
  // @@protoc_insertion_point(field_add:eve_launcher.WebLoaded.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::UsersOnServer >&
WebLoaded::users() const {
  // @@protoc_insertion_point(field_list:eve_launcher.WebLoaded.users)
  return users_;
}

// .eve_launcher.WebLoaded.Platform launcher_started_from = 2;
inline void WebLoaded::clear_launcher_started_from() {
  launcher_started_from_ = 0;
}
inline ::eve_launcher::WebLoaded_Platform WebLoaded::launcher_started_from() const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebLoaded.launcher_started_from)
  return static_cast< ::eve_launcher::WebLoaded_Platform >(launcher_started_from_);
}
inline void WebLoaded::set_launcher_started_from(::eve_launcher::WebLoaded_Platform value) {
  
  launcher_started_from_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.WebLoaded.launcher_started_from)
}

// -------------------------------------------------------------------

// LoginCancelled

// -------------------------------------------------------------------

// LoginFailed

// string server = 1;
inline void LoginFailed::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginFailed::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LoginFailed.server)
  return server_.GetNoArena();
}
inline void LoginFailed::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LoginFailed.server)
}
#if LANG_CXX11
inline void LoginFailed::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LoginFailed.server)
}
#endif
inline void LoginFailed::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LoginFailed.server)
}
inline void LoginFailed::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LoginFailed.server)
}
inline ::std::string* LoginFailed::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LoginFailed.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginFailed::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.LoginFailed.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginFailed::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LoginFailed.server)
}

// .eve_launcher.LoginFailed.LoginErrorType error_type = 2;
inline void LoginFailed::clear_error_type() {
  error_type_ = 0;
}
inline ::eve_launcher::LoginFailed_LoginErrorType LoginFailed::error_type() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LoginFailed.error_type)
  return static_cast< ::eve_launcher::LoginFailed_LoginErrorType >(error_type_);
}
inline void LoginFailed::set_error_type(::eve_launcher::LoginFailed_LoginErrorType value) {
  
  error_type_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LoginFailed.error_type)
}

// -------------------------------------------------------------------

// UserAdded

// .eve_launcher.user.Identifier user_id = 1;
inline bool UserAdded::has_user_id() const {
  return this != internal_default_instance() && user_id_ != NULL;
}
inline const ::eve_launcher::user::Identifier& UserAdded::_internal_user_id() const {
  return *user_id_;
}
inline const ::eve_launcher::user::Identifier& UserAdded::user_id() const {
  const ::eve_launcher::user::Identifier* p = user_id_;
  // @@protoc_insertion_point(field_get:eve_launcher.UserAdded.user_id)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::user::Identifier*>(
      &::eve_launcher::user::_Identifier_default_instance_);
}
inline ::eve_launcher::user::Identifier* UserAdded::release_user_id() {
  // @@protoc_insertion_point(field_release:eve_launcher.UserAdded.user_id)
  
  ::eve_launcher::user::Identifier* temp = user_id_;
  user_id_ = NULL;
  return temp;
}
inline ::eve_launcher::user::Identifier* UserAdded::mutable_user_id() {
  
  if (user_id_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::user::Identifier>(GetArenaNoVirtual());
    user_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.UserAdded.user_id)
  return user_id_;
}
inline void UserAdded::set_allocated_user_id(::eve_launcher::user::Identifier* user_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_id_);
  }
  if (user_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_id, submessage_arena);
    }
    
  } else {
    
  }
  user_id_ = user_id;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UserAdded.user_id)
}

// string server = 2;
inline void UserAdded::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserAdded::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UserAdded.server)
  return server_.GetNoArena();
}
inline void UserAdded::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UserAdded.server)
}
#if LANG_CXX11
inline void UserAdded::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UserAdded.server)
}
#endif
inline void UserAdded::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UserAdded.server)
}
inline void UserAdded::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UserAdded.server)
}
inline ::std::string* UserAdded::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UserAdded.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserAdded::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.UserAdded.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserAdded::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UserAdded.server)
}

// .eve_launcher.UserAdded.RememberType remember_type = 3;
inline void UserAdded::clear_remember_type() {
  remember_type_ = 0;
}
inline ::eve_launcher::UserAdded_RememberType UserAdded::remember_type() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UserAdded.remember_type)
  return static_cast< ::eve_launcher::UserAdded_RememberType >(remember_type_);
}
inline void UserAdded::set_remember_type(::eve_launcher::UserAdded_RememberType value) {
  
  remember_type_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UserAdded.remember_type)
}

// -------------------------------------------------------------------

// UsersRemoved

// repeated .eve_launcher.user.Identifier user_ids = 1;
inline int UsersRemoved::user_ids_size() const {
  return user_ids_.size();
}
inline ::eve_launcher::user::Identifier* UsersRemoved::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.UsersRemoved.user_ids)
  return user_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
UsersRemoved::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.UsersRemoved.user_ids)
  return &user_ids_;
}
inline const ::eve_launcher::user::Identifier& UsersRemoved::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.UsersRemoved.user_ids)
  return user_ids_.Get(index);
}
inline ::eve_launcher::user::Identifier* UsersRemoved::add_user_ids() {
  // @@protoc_insertion_point(field_add:eve_launcher.UsersRemoved.user_ids)
  return user_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
UsersRemoved::user_ids() const {
  // @@protoc_insertion_point(field_list:eve_launcher.UsersRemoved.user_ids)
  return user_ids_;
}

// string server = 2;
inline void UsersRemoved::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UsersRemoved::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UsersRemoved.server)
  return server_.GetNoArena();
}
inline void UsersRemoved::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UsersRemoved.server)
}
#if LANG_CXX11
inline void UsersRemoved::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UsersRemoved.server)
}
#endif
inline void UsersRemoved::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UsersRemoved.server)
}
inline void UsersRemoved::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UsersRemoved.server)
}
inline ::std::string* UsersRemoved::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UsersRemoved.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UsersRemoved::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.UsersRemoved.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UsersRemoved::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UsersRemoved.server)
}

// -------------------------------------------------------------------

// PlayButtonClicked

// .eve_launcher.PlayButtonClicked.PlayButton source_button = 1;
inline void PlayButtonClicked::clear_source_button() {
  source_button_ = 0;
}
inline ::eve_launcher::PlayButtonClicked_PlayButton PlayButtonClicked::source_button() const {
  // @@protoc_insertion_point(field_get:eve_launcher.PlayButtonClicked.source_button)
  return static_cast< ::eve_launcher::PlayButtonClicked_PlayButton >(source_button_);
}
inline void PlayButtonClicked::set_source_button(::eve_launcher::PlayButtonClicked_PlayButton value) {
  
  source_button_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.PlayButtonClicked.source_button)
}

// string server = 2;
inline void PlayButtonClicked::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayButtonClicked::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.PlayButtonClicked.server)
  return server_.GetNoArena();
}
inline void PlayButtonClicked::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.PlayButtonClicked.server)
}
#if LANG_CXX11
inline void PlayButtonClicked::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.PlayButtonClicked.server)
}
#endif
inline void PlayButtonClicked::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.PlayButtonClicked.server)
}
inline void PlayButtonClicked::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.PlayButtonClicked.server)
}
inline ::std::string* PlayButtonClicked::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.PlayButtonClicked.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayButtonClicked::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.PlayButtonClicked.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayButtonClicked::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.PlayButtonClicked.server)
}

// repeated .eve_launcher.user.Identifier user_ids = 3;
inline int PlayButtonClicked::user_ids_size() const {
  return user_ids_.size();
}
inline ::eve_launcher::user::Identifier* PlayButtonClicked::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:eve_launcher.PlayButtonClicked.user_ids)
  return user_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >*
PlayButtonClicked::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:eve_launcher.PlayButtonClicked.user_ids)
  return &user_ids_;
}
inline const ::eve_launcher::user::Identifier& PlayButtonClicked::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:eve_launcher.PlayButtonClicked.user_ids)
  return user_ids_.Get(index);
}
inline ::eve_launcher::user::Identifier* PlayButtonClicked::add_user_ids() {
  // @@protoc_insertion_point(field_add:eve_launcher.PlayButtonClicked.user_ids)
  return user_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_launcher::user::Identifier >&
PlayButtonClicked::user_ids() const {
  // @@protoc_insertion_point(field_list:eve_launcher.PlayButtonClicked.user_ids)
  return user_ids_;
}

// -------------------------------------------------------------------

// LoginButtonClicked

// string server = 1;
inline void LoginButtonClicked::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginButtonClicked::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LoginButtonClicked.server)
  return server_.GetNoArena();
}
inline void LoginButtonClicked::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LoginButtonClicked.server)
}
#if LANG_CXX11
inline void LoginButtonClicked::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LoginButtonClicked.server)
}
#endif
inline void LoginButtonClicked::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LoginButtonClicked.server)
}
inline void LoginButtonClicked::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LoginButtonClicked.server)
}
inline ::std::string* LoginButtonClicked::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LoginButtonClicked.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginButtonClicked::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.LoginButtonClicked.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginButtonClicked::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LoginButtonClicked.server)
}

// -------------------------------------------------------------------

// BitnessWarningShown

// -------------------------------------------------------------------

// BitnessWarningClosed

// -------------------------------------------------------------------

// WebPageLoaded

// string start_url = 1;
inline void WebPageLoaded::clear_start_url() {
  start_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WebPageLoaded::start_url() const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebPageLoaded.start_url)
  return start_url_.GetNoArena();
}
inline void WebPageLoaded::set_start_url(const ::std::string& value) {
  
  start_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.WebPageLoaded.start_url)
}
#if LANG_CXX11
inline void WebPageLoaded::set_start_url(::std::string&& value) {
  
  start_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.WebPageLoaded.start_url)
}
#endif
inline void WebPageLoaded::set_start_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.WebPageLoaded.start_url)
}
inline void WebPageLoaded::set_start_url(const char* value, size_t size) {
  
  start_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.WebPageLoaded.start_url)
}
inline ::std::string* WebPageLoaded::mutable_start_url() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.WebPageLoaded.start_url)
  return start_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WebPageLoaded::release_start_url() {
  // @@protoc_insertion_point(field_release:eve_launcher.WebPageLoaded.start_url)
  
  return start_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WebPageLoaded::set_allocated_start_url(::std::string* start_url) {
  if (start_url != NULL) {
    
  } else {
    
  }
  start_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_url);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.WebPageLoaded.start_url)
}

// string finish_url = 2;
inline void WebPageLoaded::clear_finish_url() {
  finish_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WebPageLoaded::finish_url() const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebPageLoaded.finish_url)
  return finish_url_.GetNoArena();
}
inline void WebPageLoaded::set_finish_url(const ::std::string& value) {
  
  finish_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.WebPageLoaded.finish_url)
}
#if LANG_CXX11
inline void WebPageLoaded::set_finish_url(::std::string&& value) {
  
  finish_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.WebPageLoaded.finish_url)
}
#endif
inline void WebPageLoaded::set_finish_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  finish_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.WebPageLoaded.finish_url)
}
inline void WebPageLoaded::set_finish_url(const char* value, size_t size) {
  
  finish_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.WebPageLoaded.finish_url)
}
inline ::std::string* WebPageLoaded::mutable_finish_url() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.WebPageLoaded.finish_url)
  return finish_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WebPageLoaded::release_finish_url() {
  // @@protoc_insertion_point(field_release:eve_launcher.WebPageLoaded.finish_url)
  
  return finish_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WebPageLoaded::set_allocated_finish_url(::std::string* finish_url) {
  if (finish_url != NULL) {
    
  } else {
    
  }
  finish_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), finish_url);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.WebPageLoaded.finish_url)
}

// uint32 load_duration_milliseconds = 3;
inline void WebPageLoaded::clear_load_duration_milliseconds() {
  load_duration_milliseconds_ = 0u;
}
inline ::google::protobuf::uint32 WebPageLoaded::load_duration_milliseconds() const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebPageLoaded.load_duration_milliseconds)
  return load_duration_milliseconds_;
}
inline void WebPageLoaded::set_load_duration_milliseconds(::google::protobuf::uint32 value) {
  
  load_duration_milliseconds_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.WebPageLoaded.load_duration_milliseconds)
}

// bool success = 4;
inline void WebPageLoaded::clear_success() {
  success_ = false;
}
inline bool WebPageLoaded::success() const {
  // @@protoc_insertion_point(field_get:eve_launcher.WebPageLoaded.success)
  return success_;
}
inline void WebPageLoaded::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.WebPageLoaded.success)
}

// -------------------------------------------------------------------

// AssignedToExperiment

// string name = 1;
inline void AssignedToExperiment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssignedToExperiment::name() const {
  // @@protoc_insertion_point(field_get:eve_launcher.AssignedToExperiment.name)
  return name_.GetNoArena();
}
inline void AssignedToExperiment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.AssignedToExperiment.name)
}
#if LANG_CXX11
inline void AssignedToExperiment::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.AssignedToExperiment.name)
}
#endif
inline void AssignedToExperiment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.AssignedToExperiment.name)
}
inline void AssignedToExperiment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.AssignedToExperiment.name)
}
inline ::std::string* AssignedToExperiment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.AssignedToExperiment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssignedToExperiment::release_name() {
  // @@protoc_insertion_point(field_release:eve_launcher.AssignedToExperiment.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssignedToExperiment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.AssignedToExperiment.name)
}

// string group = 2;
inline void AssignedToExperiment::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssignedToExperiment::group() const {
  // @@protoc_insertion_point(field_get:eve_launcher.AssignedToExperiment.group)
  return group_.GetNoArena();
}
inline void AssignedToExperiment::set_group(const ::std::string& value) {
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.AssignedToExperiment.group)
}
#if LANG_CXX11
inline void AssignedToExperiment::set_group(::std::string&& value) {
  
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.AssignedToExperiment.group)
}
#endif
inline void AssignedToExperiment::set_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.AssignedToExperiment.group)
}
inline void AssignedToExperiment::set_group(const char* value, size_t size) {
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.AssignedToExperiment.group)
}
inline ::std::string* AssignedToExperiment::mutable_group() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.AssignedToExperiment.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssignedToExperiment::release_group() {
  // @@protoc_insertion_point(field_release:eve_launcher.AssignedToExperiment.group)
  
  return group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssignedToExperiment::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    
  } else {
    
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.AssignedToExperiment.group)
}

// -------------------------------------------------------------------

// LoginFlowStarted

// .eve_launcher.LoginFlowStarted.DisplayMethod display_method = 1;
inline void LoginFlowStarted::clear_display_method() {
  display_method_ = 0;
}
inline ::eve_launcher::LoginFlowStarted_DisplayMethod LoginFlowStarted::display_method() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LoginFlowStarted.display_method)
  return static_cast< ::eve_launcher::LoginFlowStarted_DisplayMethod >(display_method_);
}
inline void LoginFlowStarted::set_display_method(::eve_launcher::LoginFlowStarted_DisplayMethod value) {
  
  display_method_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LoginFlowStarted.display_method)
}

// -------------------------------------------------------------------

// SystemBrowserOpened

// string url = 1;
inline void SystemBrowserOpened::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemBrowserOpened::url() const {
  // @@protoc_insertion_point(field_get:eve_launcher.SystemBrowserOpened.url)
  return url_.GetNoArena();
}
inline void SystemBrowserOpened::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.SystemBrowserOpened.url)
}
#if LANG_CXX11
inline void SystemBrowserOpened::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.SystemBrowserOpened.url)
}
#endif
inline void SystemBrowserOpened::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.SystemBrowserOpened.url)
}
inline void SystemBrowserOpened::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.SystemBrowserOpened.url)
}
inline ::std::string* SystemBrowserOpened::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.SystemBrowserOpened.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemBrowserOpened::release_url() {
  // @@protoc_insertion_point(field_release:eve_launcher.SystemBrowserOpened.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemBrowserOpened::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.SystemBrowserOpened.url)
}

// string medium = 2;
inline void SystemBrowserOpened::clear_medium() {
  medium_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemBrowserOpened::medium() const {
  // @@protoc_insertion_point(field_get:eve_launcher.SystemBrowserOpened.medium)
  return medium_.GetNoArena();
}
inline void SystemBrowserOpened::set_medium(const ::std::string& value) {
  
  medium_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.SystemBrowserOpened.medium)
}
#if LANG_CXX11
inline void SystemBrowserOpened::set_medium(::std::string&& value) {
  
  medium_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.SystemBrowserOpened.medium)
}
#endif
inline void SystemBrowserOpened::set_medium(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  medium_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.SystemBrowserOpened.medium)
}
inline void SystemBrowserOpened::set_medium(const char* value, size_t size) {
  
  medium_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.SystemBrowserOpened.medium)
}
inline ::std::string* SystemBrowserOpened::mutable_medium() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.SystemBrowserOpened.medium)
  return medium_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemBrowserOpened::release_medium() {
  // @@protoc_insertion_point(field_release:eve_launcher.SystemBrowserOpened.medium)
  
  return medium_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemBrowserOpened::set_allocated_medium(::std::string* medium) {
  if (medium != NULL) {
    
  } else {
    
  }
  medium_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), medium);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.SystemBrowserOpened.medium)
}

// -------------------------------------------------------------------

// FileUpdateFailed

// uint32 error_code = 1;
inline void FileUpdateFailed::clear_error_code() {
  error_code_ = 0u;
}
inline ::google::protobuf::uint32 FileUpdateFailed::error_code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.FileUpdateFailed.error_code)
  return error_code_;
}
inline void FileUpdateFailed::set_error_code(::google::protobuf::uint32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.FileUpdateFailed.error_code)
}

// bool rescheduled = 2;
inline void FileUpdateFailed::clear_rescheduled() {
  rescheduled_ = false;
}
inline bool FileUpdateFailed::rescheduled() const {
  // @@protoc_insertion_point(field_get:eve_launcher.FileUpdateFailed.rescheduled)
  return rescheduled_;
}
inline void FileUpdateFailed::set_rescheduled(bool value) {
  
  rescheduled_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.FileUpdateFailed.rescheduled)
}

// string url = 3;
inline void FileUpdateFailed::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileUpdateFailed::url() const {
  // @@protoc_insertion_point(field_get:eve_launcher.FileUpdateFailed.url)
  return url_.GetNoArena();
}
inline void FileUpdateFailed::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.FileUpdateFailed.url)
}
#if LANG_CXX11
inline void FileUpdateFailed::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.FileUpdateFailed.url)
}
#endif
inline void FileUpdateFailed::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.FileUpdateFailed.url)
}
inline void FileUpdateFailed::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.FileUpdateFailed.url)
}
inline ::std::string* FileUpdateFailed::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.FileUpdateFailed.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileUpdateFailed::release_url() {
  // @@protoc_insertion_point(field_release:eve_launcher.FileUpdateFailed.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileUpdateFailed::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.FileUpdateFailed.url)
}

// .eve_launcher.FileUpdateFailed.DownloadType download_type = 4;
inline void FileUpdateFailed::clear_download_type() {
  download_type_ = 0;
}
inline ::eve_launcher::FileUpdateFailed_DownloadType FileUpdateFailed::download_type() const {
  // @@protoc_insertion_point(field_get:eve_launcher.FileUpdateFailed.download_type)
  return static_cast< ::eve_launcher::FileUpdateFailed_DownloadType >(download_type_);
}
inline void FileUpdateFailed::set_download_type(::eve_launcher::FileUpdateFailed_DownloadType value) {
  
  download_type_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.FileUpdateFailed.download_type)
}

// float download_speed = 5;
inline void FileUpdateFailed::clear_download_speed() {
  download_speed_ = 0;
}
inline float FileUpdateFailed::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.FileUpdateFailed.download_speed)
  return download_speed_;
}
inline void FileUpdateFailed::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.FileUpdateFailed.download_speed)
}

// -------------------------------------------------------------------

// DownloadInterrupted

// float download_speed = 1;
inline void DownloadInterrupted::clear_download_speed() {
  download_speed_ = 0;
}
inline float DownloadInterrupted::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DownloadInterrupted.download_speed)
  return download_speed_;
}
inline void DownloadInterrupted::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.DownloadInterrupted.download_speed)
}

// string target_version = 2;
inline void DownloadInterrupted::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DownloadInterrupted::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DownloadInterrupted.target_version)
  return target_version_.GetNoArena();
}
inline void DownloadInterrupted::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.DownloadInterrupted.target_version)
}
#if LANG_CXX11
inline void DownloadInterrupted::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.DownloadInterrupted.target_version)
}
#endif
inline void DownloadInterrupted::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.DownloadInterrupted.target_version)
}
inline void DownloadInterrupted::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.DownloadInterrupted.target_version)
}
inline ::std::string* DownloadInterrupted::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.DownloadInterrupted.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DownloadInterrupted::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.DownloadInterrupted.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInterrupted::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.DownloadInterrupted.target_version)
}

// uint64 bytes_downloaded = 3;
inline void DownloadInterrupted::clear_bytes_downloaded() {
  bytes_downloaded_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DownloadInterrupted::bytes_downloaded() const {
  // @@protoc_insertion_point(field_get:eve_launcher.DownloadInterrupted.bytes_downloaded)
  return bytes_downloaded_;
}
inline void DownloadInterrupted::set_bytes_downloaded(::google::protobuf::uint64 value) {
  
  bytes_downloaded_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.DownloadInterrupted.bytes_downloaded)
}

// -------------------------------------------------------------------

// LauncherUpdateDownloaded

// string target_version = 1;
inline void LauncherUpdateDownloaded::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LauncherUpdateDownloaded::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateDownloaded.target_version)
  return target_version_.GetNoArena();
}
inline void LauncherUpdateDownloaded::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateDownloaded.target_version)
}
#if LANG_CXX11
inline void LauncherUpdateDownloaded::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LauncherUpdateDownloaded.target_version)
}
#endif
inline void LauncherUpdateDownloaded::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LauncherUpdateDownloaded.target_version)
}
inline void LauncherUpdateDownloaded::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LauncherUpdateDownloaded.target_version)
}
inline ::std::string* LauncherUpdateDownloaded::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LauncherUpdateDownloaded.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LauncherUpdateDownloaded::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.LauncherUpdateDownloaded.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LauncherUpdateDownloaded::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LauncherUpdateDownloaded.target_version)
}

// float download_speed = 2;
inline void LauncherUpdateDownloaded::clear_download_speed() {
  download_speed_ = 0;
}
inline float LauncherUpdateDownloaded::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateDownloaded.download_speed)
  return download_speed_;
}
inline void LauncherUpdateDownloaded::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateDownloaded.download_speed)
}

// -------------------------------------------------------------------

// LauncherUpdateFailed

// uint32 error_code = 1;
inline void LauncherUpdateFailed::clear_error_code() {
  error_code_ = 0u;
}
inline ::google::protobuf::uint32 LauncherUpdateFailed::error_code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateFailed.error_code)
  return error_code_;
}
inline void LauncherUpdateFailed::set_error_code(::google::protobuf::uint32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateFailed.error_code)
}

// string target_version = 2;
inline void LauncherUpdateFailed::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LauncherUpdateFailed::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateFailed.target_version)
  return target_version_.GetNoArena();
}
inline void LauncherUpdateFailed::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateFailed.target_version)
}
#if LANG_CXX11
inline void LauncherUpdateFailed::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LauncherUpdateFailed.target_version)
}
#endif
inline void LauncherUpdateFailed::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LauncherUpdateFailed.target_version)
}
inline void LauncherUpdateFailed::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LauncherUpdateFailed.target_version)
}
inline ::std::string* LauncherUpdateFailed::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LauncherUpdateFailed.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LauncherUpdateFailed::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.LauncherUpdateFailed.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LauncherUpdateFailed::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LauncherUpdateFailed.target_version)
}

// float download_speed = 3;
inline void LauncherUpdateFailed::clear_download_speed() {
  download_speed_ = 0;
}
inline float LauncherUpdateFailed::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateFailed.download_speed)
  return download_speed_;
}
inline void LauncherUpdateFailed::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateFailed.download_speed)
}

// -------------------------------------------------------------------

// UiSettings

// bool settings_changed = 1;
inline void UiSettings::clear_settings_changed() {
  settings_changed_ = false;
}
inline bool UiSettings::settings_changed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UiSettings.settings_changed)
  return settings_changed_;
}
inline void UiSettings::set_settings_changed(bool value) {
  
  settings_changed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UiSettings.settings_changed)
}

// bool start_client_on_login = 2;
inline void UiSettings::clear_start_client_on_login() {
  start_client_on_login_ = false;
}
inline bool UiSettings::start_client_on_login() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UiSettings.start_client_on_login)
  return start_client_on_login_;
}
inline void UiSettings::set_start_client_on_login(bool value) {
  
  start_client_on_login_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UiSettings.start_client_on_login)
}

// uint32 startup_delay_seconds = 3;
inline void UiSettings::clear_startup_delay_seconds() {
  startup_delay_seconds_ = 0u;
}
inline ::google::protobuf::uint32 UiSettings::startup_delay_seconds() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UiSettings.startup_delay_seconds)
  return startup_delay_seconds_;
}
inline void UiSettings::set_startup_delay_seconds(::google::protobuf::uint32 value) {
  
  startup_delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UiSettings.startup_delay_seconds)
}

// bool remember_accounts = 4;
inline void UiSettings::clear_remember_accounts() {
  remember_accounts_ = false;
}
inline bool UiSettings::remember_accounts() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UiSettings.remember_accounts)
  return remember_accounts_;
}
inline void UiSettings::set_remember_accounts(bool value) {
  
  remember_accounts_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UiSettings.remember_accounts)
}

// bool debug_logs_enabled = 5;
inline void UiSettings::clear_debug_logs_enabled() {
  debug_logs_enabled_ = false;
}
inline bool UiSettings::debug_logs_enabled() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UiSettings.debug_logs_enabled)
  return debug_logs_enabled_;
}
inline void UiSettings::set_debug_logs_enabled(bool value) {
  
  debug_logs_enabled_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UiSettings.debug_logs_enabled)
}

// -------------------------------------------------------------------

// UserRememberToggled

// .eve_launcher.user.Identifier user_id = 1;
inline bool UserRememberToggled::has_user_id() const {
  return this != internal_default_instance() && user_id_ != NULL;
}
inline const ::eve_launcher::user::Identifier& UserRememberToggled::_internal_user_id() const {
  return *user_id_;
}
inline const ::eve_launcher::user::Identifier& UserRememberToggled::user_id() const {
  const ::eve_launcher::user::Identifier* p = user_id_;
  // @@protoc_insertion_point(field_get:eve_launcher.UserRememberToggled.user_id)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::user::Identifier*>(
      &::eve_launcher::user::_Identifier_default_instance_);
}
inline ::eve_launcher::user::Identifier* UserRememberToggled::release_user_id() {
  // @@protoc_insertion_point(field_release:eve_launcher.UserRememberToggled.user_id)
  
  ::eve_launcher::user::Identifier* temp = user_id_;
  user_id_ = NULL;
  return temp;
}
inline ::eve_launcher::user::Identifier* UserRememberToggled::mutable_user_id() {
  
  if (user_id_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::user::Identifier>(GetArenaNoVirtual());
    user_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.UserRememberToggled.user_id)
  return user_id_;
}
inline void UserRememberToggled::set_allocated_user_id(::eve_launcher::user::Identifier* user_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_id_);
  }
  if (user_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_id, submessage_arena);
    }
    
  } else {
    
  }
  user_id_ = user_id;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UserRememberToggled.user_id)
}

// string server = 2;
inline void UserRememberToggled::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRememberToggled::server() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UserRememberToggled.server)
  return server_.GetNoArena();
}
inline void UserRememberToggled::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UserRememberToggled.server)
}
#if LANG_CXX11
inline void UserRememberToggled::set_server(::std::string&& value) {
  
  server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UserRememberToggled.server)
}
#endif
inline void UserRememberToggled::set_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UserRememberToggled.server)
}
inline void UserRememberToggled::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UserRememberToggled.server)
}
inline ::std::string* UserRememberToggled::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UserRememberToggled.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRememberToggled::release_server() {
  // @@protoc_insertion_point(field_release:eve_launcher.UserRememberToggled.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRememberToggled::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UserRememberToggled.server)
}

// bool remember_enabled = 3;
inline void UserRememberToggled::clear_remember_enabled() {
  remember_enabled_ = false;
}
inline bool UserRememberToggled::remember_enabled() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UserRememberToggled.remember_enabled)
  return remember_enabled_;
}
inline void UserRememberToggled::set_remember_enabled(bool value) {
  
  remember_enabled_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UserRememberToggled.remember_enabled)
}

// -------------------------------------------------------------------

// LauncherUpdateCancelled

// string target_version = 1;
inline void LauncherUpdateCancelled::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LauncherUpdateCancelled::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateCancelled.target_version)
  return target_version_.GetNoArena();
}
inline void LauncherUpdateCancelled::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateCancelled.target_version)
}
#if LANG_CXX11
inline void LauncherUpdateCancelled::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LauncherUpdateCancelled.target_version)
}
#endif
inline void LauncherUpdateCancelled::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LauncherUpdateCancelled.target_version)
}
inline void LauncherUpdateCancelled::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LauncherUpdateCancelled.target_version)
}
inline ::std::string* LauncherUpdateCancelled::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LauncherUpdateCancelled.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LauncherUpdateCancelled::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.LauncherUpdateCancelled.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LauncherUpdateCancelled::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LauncherUpdateCancelled.target_version)
}

// float download_speed = 2;
inline void LauncherUpdateCancelled::clear_download_speed() {
  download_speed_ = 0;
}
inline float LauncherUpdateCancelled::download_speed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateCancelled.download_speed)
  return download_speed_;
}
inline void LauncherUpdateCancelled::set_download_speed(float value) {
  
  download_speed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateCancelled.download_speed)
}

// -------------------------------------------------------------------

// LauncherUpdateAccepted

// string target_version = 1;
inline void LauncherUpdateAccepted::clear_target_version() {
  target_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LauncherUpdateAccepted::target_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateAccepted.target_version)
  return target_version_.GetNoArena();
}
inline void LauncherUpdateAccepted::set_target_version(const ::std::string& value) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateAccepted.target_version)
}
#if LANG_CXX11
inline void LauncherUpdateAccepted::set_target_version(::std::string&& value) {
  
  target_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.LauncherUpdateAccepted.target_version)
}
#endif
inline void LauncherUpdateAccepted::set_target_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.LauncherUpdateAccepted.target_version)
}
inline void LauncherUpdateAccepted::set_target_version(const char* value, size_t size) {
  
  target_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.LauncherUpdateAccepted.target_version)
}
inline ::std::string* LauncherUpdateAccepted::mutable_target_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.LauncherUpdateAccepted.target_version)
  return target_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LauncherUpdateAccepted::release_target_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.LauncherUpdateAccepted.target_version)
  
  return target_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LauncherUpdateAccepted::set_allocated_target_version(::std::string* target_version) {
  if (target_version != NULL) {
    
  } else {
    
  }
  target_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.LauncherUpdateAccepted.target_version)
}

// bool automatic = 2;
inline void LauncherUpdateAccepted::clear_automatic() {
  automatic_ = false;
}
inline bool LauncherUpdateAccepted::automatic() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateAccepted.automatic)
  return automatic_;
}
inline void LauncherUpdateAccepted::set_automatic(bool value) {
  
  automatic_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateAccepted.automatic)
}

// bool updater_started = 3;
inline void LauncherUpdateAccepted::clear_updater_started() {
  updater_started_ = false;
}
inline bool LauncherUpdateAccepted::updater_started() const {
  // @@protoc_insertion_point(field_get:eve_launcher.LauncherUpdateAccepted.updater_started)
  return updater_started_;
}
inline void LauncherUpdateAccepted::set_updater_started(bool value) {
  
  updater_started_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.LauncherUpdateAccepted.updater_started)
}

// -------------------------------------------------------------------

// CertificateErrorOccurred

// string url = 1;
inline void CertificateErrorOccurred::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CertificateErrorOccurred::url() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CertificateErrorOccurred.url)
  return url_.GetNoArena();
}
inline void CertificateErrorOccurred::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.CertificateErrorOccurred.url)
}
#if LANG_CXX11
inline void CertificateErrorOccurred::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.CertificateErrorOccurred.url)
}
#endif
inline void CertificateErrorOccurred::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.CertificateErrorOccurred.url)
}
inline void CertificateErrorOccurred::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.CertificateErrorOccurred.url)
}
inline ::std::string* CertificateErrorOccurred::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.CertificateErrorOccurred.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CertificateErrorOccurred::release_url() {
  // @@protoc_insertion_point(field_release:eve_launcher.CertificateErrorOccurred.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CertificateErrorOccurred::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.CertificateErrorOccurred.url)
}

// .eve_launcher.IPAddress host_ip = 2;
inline bool CertificateErrorOccurred::has_host_ip() const {
  return this != internal_default_instance() && host_ip_ != NULL;
}
inline void CertificateErrorOccurred::clear_host_ip() {
  if (GetArenaNoVirtual() == NULL && host_ip_ != NULL) {
    delete host_ip_;
  }
  host_ip_ = NULL;
}
inline const ::eve_launcher::IPAddress& CertificateErrorOccurred::_internal_host_ip() const {
  return *host_ip_;
}
inline const ::eve_launcher::IPAddress& CertificateErrorOccurred::host_ip() const {
  const ::eve_launcher::IPAddress* p = host_ip_;
  // @@protoc_insertion_point(field_get:eve_launcher.CertificateErrorOccurred.host_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::IPAddress*>(
      &::eve_launcher::_IPAddress_default_instance_);
}
inline ::eve_launcher::IPAddress* CertificateErrorOccurred::release_host_ip() {
  // @@protoc_insertion_point(field_release:eve_launcher.CertificateErrorOccurred.host_ip)
  
  ::eve_launcher::IPAddress* temp = host_ip_;
  host_ip_ = NULL;
  return temp;
}
inline ::eve_launcher::IPAddress* CertificateErrorOccurred::mutable_host_ip() {
  
  if (host_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::IPAddress>(GetArenaNoVirtual());
    host_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.CertificateErrorOccurred.host_ip)
  return host_ip_;
}
inline void CertificateErrorOccurred::set_allocated_host_ip(::eve_launcher::IPAddress* host_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_ip_;
  }
  if (host_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_ip, submessage_arena);
    }
    
  } else {
    
  }
  host_ip_ = host_ip;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.CertificateErrorOccurred.host_ip)
}

// int32 error_code = 3;
inline void CertificateErrorOccurred::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 CertificateErrorOccurred::error_code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CertificateErrorOccurred.error_code)
  return error_code_;
}
inline void CertificateErrorOccurred::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.CertificateErrorOccurred.error_code)
}

// bool user_prompted = 4;
inline void CertificateErrorOccurred::clear_user_prompted() {
  user_prompted_ = false;
}
inline bool CertificateErrorOccurred::user_prompted() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CertificateErrorOccurred.user_prompted)
  return user_prompted_;
}
inline void CertificateErrorOccurred::set_user_prompted(bool value) {
  
  user_prompted_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.CertificateErrorOccurred.user_prompted)
}

// bool user_ignored = 5;
inline void CertificateErrorOccurred::clear_user_ignored() {
  user_ignored_ = false;
}
inline bool CertificateErrorOccurred::user_ignored() const {
  // @@protoc_insertion_point(field_get:eve_launcher.CertificateErrorOccurred.user_ignored)
  return user_ignored_;
}
inline void CertificateErrorOccurred::set_user_ignored(bool value) {
  
  user_ignored_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.CertificateErrorOccurred.user_ignored)
}

// -------------------------------------------------------------------

// UnpackingBundlesStarted

// uint32 bundle_count = 1;
inline void UnpackingBundlesStarted::clear_bundle_count() {
  bundle_count_ = 0u;
}
inline ::google::protobuf::uint32 UnpackingBundlesStarted::bundle_count() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesStarted.bundle_count)
  return bundle_count_;
}
inline void UnpackingBundlesStarted::set_bundle_count(::google::protobuf::uint32 value) {
  
  bundle_count_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesStarted.bundle_count)
}

// uint32 file_count = 2;
inline void UnpackingBundlesStarted::clear_file_count() {
  file_count_ = 0u;
}
inline ::google::protobuf::uint32 UnpackingBundlesStarted::file_count() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesStarted.file_count)
  return file_count_;
}
inline void UnpackingBundlesStarted::set_file_count(::google::protobuf::uint32 value) {
  
  file_count_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesStarted.file_count)
}

// -------------------------------------------------------------------

// UnpackingBundlesFailed

// string file_name = 1;
inline void UnpackingBundlesFailed::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnpackingBundlesFailed::file_name() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesFailed.file_name)
  return file_name_.GetNoArena();
}
inline void UnpackingBundlesFailed::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesFailed.file_name)
}
#if LANG_CXX11
inline void UnpackingBundlesFailed::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.UnpackingBundlesFailed.file_name)
}
#endif
inline void UnpackingBundlesFailed::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.UnpackingBundlesFailed.file_name)
}
inline void UnpackingBundlesFailed::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.UnpackingBundlesFailed.file_name)
}
inline ::std::string* UnpackingBundlesFailed::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.UnpackingBundlesFailed.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnpackingBundlesFailed::release_file_name() {
  // @@protoc_insertion_point(field_release:eve_launcher.UnpackingBundlesFailed.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnpackingBundlesFailed::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.UnpackingBundlesFailed.file_name)
}

// .eve_launcher.UnpackingBundlesFailed.UnpackingStage stage = 2;
inline void UnpackingBundlesFailed::clear_stage() {
  stage_ = 0;
}
inline ::eve_launcher::UnpackingBundlesFailed_UnpackingStage UnpackingBundlesFailed::stage() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesFailed.stage)
  return static_cast< ::eve_launcher::UnpackingBundlesFailed_UnpackingStage >(stage_);
}
inline void UnpackingBundlesFailed::set_stage(::eve_launcher::UnpackingBundlesFailed_UnpackingStage value) {
  
  stage_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesFailed.stage)
}

// -------------------------------------------------------------------

// UnpackingBundlesCompleted

// uint32 bundle_count = 1;
inline void UnpackingBundlesCompleted::clear_bundle_count() {
  bundle_count_ = 0u;
}
inline ::google::protobuf::uint32 UnpackingBundlesCompleted::bundle_count() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesCompleted.bundle_count)
  return bundle_count_;
}
inline void UnpackingBundlesCompleted::set_bundle_count(::google::protobuf::uint32 value) {
  
  bundle_count_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesCompleted.bundle_count)
}

// uint32 file_count = 2;
inline void UnpackingBundlesCompleted::clear_file_count() {
  file_count_ = 0u;
}
inline ::google::protobuf::uint32 UnpackingBundlesCompleted::file_count() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesCompleted.file_count)
  return file_count_;
}
inline void UnpackingBundlesCompleted::set_file_count(::google::protobuf::uint32 value) {
  
  file_count_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesCompleted.file_count)
}

// uint64 extracted_byte_size = 3;
inline void UnpackingBundlesCompleted::clear_extracted_byte_size() {
  extracted_byte_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UnpackingBundlesCompleted::extracted_byte_size() const {
  // @@protoc_insertion_point(field_get:eve_launcher.UnpackingBundlesCompleted.extracted_byte_size)
  return extracted_byte_size_;
}
inline void UnpackingBundlesCompleted::set_extracted_byte_size(::google::protobuf::uint64 value) {
  
  extracted_byte_size_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.UnpackingBundlesCompleted.extracted_byte_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace eve_launcher

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eve_launcher::Application_BuildTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::Application_BuildTag>() {
  return ::eve_launcher::Application_BuildTag_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::Application_Locale> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::Application_Locale>() {
  return ::eve_launcher::Application_Locale_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::OS_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::OS_Kind>() {
  return ::eve_launcher::OS_Kind_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::WebLoaded_Platform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::WebLoaded_Platform>() {
  return ::eve_launcher::WebLoaded_Platform_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::LoginFailed_LoginErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::LoginFailed_LoginErrorType>() {
  return ::eve_launcher::LoginFailed_LoginErrorType_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::UserAdded_RememberType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::UserAdded_RememberType>() {
  return ::eve_launcher::UserAdded_RememberType_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::PlayButtonClicked_PlayButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::PlayButtonClicked_PlayButton>() {
  return ::eve_launcher::PlayButtonClicked_PlayButton_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::LoginFlowStarted_DisplayMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::LoginFlowStarted_DisplayMethod>() {
  return ::eve_launcher::LoginFlowStarted_DisplayMethod_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::FileUpdateFailed_DownloadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::FileUpdateFailed_DownloadType>() {
  return ::eve_launcher::FileUpdateFailed_DownloadType_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::UnpackingBundlesFailed_UnpackingStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::UnpackingBundlesFailed_UnpackingStage>() {
  return ::eve_launcher::UnpackingBundlesFailed_UnpackingStage_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::Bitness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::Bitness>() {
  return ::eve_launcher::Bitness_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_eve_5flauncher_2flauncher_2eproto
