// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eve_launcher/installer.proto

#ifndef PROTOBUF_INCLUDED_eve_5flauncher_2finstaller_2eproto
#define PROTOBUF_INCLUDED_eve_5flauncher_2finstaller_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_eve_5flauncher_2finstaller_2eproto 

namespace protobuf_eve_5flauncher_2finstaller_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_eve_5flauncher_2finstaller_2eproto
namespace eve_launcher {
namespace installer {
class Application;
class ApplicationDefaultTypeInternal;
extern ApplicationDefaultTypeInternal _Application_default_instance_;
class AutoRunChanged;
class AutoRunChangedDefaultTypeInternal;
extern AutoRunChangedDefaultTypeInternal _AutoRunChanged_default_instance_;
class DetailsVisibilityChanged;
class DetailsVisibilityChangedDefaultTypeInternal;
extern DetailsVisibilityChangedDefaultTypeInternal _DetailsVisibilityChanged_default_instance_;
class ErrorEncountered;
class ErrorEncounteredDefaultTypeInternal;
extern ErrorEncounteredDefaultTypeInternal _ErrorEncountered_default_instance_;
class EulaAcceptanceChanged;
class EulaAcceptanceChangedDefaultTypeInternal;
extern EulaAcceptanceChangedDefaultTypeInternal _EulaAcceptanceChanged_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventMetadata;
class EventMetadataDefaultTypeInternal;
extern EventMetadataDefaultTypeInternal _EventMetadata_default_instance_;
class IPAddress;
class IPAddressDefaultTypeInternal;
extern IPAddressDefaultTypeInternal _IPAddress_default_instance_;
class LocationChanged;
class LocationChangedDefaultTypeInternal;
extern LocationChangedDefaultTypeInternal _LocationChanged_default_instance_;
class MessageBoxClosed;
class MessageBoxClosedDefaultTypeInternal;
extern MessageBoxClosedDefaultTypeInternal _MessageBoxClosed_default_instance_;
class MessageBoxShown;
class MessageBoxShownDefaultTypeInternal;
extern MessageBoxShownDefaultTypeInternal _MessageBoxShown_default_instance_;
class PageDisplayed;
class PageDisplayedDefaultTypeInternal;
extern PageDisplayedDefaultTypeInternal _PageDisplayed_default_instance_;
class PreparationFinished;
class PreparationFinishedDefaultTypeInternal;
extern PreparationFinishedDefaultTypeInternal _PreparationFinished_default_instance_;
class PreparationStarted;
class PreparationStartedDefaultTypeInternal;
extern PreparationStartedDefaultTypeInternal _PreparationStarted_default_instance_;
class ProvidedClientFound;
class ProvidedClientFoundDefaultTypeInternal;
extern ProvidedClientFoundDefaultTypeInternal _ProvidedClientFound_default_instance_;
class RedistSearchConcluded;
class RedistSearchConcludedDefaultTypeInternal;
extern RedistSearchConcludedDefaultTypeInternal _RedistSearchConcluded_default_instance_;
class ShutDown;
class ShutDownDefaultTypeInternal;
extern ShutDownDefaultTypeInternal _ShutDown_default_instance_;
class Started;
class StartedDefaultTypeInternal;
extern StartedDefaultTypeInternal _Started_default_instance_;
class StepExecuted;
class StepExecutedDefaultTypeInternal;
extern StepExecutedDefaultTypeInternal _StepExecuted_default_instance_;
class UserCancelled;
class UserCancelledDefaultTypeInternal;
extern UserCancelledDefaultTypeInternal _UserCancelled_default_instance_;
}  // namespace installer
}  // namespace eve_launcher
namespace google {
namespace protobuf {
template<> ::eve_launcher::installer::Application* Arena::CreateMaybeMessage<::eve_launcher::installer::Application>(Arena*);
template<> ::eve_launcher::installer::AutoRunChanged* Arena::CreateMaybeMessage<::eve_launcher::installer::AutoRunChanged>(Arena*);
template<> ::eve_launcher::installer::DetailsVisibilityChanged* Arena::CreateMaybeMessage<::eve_launcher::installer::DetailsVisibilityChanged>(Arena*);
template<> ::eve_launcher::installer::ErrorEncountered* Arena::CreateMaybeMessage<::eve_launcher::installer::ErrorEncountered>(Arena*);
template<> ::eve_launcher::installer::EulaAcceptanceChanged* Arena::CreateMaybeMessage<::eve_launcher::installer::EulaAcceptanceChanged>(Arena*);
template<> ::eve_launcher::installer::Event* Arena::CreateMaybeMessage<::eve_launcher::installer::Event>(Arena*);
template<> ::eve_launcher::installer::EventMetadata* Arena::CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(Arena*);
template<> ::eve_launcher::installer::IPAddress* Arena::CreateMaybeMessage<::eve_launcher::installer::IPAddress>(Arena*);
template<> ::eve_launcher::installer::LocationChanged* Arena::CreateMaybeMessage<::eve_launcher::installer::LocationChanged>(Arena*);
template<> ::eve_launcher::installer::MessageBoxClosed* Arena::CreateMaybeMessage<::eve_launcher::installer::MessageBoxClosed>(Arena*);
template<> ::eve_launcher::installer::MessageBoxShown* Arena::CreateMaybeMessage<::eve_launcher::installer::MessageBoxShown>(Arena*);
template<> ::eve_launcher::installer::PageDisplayed* Arena::CreateMaybeMessage<::eve_launcher::installer::PageDisplayed>(Arena*);
template<> ::eve_launcher::installer::PreparationFinished* Arena::CreateMaybeMessage<::eve_launcher::installer::PreparationFinished>(Arena*);
template<> ::eve_launcher::installer::PreparationStarted* Arena::CreateMaybeMessage<::eve_launcher::installer::PreparationStarted>(Arena*);
template<> ::eve_launcher::installer::ProvidedClientFound* Arena::CreateMaybeMessage<::eve_launcher::installer::ProvidedClientFound>(Arena*);
template<> ::eve_launcher::installer::RedistSearchConcluded* Arena::CreateMaybeMessage<::eve_launcher::installer::RedistSearchConcluded>(Arena*);
template<> ::eve_launcher::installer::ShutDown* Arena::CreateMaybeMessage<::eve_launcher::installer::ShutDown>(Arena*);
template<> ::eve_launcher::installer::Started* Arena::CreateMaybeMessage<::eve_launcher::installer::Started>(Arena*);
template<> ::eve_launcher::installer::StepExecuted* Arena::CreateMaybeMessage<::eve_launcher::installer::StepExecuted>(Arena*);
template<> ::eve_launcher::installer::UserCancelled* Arena::CreateMaybeMessage<::eve_launcher::installer::UserCancelled>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace eve_launcher {
namespace installer {

enum Application_BuildType {
  Application_BuildType_BUILD_TYPE_UNKNOWN = 0,
  Application_BuildType_BUILD_TYPE_RELEASE = 1,
  Application_BuildType_BUILD_TYPE_BETA = 2,
  Application_BuildType_BUILD_TYPE_DEV = 3,
  Application_BuildType_Application_BuildType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_BuildType_Application_BuildType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_BuildType_IsValid(int value);
const Application_BuildType Application_BuildType_BuildType_MIN = Application_BuildType_BUILD_TYPE_UNKNOWN;
const Application_BuildType Application_BuildType_BuildType_MAX = Application_BuildType_BUILD_TYPE_DEV;
const int Application_BuildType_BuildType_ARRAYSIZE = Application_BuildType_BuildType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_BuildType_descriptor();
inline const ::std::string& Application_BuildType_Name(Application_BuildType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_BuildType_descriptor(), value);
}
inline bool Application_BuildType_Parse(
    const ::std::string& name, Application_BuildType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_BuildType>(
    Application_BuildType_descriptor(), name, value);
}
enum Application_Locale {
  Application_Locale_LOCALE_UNKNOWN = 0,
  Application_Locale_LOCALE_WORLD = 1,
  Application_Locale_LOCALE_CHINA = 2,
  Application_Locale_Application_Locale_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_Locale_Application_Locale_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_Locale_IsValid(int value);
const Application_Locale Application_Locale_Locale_MIN = Application_Locale_LOCALE_UNKNOWN;
const Application_Locale Application_Locale_Locale_MAX = Application_Locale_LOCALE_CHINA;
const int Application_Locale_Locale_ARRAYSIZE = Application_Locale_Locale_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_Locale_descriptor();
inline const ::std::string& Application_Locale_Name(Application_Locale value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_Locale_descriptor(), value);
}
inline bool Application_Locale_Parse(
    const ::std::string& name, Application_Locale* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_Locale>(
    Application_Locale_descriptor(), name, value);
}
enum Application_ApplicationType {
  Application_ApplicationType_APPLICATION_TYPE_UNKNOWN = 0,
  Application_ApplicationType_APPLICATION_TYPE_NOT_FOUND = 1,
  Application_ApplicationType_APPLICATION_TYPE_INSTALLER = 2,
  Application_ApplicationType_APPLICATION_TYPE_LAUNCHER = 3,
  Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER = 4,
  Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER_UPDATER = 5,
  Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER_PACKAGE_MANAGER = 6,
  Application_ApplicationType_Application_ApplicationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_ApplicationType_Application_ApplicationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_ApplicationType_IsValid(int value);
const Application_ApplicationType Application_ApplicationType_ApplicationType_MIN = Application_ApplicationType_APPLICATION_TYPE_UNKNOWN;
const Application_ApplicationType Application_ApplicationType_ApplicationType_MAX = Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER_PACKAGE_MANAGER;
const int Application_ApplicationType_ApplicationType_ARRAYSIZE = Application_ApplicationType_ApplicationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_ApplicationType_descriptor();
inline const ::std::string& Application_ApplicationType_Name(Application_ApplicationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_ApplicationType_descriptor(), value);
}
inline bool Application_ApplicationType_Parse(
    const ::std::string& name, Application_ApplicationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_ApplicationType>(
    Application_ApplicationType_descriptor(), name, value);
}
enum PageDisplayed_FlowDirection {
  PageDisplayed_FlowDirection_FLOW_DIRECTION_UNKNOWN = 0,
  PageDisplayed_FlowDirection_FLOW_DIRECTION_FIRST_VIEW = 1,
  PageDisplayed_FlowDirection_FLOW_DIRECTION_FORWARDS = 2,
  PageDisplayed_FlowDirection_FLOW_DIRECTION_BACKWARDS = 3,
  PageDisplayed_FlowDirection_FLOW_DIRECTION_RELOAD = 4,
  PageDisplayed_FlowDirection_PageDisplayed_FlowDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PageDisplayed_FlowDirection_PageDisplayed_FlowDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PageDisplayed_FlowDirection_IsValid(int value);
const PageDisplayed_FlowDirection PageDisplayed_FlowDirection_FlowDirection_MIN = PageDisplayed_FlowDirection_FLOW_DIRECTION_UNKNOWN;
const PageDisplayed_FlowDirection PageDisplayed_FlowDirection_FlowDirection_MAX = PageDisplayed_FlowDirection_FLOW_DIRECTION_RELOAD;
const int PageDisplayed_FlowDirection_FlowDirection_ARRAYSIZE = PageDisplayed_FlowDirection_FlowDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* PageDisplayed_FlowDirection_descriptor();
inline const ::std::string& PageDisplayed_FlowDirection_Name(PageDisplayed_FlowDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    PageDisplayed_FlowDirection_descriptor(), value);
}
inline bool PageDisplayed_FlowDirection_Parse(
    const ::std::string& name, PageDisplayed_FlowDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PageDisplayed_FlowDirection>(
    PageDisplayed_FlowDirection_descriptor(), name, value);
}
enum UserCancelled_Progress {
  UserCancelled_Progress_PROGRESS_UNKNOWN = 0,
  UserCancelled_Progress_PROGRESS_NOT_STARTED = 1,
  UserCancelled_Progress_PROGRESS_RUNNING = 2,
  UserCancelled_Progress_PROGRESS_FINISHED = 3,
  UserCancelled_Progress_PROGRESS_FAILED = 4,
  UserCancelled_Progress_UserCancelled_Progress_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserCancelled_Progress_UserCancelled_Progress_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserCancelled_Progress_IsValid(int value);
const UserCancelled_Progress UserCancelled_Progress_Progress_MIN = UserCancelled_Progress_PROGRESS_UNKNOWN;
const UserCancelled_Progress UserCancelled_Progress_Progress_MAX = UserCancelled_Progress_PROGRESS_FAILED;
const int UserCancelled_Progress_Progress_ARRAYSIZE = UserCancelled_Progress_Progress_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserCancelled_Progress_descriptor();
inline const ::std::string& UserCancelled_Progress_Name(UserCancelled_Progress value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserCancelled_Progress_descriptor(), value);
}
inline bool UserCancelled_Progress_Parse(
    const ::std::string& name, UserCancelled_Progress* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserCancelled_Progress>(
    UserCancelled_Progress_descriptor(), name, value);
}
enum ShutDown_State {
  ShutDown_State_STATE_UNKNOWN = 0,
  ShutDown_State_STATE_PROCESS_COMPLETED_SUCCESSFULLY = 1,
  ShutDown_State_STATE_PROCESS_FAILED = 2,
  ShutDown_State_STATE_PROCESS_NOT_BEGUN = 3,
  ShutDown_State_ShutDown_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShutDown_State_ShutDown_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShutDown_State_IsValid(int value);
const ShutDown_State ShutDown_State_State_MIN = ShutDown_State_STATE_UNKNOWN;
const ShutDown_State ShutDown_State_State_MAX = ShutDown_State_STATE_PROCESS_NOT_BEGUN;
const int ShutDown_State_State_ARRAYSIZE = ShutDown_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShutDown_State_descriptor();
inline const ::std::string& ShutDown_State_Name(ShutDown_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShutDown_State_descriptor(), value);
}
inline bool ShutDown_State_Parse(
    const ::std::string& name, ShutDown_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShutDown_State>(
    ShutDown_State_descriptor(), name, value);
}
enum LocationChanged_Source {
  LocationChanged_Source_SOURCE_UNKNOWN = 0,
  LocationChanged_Source_SOURCE_INSTALL_DIRECTORY = 1,
  LocationChanged_Source_SOURCE_START_MENU_LOCATION = 2,
  LocationChanged_Source_SOURCE_SHARED_CACHE_FOLDER = 3,
  LocationChanged_Source_LocationChanged_Source_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LocationChanged_Source_LocationChanged_Source_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LocationChanged_Source_IsValid(int value);
const LocationChanged_Source LocationChanged_Source_Source_MIN = LocationChanged_Source_SOURCE_UNKNOWN;
const LocationChanged_Source LocationChanged_Source_Source_MAX = LocationChanged_Source_SOURCE_SHARED_CACHE_FOLDER;
const int LocationChanged_Source_Source_ARRAYSIZE = LocationChanged_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationChanged_Source_descriptor();
inline const ::std::string& LocationChanged_Source_Name(LocationChanged_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationChanged_Source_descriptor(), value);
}
inline bool LocationChanged_Source_Parse(
    const ::std::string& name, LocationChanged_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationChanged_Source>(
    LocationChanged_Source_descriptor(), name, value);
}
enum LocationChanged_Provider {
  LocationChanged_Provider_PROVIDER_UNKNOWN = 0,
  LocationChanged_Provider_PROVIDER_USER = 1,
  LocationChanged_Provider_PROVIDER_SYSTEM = 2,
  LocationChanged_Provider_LocationChanged_Provider_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LocationChanged_Provider_LocationChanged_Provider_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LocationChanged_Provider_IsValid(int value);
const LocationChanged_Provider LocationChanged_Provider_Provider_MIN = LocationChanged_Provider_PROVIDER_UNKNOWN;
const LocationChanged_Provider LocationChanged_Provider_Provider_MAX = LocationChanged_Provider_PROVIDER_SYSTEM;
const int LocationChanged_Provider_Provider_ARRAYSIZE = LocationChanged_Provider_Provider_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationChanged_Provider_descriptor();
inline const ::std::string& LocationChanged_Provider_Name(LocationChanged_Provider value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationChanged_Provider_descriptor(), value);
}
inline bool LocationChanged_Provider_Parse(
    const ::std::string& name, LocationChanged_Provider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationChanged_Provider>(
    LocationChanged_Provider_descriptor(), name, value);
}
enum RedistSearchConcluded_RedistReason {
  RedistSearchConcluded_RedistReason_REDIST_REASON_UNKNOWN = 0,
  RedistSearchConcluded_RedistReason_REDIST_REASON_NOT_WINDOWS = 1,
  RedistSearchConcluded_RedistReason_REDIST_REASON_INCLUDED_IN_WINDOWS_VERSION = 2,
  RedistSearchConcluded_RedistReason_REDIST_REASON_FOUND_DLLS = 3,
  RedistSearchConcluded_RedistReason_REDIST_REASON_FOUND_WINDOWS_UPDATE = 4,
  RedistSearchConcluded_RedistReason_REDIST_REASON_WINDOWS_UPDATE_MISSING = 5,
  RedistSearchConcluded_RedistReason_REDIST_REASON_REDIST_MISSING = 6,
  RedistSearchConcluded_RedistReason_RedistSearchConcluded_RedistReason_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RedistSearchConcluded_RedistReason_RedistSearchConcluded_RedistReason_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RedistSearchConcluded_RedistReason_IsValid(int value);
const RedistSearchConcluded_RedistReason RedistSearchConcluded_RedistReason_RedistReason_MIN = RedistSearchConcluded_RedistReason_REDIST_REASON_UNKNOWN;
const RedistSearchConcluded_RedistReason RedistSearchConcluded_RedistReason_RedistReason_MAX = RedistSearchConcluded_RedistReason_REDIST_REASON_REDIST_MISSING;
const int RedistSearchConcluded_RedistReason_RedistReason_ARRAYSIZE = RedistSearchConcluded_RedistReason_RedistReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* RedistSearchConcluded_RedistReason_descriptor();
inline const ::std::string& RedistSearchConcluded_RedistReason_Name(RedistSearchConcluded_RedistReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    RedistSearchConcluded_RedistReason_descriptor(), value);
}
inline bool RedistSearchConcluded_RedistReason_Parse(
    const ::std::string& name, RedistSearchConcluded_RedistReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RedistSearchConcluded_RedistReason>(
    RedistSearchConcluded_RedistReason_descriptor(), name, value);
}
enum MessageBoxClosed_MessageBoxButton {
  MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_UNKNOWN = 0,
  MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_YES = 1,
  MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_NO = 2,
  MessageBoxClosed_MessageBoxButton_MessageBoxClosed_MessageBoxButton_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageBoxClosed_MessageBoxButton_MessageBoxClosed_MessageBoxButton_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageBoxClosed_MessageBoxButton_IsValid(int value);
const MessageBoxClosed_MessageBoxButton MessageBoxClosed_MessageBoxButton_MessageBoxButton_MIN = MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_UNKNOWN;
const MessageBoxClosed_MessageBoxButton MessageBoxClosed_MessageBoxButton_MessageBoxButton_MAX = MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_NO;
const int MessageBoxClosed_MessageBoxButton_MessageBoxButton_ARRAYSIZE = MessageBoxClosed_MessageBoxButton_MessageBoxButton_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageBoxClosed_MessageBoxButton_descriptor();
inline const ::std::string& MessageBoxClosed_MessageBoxButton_Name(MessageBoxClosed_MessageBoxButton value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageBoxClosed_MessageBoxButton_descriptor(), value);
}
inline bool MessageBoxClosed_MessageBoxButton_Parse(
    const ::std::string& name, MessageBoxClosed_MessageBoxButton* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageBoxClosed_MessageBoxButton>(
    MessageBoxClosed_MessageBoxButton_descriptor(), name, value);
}
enum StepExecuted_Step {
  StepExecuted_Step_STEP_UNKNOWN = 0,
  StepExecuted_Step_STEP_STARTED = 1,
  StepExecuted_Step_STEP_FINISHED = 2,
  StepExecuted_Step_STEP_INTERRUPTED = 3,
  StepExecuted_Step_STEP_COMPONENTS_INIT_STARTED = 4,
  StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_INIT_STARTED = 5,
  StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_INTI_FINISHED = 6,
  StepExecuted_Step_STEP_COMPONENTS_INIT_FINISHED = 7,
  StepExecuted_Step_STEP_COMPONENTS_EXECUTION_STARTED = 8,
  StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_EXECUTION_STARTED = 9,
  StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_EXECUTION_FINISHED = 10,
  StepExecuted_Step_STEP_COMPONENTS_EXECUTION_FINISHED = 11,
  StepExecuted_Step_STEP_MAINTENANCE_TOOL_CREATION_STARTED = 12,
  StepExecuted_Step_STEP_MAINTENANCE_TOOL_CREATION_FINISHED = 13,
  StepExecuted_Step_StepExecuted_Step_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StepExecuted_Step_StepExecuted_Step_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StepExecuted_Step_IsValid(int value);
const StepExecuted_Step StepExecuted_Step_Step_MIN = StepExecuted_Step_STEP_UNKNOWN;
const StepExecuted_Step StepExecuted_Step_Step_MAX = StepExecuted_Step_STEP_MAINTENANCE_TOOL_CREATION_FINISHED;
const int StepExecuted_Step_Step_ARRAYSIZE = StepExecuted_Step_Step_MAX + 1;

const ::google::protobuf::EnumDescriptor* StepExecuted_Step_descriptor();
inline const ::std::string& StepExecuted_Step_Name(StepExecuted_Step value) {
  return ::google::protobuf::internal::NameOfEnum(
    StepExecuted_Step_descriptor(), value);
}
inline bool StepExecuted_Step_Parse(
    const ::std::string& name, StepExecuted_Step* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StepExecuted_Step>(
    StepExecuted_Step_descriptor(), name, value);
}
enum ErrorEncountered_ErrorCode {
  ErrorEncountered_ErrorCode_ERROR_CODE_UNKNOWN = 0,
  ErrorEncountered_ErrorCode_ERROR_CODE_CREATE_OPERATIONS = 1,
  ErrorEncountered_ErrorCode_ERROR_CODE_ADD_OPERATION = 2,
  ErrorEncountered_ErrorCode_ERROR_CODE_SEARCH_DLL = 3,
  ErrorEncountered_ErrorCode_ERROR_CODE_SEARCH_WINDOWS_UPDATE = 4,
  ErrorEncountered_ErrorCode_ERROR_CODE_MISSING_PREREQUISITE = 5,
  ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_FAILURE = 6,
  ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_UNFINISHED = 7,
  ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_FORCE_UPDATE = 8,
  ErrorEncountered_ErrorCode_ErrorEncountered_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorEncountered_ErrorCode_ErrorEncountered_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorEncountered_ErrorCode_IsValid(int value);
const ErrorEncountered_ErrorCode ErrorEncountered_ErrorCode_ErrorCode_MIN = ErrorEncountered_ErrorCode_ERROR_CODE_UNKNOWN;
const ErrorEncountered_ErrorCode ErrorEncountered_ErrorCode_ErrorCode_MAX = ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_FORCE_UPDATE;
const int ErrorEncountered_ErrorCode_ErrorCode_ARRAYSIZE = ErrorEncountered_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorEncountered_ErrorCode_descriptor();
inline const ::std::string& ErrorEncountered_ErrorCode_Name(ErrorEncountered_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorEncountered_ErrorCode_descriptor(), value);
}
inline bool ErrorEncountered_ErrorCode_Parse(
    const ::std::string& name, ErrorEncountered_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorEncountered_ErrorCode>(
    ErrorEncountered_ErrorCode_descriptor(), name, value);
}
enum Page {
  PAGE_UNKNOWN = 0,
  PAGE_NOT_FOUND = 1,
  PAGE_NO_PAGE = 2,
  PAGE_INTRODUCTION = 3,
  PAGE_TARGET_DIRECTORY = 4,
  PAGE_COMPONENT_SELECTION = 5,
  PAGE_EULA = 6,
  PAGE_START_MENU = 7,
  PAGE_READY = 8,
  PAGE_EXECUTION = 9,
  PAGE_FINISHED = 10,
  PAGE_FAILED = 11,
  Page_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Page_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Page_IsValid(int value);
const Page Page_MIN = PAGE_UNKNOWN;
const Page Page_MAX = PAGE_FAILED;
const int Page_ARRAYSIZE = Page_MAX + 1;

const ::google::protobuf::EnumDescriptor* Page_descriptor();
inline const ::std::string& Page_Name(Page value) {
  return ::google::protobuf::internal::NameOfEnum(
    Page_descriptor(), value);
}
inline bool Page_Parse(
    const ::std::string& name, Page* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Page>(
    Page_descriptor(), name, value);
}
enum RedistVersion {
  REDIST_VERSION_UNKNOWN = 0,
  REDIST_VERSION_NONE = 1,
  REDIST_VERSION_7SP1_X64 = 2,
  REDIST_VERSION_7SP1_X86 = 3,
  REDIST_VERSION_8_X64 = 4,
  REDIST_VERSION_8_X86 = 5,
  REDIST_VERSION_81_X64 = 6,
  REDIST_VERSION_81_X86 = 7,
  RedistVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RedistVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RedistVersion_IsValid(int value);
const RedistVersion RedistVersion_MIN = REDIST_VERSION_UNKNOWN;
const RedistVersion RedistVersion_MAX = REDIST_VERSION_81_X86;
const int RedistVersion_ARRAYSIZE = RedistVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* RedistVersion_descriptor();
inline const ::std::string& RedistVersion_Name(RedistVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    RedistVersion_descriptor(), value);
}
inline bool RedistVersion_Parse(
    const ::std::string& name, RedistVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RedistVersion>(
    RedistVersion_descriptor(), name, value);
}
enum MessageBox {
  MESSAGE_BOX_UNKNOWN = 0,
  MESSAGE_BOX_SHARED_CACHE = 1,
  MessageBox_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageBox_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageBox_IsValid(int value);
const MessageBox MessageBox_MIN = MESSAGE_BOX_UNKNOWN;
const MessageBox MessageBox_MAX = MESSAGE_BOX_SHARED_CACHE;
const int MessageBox_ARRAYSIZE = MessageBox_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageBox_descriptor();
inline const ::std::string& MessageBox_Name(MessageBox value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageBox_descriptor(), value);
}
inline bool MessageBox_Parse(
    const ::std::string& name, MessageBox* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageBox>(
    MessageBox_descriptor(), name, value);
}
enum Component {
  COMPONENT_UNKNOWN = 0,
  COMPONENT_NONE = 1,
  COMPONENT_LAUNCHER = 2,
  COMPONENT_REDIST = 3,
  Component_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Component_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Component_IsValid(int value);
const Component Component_MIN = COMPONENT_UNKNOWN;
const Component Component_MAX = COMPONENT_REDIST;
const int Component_ARRAYSIZE = Component_MAX + 1;

const ::google::protobuf::EnumDescriptor* Component_descriptor();
inline const ::std::string& Component_Name(Component value) {
  return ::google::protobuf::internal::NameOfEnum(
    Component_descriptor(), value);
}
inline bool Component_Parse(
    const ::std::string& name, Component* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Component>(
    Component_descriptor(), name, value);
}
// ===================================================================

class EventMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.EventMetadata) */ {
 public:
  EventMetadata();
  virtual ~EventMetadata();

  EventMetadata(const EventMetadata& from);

  inline EventMetadata& operator=(const EventMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventMetadata(EventMetadata&& from) noexcept
    : EventMetadata() {
    *this = ::std::move(from);
  }

  inline EventMetadata& operator=(EventMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventMetadata* internal_default_instance() {
    return reinterpret_cast<const EventMetadata*>(
               &_EventMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EventMetadata* other);
  friend void swap(EventMetadata& a, EventMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventMetadata* New() const final {
    return CreateMaybeMessage<EventMetadata>(NULL);
  }

  EventMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventMetadata& from);
  void MergeFrom(const EventMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes md5_session = 1;
  void clear_md5_session();
  static const int kMd5SessionFieldNumber = 1;
  const ::std::string& md5_session() const;
  void set_md5_session(const ::std::string& value);
  #if LANG_CXX11
  void set_md5_session(::std::string&& value);
  #endif
  void set_md5_session(const char* value);
  void set_md5_session(const void* value, size_t size);
  ::std::string* mutable_md5_session();
  ::std::string* release_md5_session();
  void set_allocated_md5_session(::std::string* md5_session);

  // bytes operating_system_uuid = 3;
  void clear_operating_system_uuid();
  static const int kOperatingSystemUuidFieldNumber = 3;
  const ::std::string& operating_system_uuid() const;
  void set_operating_system_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_operating_system_uuid(::std::string&& value);
  #endif
  void set_operating_system_uuid(const char* value);
  void set_operating_system_uuid(const void* value, size_t size);
  ::std::string* mutable_operating_system_uuid();
  ::std::string* release_operating_system_uuid();
  void set_allocated_operating_system_uuid(::std::string* operating_system_uuid);

  // .eve_launcher.installer.Application application = 2;
  bool has_application() const;
  void clear_application();
  static const int kApplicationFieldNumber = 2;
  private:
  const ::eve_launcher::installer::Application& _internal_application() const;
  public:
  const ::eve_launcher::installer::Application& application() const;
  ::eve_launcher::installer::Application* release_application();
  ::eve_launcher::installer::Application* mutable_application();
  void set_allocated_application(::eve_launcher::installer::Application* application);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.EventMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr md5_session_;
  ::google::protobuf::internal::ArenaStringPtr operating_system_uuid_;
  ::eve_launcher::installer::Application* application_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Application : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.Application) */ {
 public:
  Application();
  virtual ~Application();

  Application(const Application& from);

  inline Application& operator=(const Application& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Application(Application&& from) noexcept
    : Application() {
    *this = ::std::move(from);
  }

  inline Application& operator=(Application&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Application& default_instance();

  enum ProviderCase {
    kNoInstallerProvider = 5,
    kInstallerProvider = 6,
    PROVIDER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Application* internal_default_instance() {
    return reinterpret_cast<const Application*>(
               &_Application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Application* other);
  friend void swap(Application& a, Application& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Application* New() const final {
    return CreateMaybeMessage<Application>(NULL);
  }

  Application* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Application>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Application& from);
  void MergeFrom(const Application& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Application* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Application_BuildType BuildType;
  static const BuildType BUILD_TYPE_UNKNOWN =
    Application_BuildType_BUILD_TYPE_UNKNOWN;
  static const BuildType BUILD_TYPE_RELEASE =
    Application_BuildType_BUILD_TYPE_RELEASE;
  static const BuildType BUILD_TYPE_BETA =
    Application_BuildType_BUILD_TYPE_BETA;
  static const BuildType BUILD_TYPE_DEV =
    Application_BuildType_BUILD_TYPE_DEV;
  static inline bool BuildType_IsValid(int value) {
    return Application_BuildType_IsValid(value);
  }
  static const BuildType BuildType_MIN =
    Application_BuildType_BuildType_MIN;
  static const BuildType BuildType_MAX =
    Application_BuildType_BuildType_MAX;
  static const int BuildType_ARRAYSIZE =
    Application_BuildType_BuildType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BuildType_descriptor() {
    return Application_BuildType_descriptor();
  }
  static inline const ::std::string& BuildType_Name(BuildType value) {
    return Application_BuildType_Name(value);
  }
  static inline bool BuildType_Parse(const ::std::string& name,
      BuildType* value) {
    return Application_BuildType_Parse(name, value);
  }

  typedef Application_Locale Locale;
  static const Locale LOCALE_UNKNOWN =
    Application_Locale_LOCALE_UNKNOWN;
  static const Locale LOCALE_WORLD =
    Application_Locale_LOCALE_WORLD;
  static const Locale LOCALE_CHINA =
    Application_Locale_LOCALE_CHINA;
  static inline bool Locale_IsValid(int value) {
    return Application_Locale_IsValid(value);
  }
  static const Locale Locale_MIN =
    Application_Locale_Locale_MIN;
  static const Locale Locale_MAX =
    Application_Locale_Locale_MAX;
  static const int Locale_ARRAYSIZE =
    Application_Locale_Locale_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Locale_descriptor() {
    return Application_Locale_descriptor();
  }
  static inline const ::std::string& Locale_Name(Locale value) {
    return Application_Locale_Name(value);
  }
  static inline bool Locale_Parse(const ::std::string& name,
      Locale* value) {
    return Application_Locale_Parse(name, value);
  }

  typedef Application_ApplicationType ApplicationType;
  static const ApplicationType APPLICATION_TYPE_UNKNOWN =
    Application_ApplicationType_APPLICATION_TYPE_UNKNOWN;
  static const ApplicationType APPLICATION_TYPE_NOT_FOUND =
    Application_ApplicationType_APPLICATION_TYPE_NOT_FOUND;
  static const ApplicationType APPLICATION_TYPE_INSTALLER =
    Application_ApplicationType_APPLICATION_TYPE_INSTALLER;
  static const ApplicationType APPLICATION_TYPE_LAUNCHER =
    Application_ApplicationType_APPLICATION_TYPE_LAUNCHER;
  static const ApplicationType APPLICATION_TYPE_UNINSTALLER =
    Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER;
  static const ApplicationType APPLICATION_TYPE_UNINSTALLER_UPDATER =
    Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER_UPDATER;
  static const ApplicationType APPLICATION_TYPE_UNINSTALLER_PACKAGE_MANAGER =
    Application_ApplicationType_APPLICATION_TYPE_UNINSTALLER_PACKAGE_MANAGER;
  static inline bool ApplicationType_IsValid(int value) {
    return Application_ApplicationType_IsValid(value);
  }
  static const ApplicationType ApplicationType_MIN =
    Application_ApplicationType_ApplicationType_MIN;
  static const ApplicationType ApplicationType_MAX =
    Application_ApplicationType_ApplicationType_MAX;
  static const int ApplicationType_ARRAYSIZE =
    Application_ApplicationType_ApplicationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ApplicationType_descriptor() {
    return Application_ApplicationType_descriptor();
  }
  static inline const ::std::string& ApplicationType_Name(ApplicationType value) {
    return Application_ApplicationType_Name(value);
  }
  static inline bool ApplicationType_Parse(const ::std::string& name,
      ApplicationType* value) {
    return Application_ApplicationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .eve_launcher.installer.Application.BuildType build_type = 2;
  void clear_build_type();
  static const int kBuildTypeFieldNumber = 2;
  ::eve_launcher::installer::Application_BuildType build_type() const;
  void set_build_type(::eve_launcher::installer::Application_BuildType value);

  // .eve_launcher.installer.Application.Locale locale = 3;
  void clear_locale();
  static const int kLocaleFieldNumber = 3;
  ::eve_launcher::installer::Application_Locale locale() const;
  void set_locale(::eve_launcher::installer::Application_Locale value);

  // .eve_launcher.installer.Application.ApplicationType application_type = 4;
  void clear_application_type();
  static const int kApplicationTypeFieldNumber = 4;
  ::eve_launcher::installer::Application_ApplicationType application_type() const;
  void set_application_type(::eve_launcher::installer::Application_ApplicationType value);

  // bool no_installer_provider = 5;
  private:
  bool has_no_installer_provider() const;
  public:
  void clear_no_installer_provider();
  static const int kNoInstallerProviderFieldNumber = 5;
  bool no_installer_provider() const;
  void set_no_installer_provider(bool value);

  // string installer_provider = 6;
  private:
  bool has_installer_provider() const;
  public:
  void clear_installer_provider();
  static const int kInstallerProviderFieldNumber = 6;
  const ::std::string& installer_provider() const;
  void set_installer_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_installer_provider(::std::string&& value);
  #endif
  void set_installer_provider(const char* value);
  void set_installer_provider(const char* value, size_t size);
  ::std::string* mutable_installer_provider();
  ::std::string* release_installer_provider();
  void set_allocated_installer_provider(::std::string* installer_provider);

  void clear_provider();
  ProviderCase provider_case() const;
  // @@protoc_insertion_point(class_scope:eve_launcher.installer.Application)
 private:
  void set_has_no_installer_provider();
  void set_has_installer_provider();

  inline bool has_provider() const;
  inline void clear_has_provider();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  int build_type_;
  int locale_;
  int application_type_;
  union ProviderUnion {
    ProviderUnion() {}
    bool no_installer_provider_;
    ::google::protobuf::internal::ArenaStringPtr installer_provider_;
  } provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Started : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.Started) */ {
 public:
  Started();
  virtual ~Started();

  Started(const Started& from);

  inline Started& operator=(const Started& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Started(Started&& from) noexcept
    : Started() {
    *this = ::std::move(from);
  }

  inline Started& operator=(Started&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Started& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Started* internal_default_instance() {
    return reinterpret_cast<const Started*>(
               &_Started_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Started* other);
  friend void swap(Started& a, Started& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Started* New() const final {
    return CreateMaybeMessage<Started>(NULL);
  }

  Started* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Started>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Started& from);
  void MergeFrom(const Started& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Started* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // int32 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.Started)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  ::google::protobuf::int32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PageDisplayed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.PageDisplayed) */ {
 public:
  PageDisplayed();
  virtual ~PageDisplayed();

  PageDisplayed(const PageDisplayed& from);

  inline PageDisplayed& operator=(const PageDisplayed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PageDisplayed(PageDisplayed&& from) noexcept
    : PageDisplayed() {
    *this = ::std::move(from);
  }

  inline PageDisplayed& operator=(PageDisplayed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PageDisplayed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PageDisplayed* internal_default_instance() {
    return reinterpret_cast<const PageDisplayed*>(
               &_PageDisplayed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PageDisplayed* other);
  friend void swap(PageDisplayed& a, PageDisplayed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PageDisplayed* New() const final {
    return CreateMaybeMessage<PageDisplayed>(NULL);
  }

  PageDisplayed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PageDisplayed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PageDisplayed& from);
  void MergeFrom(const PageDisplayed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PageDisplayed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PageDisplayed_FlowDirection FlowDirection;
  static const FlowDirection FLOW_DIRECTION_UNKNOWN =
    PageDisplayed_FlowDirection_FLOW_DIRECTION_UNKNOWN;
  static const FlowDirection FLOW_DIRECTION_FIRST_VIEW =
    PageDisplayed_FlowDirection_FLOW_DIRECTION_FIRST_VIEW;
  static const FlowDirection FLOW_DIRECTION_FORWARDS =
    PageDisplayed_FlowDirection_FLOW_DIRECTION_FORWARDS;
  static const FlowDirection FLOW_DIRECTION_BACKWARDS =
    PageDisplayed_FlowDirection_FLOW_DIRECTION_BACKWARDS;
  static const FlowDirection FLOW_DIRECTION_RELOAD =
    PageDisplayed_FlowDirection_FLOW_DIRECTION_RELOAD;
  static inline bool FlowDirection_IsValid(int value) {
    return PageDisplayed_FlowDirection_IsValid(value);
  }
  static const FlowDirection FlowDirection_MIN =
    PageDisplayed_FlowDirection_FlowDirection_MIN;
  static const FlowDirection FlowDirection_MAX =
    PageDisplayed_FlowDirection_FlowDirection_MAX;
  static const int FlowDirection_ARRAYSIZE =
    PageDisplayed_FlowDirection_FlowDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlowDirection_descriptor() {
    return PageDisplayed_FlowDirection_descriptor();
  }
  static inline const ::std::string& FlowDirection_Name(FlowDirection value) {
    return PageDisplayed_FlowDirection_Name(value);
  }
  static inline bool FlowDirection_Parse(const ::std::string& name,
      FlowDirection* value) {
    return PageDisplayed_FlowDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.Page previous_page = 2;
  void clear_previous_page();
  static const int kPreviousPageFieldNumber = 2;
  ::eve_launcher::installer::Page previous_page() const;
  void set_previous_page(::eve_launcher::installer::Page value);

  // .eve_launcher.installer.Page current_page = 3;
  void clear_current_page();
  static const int kCurrentPageFieldNumber = 3;
  ::eve_launcher::installer::Page current_page() const;
  void set_current_page(::eve_launcher::installer::Page value);

  // .eve_launcher.installer.PageDisplayed.FlowDirection flow = 4;
  void clear_flow();
  static const int kFlowFieldNumber = 4;
  ::eve_launcher::installer::PageDisplayed_FlowDirection flow() const;
  void set_flow(::eve_launcher::installer::PageDisplayed_FlowDirection value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.PageDisplayed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int previous_page_;
  int current_page_;
  int flow_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserCancelled : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.UserCancelled) */ {
 public:
  UserCancelled();
  virtual ~UserCancelled();

  UserCancelled(const UserCancelled& from);

  inline UserCancelled& operator=(const UserCancelled& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserCancelled(UserCancelled&& from) noexcept
    : UserCancelled() {
    *this = ::std::move(from);
  }

  inline UserCancelled& operator=(UserCancelled&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCancelled& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserCancelled* internal_default_instance() {
    return reinterpret_cast<const UserCancelled*>(
               &_UserCancelled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UserCancelled* other);
  friend void swap(UserCancelled& a, UserCancelled& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserCancelled* New() const final {
    return CreateMaybeMessage<UserCancelled>(NULL);
  }

  UserCancelled* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserCancelled>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserCancelled& from);
  void MergeFrom(const UserCancelled& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserCancelled* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserCancelled_Progress Progress;
  static const Progress PROGRESS_UNKNOWN =
    UserCancelled_Progress_PROGRESS_UNKNOWN;
  static const Progress PROGRESS_NOT_STARTED =
    UserCancelled_Progress_PROGRESS_NOT_STARTED;
  static const Progress PROGRESS_RUNNING =
    UserCancelled_Progress_PROGRESS_RUNNING;
  static const Progress PROGRESS_FINISHED =
    UserCancelled_Progress_PROGRESS_FINISHED;
  static const Progress PROGRESS_FAILED =
    UserCancelled_Progress_PROGRESS_FAILED;
  static inline bool Progress_IsValid(int value) {
    return UserCancelled_Progress_IsValid(value);
  }
  static const Progress Progress_MIN =
    UserCancelled_Progress_Progress_MIN;
  static const Progress Progress_MAX =
    UserCancelled_Progress_Progress_MAX;
  static const int Progress_ARRAYSIZE =
    UserCancelled_Progress_Progress_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Progress_descriptor() {
    return UserCancelled_Progress_descriptor();
  }
  static inline const ::std::string& Progress_Name(Progress value) {
    return UserCancelled_Progress_Name(value);
  }
  static inline bool Progress_Parse(const ::std::string& name,
      Progress* value) {
    return UserCancelled_Progress_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.Page page = 2;
  void clear_page();
  static const int kPageFieldNumber = 2;
  ::eve_launcher::installer::Page page() const;
  void set_page(::eve_launcher::installer::Page value);

  // .eve_launcher.installer.UserCancelled.Progress progress = 3;
  void clear_progress();
  static const int kProgressFieldNumber = 3;
  ::eve_launcher::installer::UserCancelled_Progress progress() const;
  void set_progress(::eve_launcher::installer::UserCancelled_Progress value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.UserCancelled)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int page_;
  int progress_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShutDown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.ShutDown) */ {
 public:
  ShutDown();
  virtual ~ShutDown();

  ShutDown(const ShutDown& from);

  inline ShutDown& operator=(const ShutDown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShutDown(ShutDown&& from) noexcept
    : ShutDown() {
    *this = ::std::move(from);
  }

  inline ShutDown& operator=(ShutDown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutDown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutDown* internal_default_instance() {
    return reinterpret_cast<const ShutDown*>(
               &_ShutDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ShutDown* other);
  friend void swap(ShutDown& a, ShutDown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShutDown* New() const final {
    return CreateMaybeMessage<ShutDown>(NULL);
  }

  ShutDown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShutDown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShutDown& from);
  void MergeFrom(const ShutDown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutDown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShutDown_State State;
  static const State STATE_UNKNOWN =
    ShutDown_State_STATE_UNKNOWN;
  static const State STATE_PROCESS_COMPLETED_SUCCESSFULLY =
    ShutDown_State_STATE_PROCESS_COMPLETED_SUCCESSFULLY;
  static const State STATE_PROCESS_FAILED =
    ShutDown_State_STATE_PROCESS_FAILED;
  static const State STATE_PROCESS_NOT_BEGUN =
    ShutDown_State_STATE_PROCESS_NOT_BEGUN;
  static inline bool State_IsValid(int value) {
    return ShutDown_State_IsValid(value);
  }
  static const State State_MIN =
    ShutDown_State_State_MIN;
  static const State State_MAX =
    ShutDown_State_State_MAX;
  static const int State_ARRAYSIZE =
    ShutDown_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ShutDown_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ShutDown_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ShutDown_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.Page page = 2;
  void clear_page();
  static const int kPageFieldNumber = 2;
  ::eve_launcher::installer::Page page() const;
  void set_page(::eve_launcher::installer::Page value);

  // .eve_launcher.installer.ShutDown.State state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::eve_launcher::installer::ShutDown_State state() const;
  void set_state(::eve_launcher::installer::ShutDown_State value);

  // bool finish_button = 4;
  void clear_finish_button();
  static const int kFinishButtonFieldNumber = 4;
  bool finish_button() const;
  void set_finish_button(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.ShutDown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int page_;
  int state_;
  bool finish_button_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparationStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.PreparationStarted) */ {
 public:
  PreparationStarted();
  virtual ~PreparationStarted();

  PreparationStarted(const PreparationStarted& from);

  inline PreparationStarted& operator=(const PreparationStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreparationStarted(PreparationStarted&& from) noexcept
    : PreparationStarted() {
    *this = ::std::move(from);
  }

  inline PreparationStarted& operator=(PreparationStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparationStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreparationStarted* internal_default_instance() {
    return reinterpret_cast<const PreparationStarted*>(
               &_PreparationStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PreparationStarted* other);
  friend void swap(PreparationStarted& a, PreparationStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreparationStarted* New() const final {
    return CreateMaybeMessage<PreparationStarted>(NULL);
  }

  PreparationStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PreparationStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PreparationStarted& from);
  void MergeFrom(const PreparationStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparationStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.PreparationStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparationFinished : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.PreparationFinished) */ {
 public:
  PreparationFinished();
  virtual ~PreparationFinished();

  PreparationFinished(const PreparationFinished& from);

  inline PreparationFinished& operator=(const PreparationFinished& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreparationFinished(PreparationFinished&& from) noexcept
    : PreparationFinished() {
    *this = ::std::move(from);
  }

  inline PreparationFinished& operator=(PreparationFinished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparationFinished& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreparationFinished* internal_default_instance() {
    return reinterpret_cast<const PreparationFinished*>(
               &_PreparationFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PreparationFinished* other);
  friend void swap(PreparationFinished& a, PreparationFinished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreparationFinished* New() const final {
    return CreateMaybeMessage<PreparationFinished>(NULL);
  }

  PreparationFinished* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PreparationFinished>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PreparationFinished& from);
  void MergeFrom(const PreparationFinished& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparationFinished* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // int32 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.PreparationFinished)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  ::google::protobuf::int32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.LocationChanged) */ {
 public:
  LocationChanged();
  virtual ~LocationChanged();

  LocationChanged(const LocationChanged& from);

  inline LocationChanged& operator=(const LocationChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationChanged(LocationChanged&& from) noexcept
    : LocationChanged() {
    *this = ::std::move(from);
  }

  inline LocationChanged& operator=(LocationChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationChanged& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationChanged* internal_default_instance() {
    return reinterpret_cast<const LocationChanged*>(
               &_LocationChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LocationChanged* other);
  friend void swap(LocationChanged& a, LocationChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationChanged* New() const final {
    return CreateMaybeMessage<LocationChanged>(NULL);
  }

  LocationChanged* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationChanged>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationChanged& from);
  void MergeFrom(const LocationChanged& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocationChanged_Source Source;
  static const Source SOURCE_UNKNOWN =
    LocationChanged_Source_SOURCE_UNKNOWN;
  static const Source SOURCE_INSTALL_DIRECTORY =
    LocationChanged_Source_SOURCE_INSTALL_DIRECTORY;
  static const Source SOURCE_START_MENU_LOCATION =
    LocationChanged_Source_SOURCE_START_MENU_LOCATION;
  static const Source SOURCE_SHARED_CACHE_FOLDER =
    LocationChanged_Source_SOURCE_SHARED_CACHE_FOLDER;
  static inline bool Source_IsValid(int value) {
    return LocationChanged_Source_IsValid(value);
  }
  static const Source Source_MIN =
    LocationChanged_Source_Source_MIN;
  static const Source Source_MAX =
    LocationChanged_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    LocationChanged_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return LocationChanged_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return LocationChanged_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return LocationChanged_Source_Parse(name, value);
  }

  typedef LocationChanged_Provider Provider;
  static const Provider PROVIDER_UNKNOWN =
    LocationChanged_Provider_PROVIDER_UNKNOWN;
  static const Provider PROVIDER_USER =
    LocationChanged_Provider_PROVIDER_USER;
  static const Provider PROVIDER_SYSTEM =
    LocationChanged_Provider_PROVIDER_SYSTEM;
  static inline bool Provider_IsValid(int value) {
    return LocationChanged_Provider_IsValid(value);
  }
  static const Provider Provider_MIN =
    LocationChanged_Provider_Provider_MIN;
  static const Provider Provider_MAX =
    LocationChanged_Provider_Provider_MAX;
  static const int Provider_ARRAYSIZE =
    LocationChanged_Provider_Provider_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Provider_descriptor() {
    return LocationChanged_Provider_descriptor();
  }
  static inline const ::std::string& Provider_Name(Provider value) {
    return LocationChanged_Provider_Name(value);
  }
  static inline bool Provider_Parse(const ::std::string& name,
      Provider* value) {
    return LocationChanged_Provider_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string path = 4;
  void clear_path();
  static const int kPathFieldNumber = 4;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.LocationChanged.Source source = 2;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::eve_launcher::installer::LocationChanged_Source source() const;
  void set_source(::eve_launcher::installer::LocationChanged_Source value);

  // .eve_launcher.installer.LocationChanged.Provider provider = 3;
  void clear_provider();
  static const int kProviderFieldNumber = 3;
  ::eve_launcher::installer::LocationChanged_Provider provider() const;
  void set_provider(::eve_launcher::installer::LocationChanged_Provider value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.LocationChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int source_;
  int provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetailsVisibilityChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.DetailsVisibilityChanged) */ {
 public:
  DetailsVisibilityChanged();
  virtual ~DetailsVisibilityChanged();

  DetailsVisibilityChanged(const DetailsVisibilityChanged& from);

  inline DetailsVisibilityChanged& operator=(const DetailsVisibilityChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetailsVisibilityChanged(DetailsVisibilityChanged&& from) noexcept
    : DetailsVisibilityChanged() {
    *this = ::std::move(from);
  }

  inline DetailsVisibilityChanged& operator=(DetailsVisibilityChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetailsVisibilityChanged& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetailsVisibilityChanged* internal_default_instance() {
    return reinterpret_cast<const DetailsVisibilityChanged*>(
               &_DetailsVisibilityChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DetailsVisibilityChanged* other);
  friend void swap(DetailsVisibilityChanged& a, DetailsVisibilityChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetailsVisibilityChanged* New() const final {
    return CreateMaybeMessage<DetailsVisibilityChanged>(NULL);
  }

  DetailsVisibilityChanged* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DetailsVisibilityChanged>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DetailsVisibilityChanged& from);
  void MergeFrom(const DetailsVisibilityChanged& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailsVisibilityChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // bool visible = 2;
  void clear_visible();
  static const int kVisibleFieldNumber = 2;
  bool visible() const;
  void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.DetailsVisibilityChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  bool visible_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoRunChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.AutoRunChanged) */ {
 public:
  AutoRunChanged();
  virtual ~AutoRunChanged();

  AutoRunChanged(const AutoRunChanged& from);

  inline AutoRunChanged& operator=(const AutoRunChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutoRunChanged(AutoRunChanged&& from) noexcept
    : AutoRunChanged() {
    *this = ::std::move(from);
  }

  inline AutoRunChanged& operator=(AutoRunChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoRunChanged& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoRunChanged* internal_default_instance() {
    return reinterpret_cast<const AutoRunChanged*>(
               &_AutoRunChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AutoRunChanged* other);
  friend void swap(AutoRunChanged& a, AutoRunChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoRunChanged* New() const final {
    return CreateMaybeMessage<AutoRunChanged>(NULL);
  }

  AutoRunChanged* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutoRunChanged>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutoRunChanged& from);
  void MergeFrom(const AutoRunChanged& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoRunChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // bool run = 2;
  void clear_run();
  static const int kRunFieldNumber = 2;
  bool run() const;
  void set_run(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.AutoRunChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  bool run_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EulaAcceptanceChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.EulaAcceptanceChanged) */ {
 public:
  EulaAcceptanceChanged();
  virtual ~EulaAcceptanceChanged();

  EulaAcceptanceChanged(const EulaAcceptanceChanged& from);

  inline EulaAcceptanceChanged& operator=(const EulaAcceptanceChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EulaAcceptanceChanged(EulaAcceptanceChanged&& from) noexcept
    : EulaAcceptanceChanged() {
    *this = ::std::move(from);
  }

  inline EulaAcceptanceChanged& operator=(EulaAcceptanceChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EulaAcceptanceChanged& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EulaAcceptanceChanged* internal_default_instance() {
    return reinterpret_cast<const EulaAcceptanceChanged*>(
               &_EulaAcceptanceChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(EulaAcceptanceChanged* other);
  friend void swap(EulaAcceptanceChanged& a, EulaAcceptanceChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EulaAcceptanceChanged* New() const final {
    return CreateMaybeMessage<EulaAcceptanceChanged>(NULL);
  }

  EulaAcceptanceChanged* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EulaAcceptanceChanged>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EulaAcceptanceChanged& from);
  void MergeFrom(const EulaAcceptanceChanged& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EulaAcceptanceChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // bool accept = 2;
  void clear_accept();
  static const int kAcceptFieldNumber = 2;
  bool accept() const;
  void set_accept(bool value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.EulaAcceptanceChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  bool accept_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedistSearchConcluded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.RedistSearchConcluded) */ {
 public:
  RedistSearchConcluded();
  virtual ~RedistSearchConcluded();

  RedistSearchConcluded(const RedistSearchConcluded& from);

  inline RedistSearchConcluded& operator=(const RedistSearchConcluded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedistSearchConcluded(RedistSearchConcluded&& from) noexcept
    : RedistSearchConcluded() {
    *this = ::std::move(from);
  }

  inline RedistSearchConcluded& operator=(RedistSearchConcluded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedistSearchConcluded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RedistSearchConcluded* internal_default_instance() {
    return reinterpret_cast<const RedistSearchConcluded*>(
               &_RedistSearchConcluded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RedistSearchConcluded* other);
  friend void swap(RedistSearchConcluded& a, RedistSearchConcluded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedistSearchConcluded* New() const final {
    return CreateMaybeMessage<RedistSearchConcluded>(NULL);
  }

  RedistSearchConcluded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RedistSearchConcluded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RedistSearchConcluded& from);
  void MergeFrom(const RedistSearchConcluded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedistSearchConcluded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RedistSearchConcluded_RedistReason RedistReason;
  static const RedistReason REDIST_REASON_UNKNOWN =
    RedistSearchConcluded_RedistReason_REDIST_REASON_UNKNOWN;
  static const RedistReason REDIST_REASON_NOT_WINDOWS =
    RedistSearchConcluded_RedistReason_REDIST_REASON_NOT_WINDOWS;
  static const RedistReason REDIST_REASON_INCLUDED_IN_WINDOWS_VERSION =
    RedistSearchConcluded_RedistReason_REDIST_REASON_INCLUDED_IN_WINDOWS_VERSION;
  static const RedistReason REDIST_REASON_FOUND_DLLS =
    RedistSearchConcluded_RedistReason_REDIST_REASON_FOUND_DLLS;
  static const RedistReason REDIST_REASON_FOUND_WINDOWS_UPDATE =
    RedistSearchConcluded_RedistReason_REDIST_REASON_FOUND_WINDOWS_UPDATE;
  static const RedistReason REDIST_REASON_WINDOWS_UPDATE_MISSING =
    RedistSearchConcluded_RedistReason_REDIST_REASON_WINDOWS_UPDATE_MISSING;
  static const RedistReason REDIST_REASON_REDIST_MISSING =
    RedistSearchConcluded_RedistReason_REDIST_REASON_REDIST_MISSING;
  static inline bool RedistReason_IsValid(int value) {
    return RedistSearchConcluded_RedistReason_IsValid(value);
  }
  static const RedistReason RedistReason_MIN =
    RedistSearchConcluded_RedistReason_RedistReason_MIN;
  static const RedistReason RedistReason_MAX =
    RedistSearchConcluded_RedistReason_RedistReason_MAX;
  static const int RedistReason_ARRAYSIZE =
    RedistSearchConcluded_RedistReason_RedistReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RedistReason_descriptor() {
    return RedistSearchConcluded_RedistReason_descriptor();
  }
  static inline const ::std::string& RedistReason_Name(RedistReason value) {
    return RedistSearchConcluded_RedistReason_Name(value);
  }
  static inline bool RedistReason_Parse(const ::std::string& name,
      RedistReason* value) {
    return RedistSearchConcluded_RedistReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.RedistVersion version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::eve_launcher::installer::RedistVersion version() const;
  void set_version(::eve_launcher::installer::RedistVersion value);

  // .eve_launcher.installer.RedistSearchConcluded.RedistReason reason = 3;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::eve_launcher::installer::RedistSearchConcluded_RedistReason reason() const;
  void set_reason(::eve_launcher::installer::RedistSearchConcluded_RedistReason value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.RedistSearchConcluded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int version_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProvidedClientFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.ProvidedClientFound) */ {
 public:
  ProvidedClientFound();
  virtual ~ProvidedClientFound();

  ProvidedClientFound(const ProvidedClientFound& from);

  inline ProvidedClientFound& operator=(const ProvidedClientFound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProvidedClientFound(ProvidedClientFound&& from) noexcept
    : ProvidedClientFound() {
    *this = ::std::move(from);
  }

  inline ProvidedClientFound& operator=(ProvidedClientFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProvidedClientFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProvidedClientFound* internal_default_instance() {
    return reinterpret_cast<const ProvidedClientFound*>(
               &_ProvidedClientFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProvidedClientFound* other);
  friend void swap(ProvidedClientFound& a, ProvidedClientFound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProvidedClientFound* New() const final {
    return CreateMaybeMessage<ProvidedClientFound>(NULL);
  }

  ProvidedClientFound* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProvidedClientFound>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProvidedClientFound& from);
  void MergeFrom(const ProvidedClientFound& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProvidedClientFound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.ProvidedClientFound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageBoxShown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.MessageBoxShown) */ {
 public:
  MessageBoxShown();
  virtual ~MessageBoxShown();

  MessageBoxShown(const MessageBoxShown& from);

  inline MessageBoxShown& operator=(const MessageBoxShown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageBoxShown(MessageBoxShown&& from) noexcept
    : MessageBoxShown() {
    *this = ::std::move(from);
  }

  inline MessageBoxShown& operator=(MessageBoxShown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageBoxShown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageBoxShown* internal_default_instance() {
    return reinterpret_cast<const MessageBoxShown*>(
               &_MessageBoxShown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MessageBoxShown* other);
  friend void swap(MessageBoxShown& a, MessageBoxShown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageBoxShown* New() const final {
    return CreateMaybeMessage<MessageBoxShown>(NULL);
  }

  MessageBoxShown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageBoxShown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageBoxShown& from);
  void MergeFrom(const MessageBoxShown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageBoxShown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.MessageBox message_box = 2;
  void clear_message_box();
  static const int kMessageBoxFieldNumber = 2;
  ::eve_launcher::installer::MessageBox message_box() const;
  void set_message_box(::eve_launcher::installer::MessageBox value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.MessageBoxShown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int message_box_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageBoxClosed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.MessageBoxClosed) */ {
 public:
  MessageBoxClosed();
  virtual ~MessageBoxClosed();

  MessageBoxClosed(const MessageBoxClosed& from);

  inline MessageBoxClosed& operator=(const MessageBoxClosed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageBoxClosed(MessageBoxClosed&& from) noexcept
    : MessageBoxClosed() {
    *this = ::std::move(from);
  }

  inline MessageBoxClosed& operator=(MessageBoxClosed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageBoxClosed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageBoxClosed* internal_default_instance() {
    return reinterpret_cast<const MessageBoxClosed*>(
               &_MessageBoxClosed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MessageBoxClosed* other);
  friend void swap(MessageBoxClosed& a, MessageBoxClosed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageBoxClosed* New() const final {
    return CreateMaybeMessage<MessageBoxClosed>(NULL);
  }

  MessageBoxClosed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageBoxClosed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageBoxClosed& from);
  void MergeFrom(const MessageBoxClosed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageBoxClosed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MessageBoxClosed_MessageBoxButton MessageBoxButton;
  static const MessageBoxButton MESSAGE_BOX_BUTTON_UNKNOWN =
    MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_UNKNOWN;
  static const MessageBoxButton MESSAGE_BOX_BUTTON_YES =
    MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_YES;
  static const MessageBoxButton MESSAGE_BOX_BUTTON_NO =
    MessageBoxClosed_MessageBoxButton_MESSAGE_BOX_BUTTON_NO;
  static inline bool MessageBoxButton_IsValid(int value) {
    return MessageBoxClosed_MessageBoxButton_IsValid(value);
  }
  static const MessageBoxButton MessageBoxButton_MIN =
    MessageBoxClosed_MessageBoxButton_MessageBoxButton_MIN;
  static const MessageBoxButton MessageBoxButton_MAX =
    MessageBoxClosed_MessageBoxButton_MessageBoxButton_MAX;
  static const int MessageBoxButton_ARRAYSIZE =
    MessageBoxClosed_MessageBoxButton_MessageBoxButton_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageBoxButton_descriptor() {
    return MessageBoxClosed_MessageBoxButton_descriptor();
  }
  static inline const ::std::string& MessageBoxButton_Name(MessageBoxButton value) {
    return MessageBoxClosed_MessageBoxButton_Name(value);
  }
  static inline bool MessageBoxButton_Parse(const ::std::string& name,
      MessageBoxButton* value) {
    return MessageBoxClosed_MessageBoxButton_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.MessageBox message_box = 2;
  void clear_message_box();
  static const int kMessageBoxFieldNumber = 2;
  ::eve_launcher::installer::MessageBox message_box() const;
  void set_message_box(::eve_launcher::installer::MessageBox value);

  // .eve_launcher.installer.MessageBoxClosed.MessageBoxButton message_box_button = 3;
  void clear_message_box_button();
  static const int kMessageBoxButtonFieldNumber = 3;
  ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton message_box_button() const;
  void set_message_box_button(::eve_launcher::installer::MessageBoxClosed_MessageBoxButton value);

  // int32 time_displayed = 4;
  void clear_time_displayed();
  static const int kTimeDisplayedFieldNumber = 4;
  ::google::protobuf::int32 time_displayed() const;
  void set_time_displayed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.MessageBoxClosed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int message_box_;
  int message_box_button_;
  ::google::protobuf::int32 time_displayed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepExecuted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.StepExecuted) */ {
 public:
  StepExecuted();
  virtual ~StepExecuted();

  StepExecuted(const StepExecuted& from);

  inline StepExecuted& operator=(const StepExecuted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepExecuted(StepExecuted&& from) noexcept
    : StepExecuted() {
    *this = ::std::move(from);
  }

  inline StepExecuted& operator=(StepExecuted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepExecuted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepExecuted* internal_default_instance() {
    return reinterpret_cast<const StepExecuted*>(
               &_StepExecuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(StepExecuted* other);
  friend void swap(StepExecuted& a, StepExecuted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepExecuted* New() const final {
    return CreateMaybeMessage<StepExecuted>(NULL);
  }

  StepExecuted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StepExecuted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StepExecuted& from);
  void MergeFrom(const StepExecuted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepExecuted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StepExecuted_Step Step;
  static const Step STEP_UNKNOWN =
    StepExecuted_Step_STEP_UNKNOWN;
  static const Step STEP_STARTED =
    StepExecuted_Step_STEP_STARTED;
  static const Step STEP_FINISHED =
    StepExecuted_Step_STEP_FINISHED;
  static const Step STEP_INTERRUPTED =
    StepExecuted_Step_STEP_INTERRUPTED;
  static const Step STEP_COMPONENTS_INIT_STARTED =
    StepExecuted_Step_STEP_COMPONENTS_INIT_STARTED;
  static const Step STEP_INDIVIDUAL_COMPONENT_INIT_STARTED =
    StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_INIT_STARTED;
  static const Step STEP_INDIVIDUAL_COMPONENT_INTI_FINISHED =
    StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_INTI_FINISHED;
  static const Step STEP_COMPONENTS_INIT_FINISHED =
    StepExecuted_Step_STEP_COMPONENTS_INIT_FINISHED;
  static const Step STEP_COMPONENTS_EXECUTION_STARTED =
    StepExecuted_Step_STEP_COMPONENTS_EXECUTION_STARTED;
  static const Step STEP_INDIVIDUAL_COMPONENT_EXECUTION_STARTED =
    StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_EXECUTION_STARTED;
  static const Step STEP_INDIVIDUAL_COMPONENT_EXECUTION_FINISHED =
    StepExecuted_Step_STEP_INDIVIDUAL_COMPONENT_EXECUTION_FINISHED;
  static const Step STEP_COMPONENTS_EXECUTION_FINISHED =
    StepExecuted_Step_STEP_COMPONENTS_EXECUTION_FINISHED;
  static const Step STEP_MAINTENANCE_TOOL_CREATION_STARTED =
    StepExecuted_Step_STEP_MAINTENANCE_TOOL_CREATION_STARTED;
  static const Step STEP_MAINTENANCE_TOOL_CREATION_FINISHED =
    StepExecuted_Step_STEP_MAINTENANCE_TOOL_CREATION_FINISHED;
  static inline bool Step_IsValid(int value) {
    return StepExecuted_Step_IsValid(value);
  }
  static const Step Step_MIN =
    StepExecuted_Step_Step_MIN;
  static const Step Step_MAX =
    StepExecuted_Step_Step_MAX;
  static const int Step_ARRAYSIZE =
    StepExecuted_Step_Step_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Step_descriptor() {
    return StepExecuted_Step_descriptor();
  }
  static inline const ::std::string& Step_Name(Step value) {
    return StepExecuted_Step_Name(value);
  }
  static inline bool Step_Parse(const ::std::string& name,
      Step* value) {
    return StepExecuted_Step_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.StepExecuted.Step step = 2;
  void clear_step();
  static const int kStepFieldNumber = 2;
  ::eve_launcher::installer::StepExecuted_Step step() const;
  void set_step(::eve_launcher::installer::StepExecuted_Step value);

  // .eve_launcher.installer.Component component = 3;
  void clear_component();
  static const int kComponentFieldNumber = 3;
  ::eve_launcher::installer::Component component() const;
  void set_component(::eve_launcher::installer::Component value);

  // .eve_launcher.installer.RedistVersion redist_version = 4;
  void clear_redist_version();
  static const int kRedistVersionFieldNumber = 4;
  ::eve_launcher::installer::RedistVersion redist_version() const;
  void set_redist_version(::eve_launcher::installer::RedistVersion value);

  // int32 duration = 5;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.StepExecuted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int step_;
  int component_;
  int redist_version_;
  ::google::protobuf::int32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorEncountered : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.ErrorEncountered) */ {
 public:
  ErrorEncountered();
  virtual ~ErrorEncountered();

  ErrorEncountered(const ErrorEncountered& from);

  inline ErrorEncountered& operator=(const ErrorEncountered& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorEncountered(ErrorEncountered&& from) noexcept
    : ErrorEncountered() {
    *this = ::std::move(from);
  }

  inline ErrorEncountered& operator=(ErrorEncountered&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorEncountered& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorEncountered* internal_default_instance() {
    return reinterpret_cast<const ErrorEncountered*>(
               &_ErrorEncountered_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ErrorEncountered* other);
  friend void swap(ErrorEncountered& a, ErrorEncountered& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorEncountered* New() const final {
    return CreateMaybeMessage<ErrorEncountered>(NULL);
  }

  ErrorEncountered* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorEncountered>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorEncountered& from);
  void MergeFrom(const ErrorEncountered& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorEncountered* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ErrorEncountered_ErrorCode ErrorCode;
  static const ErrorCode ERROR_CODE_UNKNOWN =
    ErrorEncountered_ErrorCode_ERROR_CODE_UNKNOWN;
  static const ErrorCode ERROR_CODE_CREATE_OPERATIONS =
    ErrorEncountered_ErrorCode_ERROR_CODE_CREATE_OPERATIONS;
  static const ErrorCode ERROR_CODE_ADD_OPERATION =
    ErrorEncountered_ErrorCode_ERROR_CODE_ADD_OPERATION;
  static const ErrorCode ERROR_CODE_SEARCH_DLL =
    ErrorEncountered_ErrorCode_ERROR_CODE_SEARCH_DLL;
  static const ErrorCode ERROR_CODE_SEARCH_WINDOWS_UPDATE =
    ErrorEncountered_ErrorCode_ERROR_CODE_SEARCH_WINDOWS_UPDATE;
  static const ErrorCode ERROR_CODE_MISSING_PREREQUISITE =
    ErrorEncountered_ErrorCode_ERROR_CODE_MISSING_PREREQUISITE;
  static const ErrorCode ERROR_CODE_QT_STATUS_FAILURE =
    ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_FAILURE;
  static const ErrorCode ERROR_CODE_QT_STATUS_UNFINISHED =
    ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_UNFINISHED;
  static const ErrorCode ERROR_CODE_QT_STATUS_FORCE_UPDATE =
    ErrorEncountered_ErrorCode_ERROR_CODE_QT_STATUS_FORCE_UPDATE;
  static inline bool ErrorCode_IsValid(int value) {
    return ErrorEncountered_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    ErrorEncountered_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    ErrorEncountered_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    ErrorEncountered_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return ErrorEncountered_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return ErrorEncountered_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return ErrorEncountered_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_launcher.installer.EventMetadata event_metadata = 1;
  bool has_event_metadata() const;
  void clear_event_metadata();
  static const int kEventMetadataFieldNumber = 1;
  private:
  const ::eve_launcher::installer::EventMetadata& _internal_event_metadata() const;
  public:
  const ::eve_launcher::installer::EventMetadata& event_metadata() const;
  ::eve_launcher::installer::EventMetadata* release_event_metadata();
  ::eve_launcher::installer::EventMetadata* mutable_event_metadata();
  void set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata);

  // .eve_launcher.installer.ErrorEncountered.ErrorCode code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::eve_launcher::installer::ErrorEncountered_ErrorCode code() const;
  void set_code(::eve_launcher::installer::ErrorEncountered_ErrorCode value);

  // .eve_launcher.installer.Page page = 3;
  void clear_page();
  static const int kPageFieldNumber = 3;
  ::eve_launcher::installer::Page page() const;
  void set_page(::eve_launcher::installer::Page value);

  // .eve_launcher.installer.Component component = 4;
  void clear_component();
  static const int kComponentFieldNumber = 4;
  ::eve_launcher::installer::Component component() const;
  void set_component(::eve_launcher::installer::Component value);

  // .eve_launcher.installer.RedistVersion redist_version = 5;
  void clear_redist_version();
  static const int kRedistVersionFieldNumber = 5;
  ::eve_launcher::installer::RedistVersion redist_version() const;
  void set_redist_version(::eve_launcher::installer::RedistVersion value);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.ErrorEncountered)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_launcher::installer::EventMetadata* event_metadata_;
  int code_;
  int page_;
  int component_;
  int redist_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IPAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.IPAddress) */ {
 public:
  IPAddress();
  virtual ~IPAddress();

  IPAddress(const IPAddress& from);

  inline IPAddress& operator=(const IPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IPAddress(IPAddress&& from) noexcept
    : IPAddress() {
    *this = ::std::move(from);
  }

  inline IPAddress& operator=(IPAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAddress& default_instance();

  enum VersionCase {
    kV4 = 1,
    kV6 = 2,
    VERSION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IPAddress* internal_default_instance() {
    return reinterpret_cast<const IPAddress*>(
               &_IPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(IPAddress* other);
  friend void swap(IPAddress& a, IPAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IPAddress* New() const final {
    return CreateMaybeMessage<IPAddress>(NULL);
  }

  IPAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IPAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IPAddress& from);
  void MergeFrom(const IPAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed32 v4 = 1;
  private:
  bool has_v4() const;
  public:
  void clear_v4();
  static const int kV4FieldNumber = 1;
  ::google::protobuf::uint32 v4() const;
  void set_v4(::google::protobuf::uint32 value);

  // bytes v6 = 2;
  private:
  bool has_v6() const;
  public:
  void clear_v6();
  static const int kV6FieldNumber = 2;
  const ::std::string& v6() const;
  void set_v6(const ::std::string& value);
  #if LANG_CXX11
  void set_v6(::std::string&& value);
  #endif
  void set_v6(const char* value);
  void set_v6(const void* value, size_t size);
  ::std::string* mutable_v6();
  ::std::string* release_v6();
  void set_allocated_v6(::std::string* v6);

  void clear_version();
  VersionCase version_case() const;
  // @@protoc_insertion_point(class_scope:eve_launcher.installer.IPAddress)
 private:
  void set_has_v4();
  void set_has_v6();

  inline bool has_version() const;
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union VersionUnion {
    VersionUnion() {}
    ::google::protobuf::uint32 v4_;
    ::google::protobuf::internal::ArenaStringPtr v6_;
  } version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_launcher.installer.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 2;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string tenant = 4;
  void clear_tenant();
  static const int kTenantFieldNumber = 4;
  const ::std::string& tenant() const;
  void set_tenant(const ::std::string& value);
  #if LANG_CXX11
  void set_tenant(::std::string&& value);
  #endif
  void set_tenant(const char* value);
  void set_tenant(const char* value, size_t size);
  ::std::string* mutable_tenant();
  ::std::string* release_tenant();
  void set_allocated_tenant(::std::string* tenant);

  // bytes journey = 6;
  void clear_journey();
  static const int kJourneyFieldNumber = 6;
  const ::std::string& journey() const;
  void set_journey(const ::std::string& value);
  #if LANG_CXX11
  void set_journey(::std::string&& value);
  #endif
  void set_journey(const char* value);
  void set_journey(const void* value, size_t size);
  ::std::string* mutable_journey();
  ::std::string* release_journey();
  void set_allocated_journey(::std::string* journey);

  // .google.protobuf.Timestamp created = 1;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 1;
  private:
  const ::google::protobuf::Timestamp& _internal_created() const;
  public:
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // .eve_launcher.installer.IPAddress ip_address = 3;
  bool has_ip_address() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 3;
  private:
  const ::eve_launcher::installer::IPAddress& _internal_ip_address() const;
  public:
  const ::eve_launcher::installer::IPAddress& ip_address() const;
  ::eve_launcher::installer::IPAddress* release_ip_address();
  ::eve_launcher::installer::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::eve_launcher::installer::IPAddress* ip_address);

  // .google.protobuf.Any payload = 5;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  private:
  const ::google::protobuf::Any& _internal_payload() const;
  public:
  const ::google::protobuf::Any& payload() const;
  ::google::protobuf::Any* release_payload();
  ::google::protobuf::Any* mutable_payload();
  void set_allocated_payload(::google::protobuf::Any* payload);

  // .google.protobuf.Timestamp reveived = 7;
  bool has_reveived() const;
  void clear_reveived();
  static const int kReveivedFieldNumber = 7;
  private:
  const ::google::protobuf::Timestamp& _internal_reveived() const;
  public:
  const ::google::protobuf::Timestamp& reveived() const;
  ::google::protobuf::Timestamp* release_reveived();
  ::google::protobuf::Timestamp* mutable_reveived();
  void set_allocated_reveived(::google::protobuf::Timestamp* reveived);

  // @@protoc_insertion_point(class_scope:eve_launcher.installer.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr tenant_;
  ::google::protobuf::internal::ArenaStringPtr journey_;
  ::google::protobuf::Timestamp* created_;
  ::eve_launcher::installer::IPAddress* ip_address_;
  ::google::protobuf::Any* payload_;
  ::google::protobuf::Timestamp* reveived_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5flauncher_2finstaller_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventMetadata

// bytes md5_session = 1;
inline void EventMetadata::clear_md5_session() {
  md5_session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventMetadata::md5_session() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.EventMetadata.md5_session)
  return md5_session_.GetNoArena();
}
inline void EventMetadata::set_md5_session(const ::std::string& value) {
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.EventMetadata.md5_session)
}
#if LANG_CXX11
inline void EventMetadata::set_md5_session(::std::string&& value) {
  
  md5_session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.EventMetadata.md5_session)
}
#endif
inline void EventMetadata::set_md5_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.EventMetadata.md5_session)
}
inline void EventMetadata::set_md5_session(const void* value, size_t size) {
  
  md5_session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.EventMetadata.md5_session)
}
inline ::std::string* EventMetadata::mutable_md5_session() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.EventMetadata.md5_session)
  return md5_session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventMetadata::release_md5_session() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.EventMetadata.md5_session)
  
  return md5_session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventMetadata::set_allocated_md5_session(::std::string* md5_session) {
  if (md5_session != NULL) {
    
  } else {
    
  }
  md5_session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5_session);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.EventMetadata.md5_session)
}

// .eve_launcher.installer.Application application = 2;
inline bool EventMetadata::has_application() const {
  return this != internal_default_instance() && application_ != NULL;
}
inline void EventMetadata::clear_application() {
  if (GetArenaNoVirtual() == NULL && application_ != NULL) {
    delete application_;
  }
  application_ = NULL;
}
inline const ::eve_launcher::installer::Application& EventMetadata::_internal_application() const {
  return *application_;
}
inline const ::eve_launcher::installer::Application& EventMetadata::application() const {
  const ::eve_launcher::installer::Application* p = application_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.EventMetadata.application)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::Application*>(
      &::eve_launcher::installer::_Application_default_instance_);
}
inline ::eve_launcher::installer::Application* EventMetadata::release_application() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.EventMetadata.application)
  
  ::eve_launcher::installer::Application* temp = application_;
  application_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::Application* EventMetadata::mutable_application() {
  
  if (application_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::Application>(GetArenaNoVirtual());
    application_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.EventMetadata.application)
  return application_;
}
inline void EventMetadata::set_allocated_application(::eve_launcher::installer::Application* application) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete application_;
  }
  if (application) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      application = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    
  } else {
    
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.EventMetadata.application)
}

// bytes operating_system_uuid = 3;
inline void EventMetadata::clear_operating_system_uuid() {
  operating_system_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventMetadata::operating_system_uuid() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.EventMetadata.operating_system_uuid)
  return operating_system_uuid_.GetNoArena();
}
inline void EventMetadata::set_operating_system_uuid(const ::std::string& value) {
  
  operating_system_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.EventMetadata.operating_system_uuid)
}
#if LANG_CXX11
inline void EventMetadata::set_operating_system_uuid(::std::string&& value) {
  
  operating_system_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.EventMetadata.operating_system_uuid)
}
#endif
inline void EventMetadata::set_operating_system_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operating_system_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.EventMetadata.operating_system_uuid)
}
inline void EventMetadata::set_operating_system_uuid(const void* value, size_t size) {
  
  operating_system_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.EventMetadata.operating_system_uuid)
}
inline ::std::string* EventMetadata::mutable_operating_system_uuid() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.EventMetadata.operating_system_uuid)
  return operating_system_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventMetadata::release_operating_system_uuid() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.EventMetadata.operating_system_uuid)
  
  return operating_system_uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventMetadata::set_allocated_operating_system_uuid(::std::string* operating_system_uuid) {
  if (operating_system_uuid != NULL) {
    
  } else {
    
  }
  operating_system_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operating_system_uuid);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.EventMetadata.operating_system_uuid)
}

// -------------------------------------------------------------------

// Application

// string version = 1;
inline void Application::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Application::version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.version)
  return version_.GetNoArena();
}
inline void Application::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.version)
}
#if LANG_CXX11
inline void Application::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.Application.version)
}
#endif
inline void Application::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.Application.version)
}
inline void Application::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.Application.version)
}
inline ::std::string* Application::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Application.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Application::release_version() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Application.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Application::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Application.version)
}

// .eve_launcher.installer.Application.BuildType build_type = 2;
inline void Application::clear_build_type() {
  build_type_ = 0;
}
inline ::eve_launcher::installer::Application_BuildType Application::build_type() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.build_type)
  return static_cast< ::eve_launcher::installer::Application_BuildType >(build_type_);
}
inline void Application::set_build_type(::eve_launcher::installer::Application_BuildType value) {
  
  build_type_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.build_type)
}

// .eve_launcher.installer.Application.Locale locale = 3;
inline void Application::clear_locale() {
  locale_ = 0;
}
inline ::eve_launcher::installer::Application_Locale Application::locale() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.locale)
  return static_cast< ::eve_launcher::installer::Application_Locale >(locale_);
}
inline void Application::set_locale(::eve_launcher::installer::Application_Locale value) {
  
  locale_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.locale)
}

// .eve_launcher.installer.Application.ApplicationType application_type = 4;
inline void Application::clear_application_type() {
  application_type_ = 0;
}
inline ::eve_launcher::installer::Application_ApplicationType Application::application_type() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.application_type)
  return static_cast< ::eve_launcher::installer::Application_ApplicationType >(application_type_);
}
inline void Application::set_application_type(::eve_launcher::installer::Application_ApplicationType value) {
  
  application_type_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.application_type)
}

// bool no_installer_provider = 5;
inline bool Application::has_no_installer_provider() const {
  return provider_case() == kNoInstallerProvider;
}
inline void Application::set_has_no_installer_provider() {
  _oneof_case_[0] = kNoInstallerProvider;
}
inline void Application::clear_no_installer_provider() {
  if (has_no_installer_provider()) {
    provider_.no_installer_provider_ = false;
    clear_has_provider();
  }
}
inline bool Application::no_installer_provider() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.no_installer_provider)
  if (has_no_installer_provider()) {
    return provider_.no_installer_provider_;
  }
  return false;
}
inline void Application::set_no_installer_provider(bool value) {
  if (!has_no_installer_provider()) {
    clear_provider();
    set_has_no_installer_provider();
  }
  provider_.no_installer_provider_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.no_installer_provider)
}

// string installer_provider = 6;
inline bool Application::has_installer_provider() const {
  return provider_case() == kInstallerProvider;
}
inline void Application::set_has_installer_provider() {
  _oneof_case_[0] = kInstallerProvider;
}
inline void Application::clear_installer_provider() {
  if (has_installer_provider()) {
    provider_.installer_provider_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_provider();
  }
}
inline const ::std::string& Application::installer_provider() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Application.installer_provider)
  if (has_installer_provider()) {
    return provider_.installer_provider_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Application::set_installer_provider(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.installer_provider)
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.installer_provider)
}
#if LANG_CXX11
inline void Application::set_installer_provider(::std::string&& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Application.installer_provider)
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.Application.installer_provider)
}
#endif
inline void Application::set_installer_provider(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.Application.installer_provider)
}
inline void Application::set_installer_provider(const char* value, size_t size) {
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  provider_.installer_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.Application.installer_provider)
}
inline ::std::string* Application::mutable_installer_provider() {
  if (!has_installer_provider()) {
    clear_provider();
    set_has_installer_provider();
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Application.installer_provider)
  return provider_.installer_provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Application::release_installer_provider() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Application.installer_provider)
  if (has_installer_provider()) {
    clear_has_provider();
    return provider_.installer_provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Application::set_allocated_installer_provider(::std::string* installer_provider) {
  if (!has_installer_provider()) {
    provider_.installer_provider_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_provider();
  if (installer_provider != NULL) {
    set_has_installer_provider();
    provider_.installer_provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), installer_provider);
  }
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Application.installer_provider)
}

inline bool Application::has_provider() const {
  return provider_case() != PROVIDER_NOT_SET;
}
inline void Application::clear_has_provider() {
  _oneof_case_[0] = PROVIDER_NOT_SET;
}
inline Application::ProviderCase Application::provider_case() const {
  return Application::ProviderCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Started

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool Started::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void Started::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& Started::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& Started::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Started.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* Started::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Started.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* Started::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Started.event_metadata)
  return event_metadata_;
}
inline void Started::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Started.event_metadata)
}

// int32 duration = 2;
inline void Started::clear_duration() {
  duration_ = 0;
}
inline ::google::protobuf::int32 Started::duration() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Started.duration)
  return duration_;
}
inline void Started::set_duration(::google::protobuf::int32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Started.duration)
}

// -------------------------------------------------------------------

// PageDisplayed

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool PageDisplayed::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void PageDisplayed::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& PageDisplayed::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& PageDisplayed::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PageDisplayed.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* PageDisplayed::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.PageDisplayed.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* PageDisplayed::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.PageDisplayed.event_metadata)
  return event_metadata_;
}
inline void PageDisplayed::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.PageDisplayed.event_metadata)
}

// .eve_launcher.installer.Page previous_page = 2;
inline void PageDisplayed::clear_previous_page() {
  previous_page_ = 0;
}
inline ::eve_launcher::installer::Page PageDisplayed::previous_page() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PageDisplayed.previous_page)
  return static_cast< ::eve_launcher::installer::Page >(previous_page_);
}
inline void PageDisplayed::set_previous_page(::eve_launcher::installer::Page value) {
  
  previous_page_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.PageDisplayed.previous_page)
}

// .eve_launcher.installer.Page current_page = 3;
inline void PageDisplayed::clear_current_page() {
  current_page_ = 0;
}
inline ::eve_launcher::installer::Page PageDisplayed::current_page() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PageDisplayed.current_page)
  return static_cast< ::eve_launcher::installer::Page >(current_page_);
}
inline void PageDisplayed::set_current_page(::eve_launcher::installer::Page value) {
  
  current_page_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.PageDisplayed.current_page)
}

// .eve_launcher.installer.PageDisplayed.FlowDirection flow = 4;
inline void PageDisplayed::clear_flow() {
  flow_ = 0;
}
inline ::eve_launcher::installer::PageDisplayed_FlowDirection PageDisplayed::flow() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PageDisplayed.flow)
  return static_cast< ::eve_launcher::installer::PageDisplayed_FlowDirection >(flow_);
}
inline void PageDisplayed::set_flow(::eve_launcher::installer::PageDisplayed_FlowDirection value) {
  
  flow_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.PageDisplayed.flow)
}

// -------------------------------------------------------------------

// UserCancelled

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool UserCancelled::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void UserCancelled::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& UserCancelled::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& UserCancelled::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.UserCancelled.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* UserCancelled::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.UserCancelled.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* UserCancelled::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.UserCancelled.event_metadata)
  return event_metadata_;
}
inline void UserCancelled::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.UserCancelled.event_metadata)
}

// .eve_launcher.installer.Page page = 2;
inline void UserCancelled::clear_page() {
  page_ = 0;
}
inline ::eve_launcher::installer::Page UserCancelled::page() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.UserCancelled.page)
  return static_cast< ::eve_launcher::installer::Page >(page_);
}
inline void UserCancelled::set_page(::eve_launcher::installer::Page value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.UserCancelled.page)
}

// .eve_launcher.installer.UserCancelled.Progress progress = 3;
inline void UserCancelled::clear_progress() {
  progress_ = 0;
}
inline ::eve_launcher::installer::UserCancelled_Progress UserCancelled::progress() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.UserCancelled.progress)
  return static_cast< ::eve_launcher::installer::UserCancelled_Progress >(progress_);
}
inline void UserCancelled::set_progress(::eve_launcher::installer::UserCancelled_Progress value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.UserCancelled.progress)
}

// -------------------------------------------------------------------

// ShutDown

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool ShutDown::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void ShutDown::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& ShutDown::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& ShutDown::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ShutDown.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* ShutDown::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.ShutDown.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* ShutDown::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.ShutDown.event_metadata)
  return event_metadata_;
}
inline void ShutDown::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.ShutDown.event_metadata)
}

// .eve_launcher.installer.Page page = 2;
inline void ShutDown::clear_page() {
  page_ = 0;
}
inline ::eve_launcher::installer::Page ShutDown::page() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ShutDown.page)
  return static_cast< ::eve_launcher::installer::Page >(page_);
}
inline void ShutDown::set_page(::eve_launcher::installer::Page value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ShutDown.page)
}

// .eve_launcher.installer.ShutDown.State state = 3;
inline void ShutDown::clear_state() {
  state_ = 0;
}
inline ::eve_launcher::installer::ShutDown_State ShutDown::state() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ShutDown.state)
  return static_cast< ::eve_launcher::installer::ShutDown_State >(state_);
}
inline void ShutDown::set_state(::eve_launcher::installer::ShutDown_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ShutDown.state)
}

// bool finish_button = 4;
inline void ShutDown::clear_finish_button() {
  finish_button_ = false;
}
inline bool ShutDown::finish_button() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ShutDown.finish_button)
  return finish_button_;
}
inline void ShutDown::set_finish_button(bool value) {
  
  finish_button_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ShutDown.finish_button)
}

// -------------------------------------------------------------------

// PreparationStarted

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool PreparationStarted::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void PreparationStarted::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& PreparationStarted::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& PreparationStarted::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PreparationStarted.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* PreparationStarted::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.PreparationStarted.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* PreparationStarted::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.PreparationStarted.event_metadata)
  return event_metadata_;
}
inline void PreparationStarted::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.PreparationStarted.event_metadata)
}

// -------------------------------------------------------------------

// PreparationFinished

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool PreparationFinished::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void PreparationFinished::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& PreparationFinished::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& PreparationFinished::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PreparationFinished.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* PreparationFinished::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.PreparationFinished.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* PreparationFinished::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.PreparationFinished.event_metadata)
  return event_metadata_;
}
inline void PreparationFinished::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.PreparationFinished.event_metadata)
}

// int32 duration = 2;
inline void PreparationFinished::clear_duration() {
  duration_ = 0;
}
inline ::google::protobuf::int32 PreparationFinished::duration() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.PreparationFinished.duration)
  return duration_;
}
inline void PreparationFinished::set_duration(::google::protobuf::int32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.PreparationFinished.duration)
}

// -------------------------------------------------------------------

// LocationChanged

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool LocationChanged::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void LocationChanged::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& LocationChanged::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& LocationChanged::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.LocationChanged.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* LocationChanged::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.LocationChanged.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* LocationChanged::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.LocationChanged.event_metadata)
  return event_metadata_;
}
inline void LocationChanged::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.LocationChanged.event_metadata)
}

// .eve_launcher.installer.LocationChanged.Source source = 2;
inline void LocationChanged::clear_source() {
  source_ = 0;
}
inline ::eve_launcher::installer::LocationChanged_Source LocationChanged::source() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.LocationChanged.source)
  return static_cast< ::eve_launcher::installer::LocationChanged_Source >(source_);
}
inline void LocationChanged::set_source(::eve_launcher::installer::LocationChanged_Source value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.LocationChanged.source)
}

// .eve_launcher.installer.LocationChanged.Provider provider = 3;
inline void LocationChanged::clear_provider() {
  provider_ = 0;
}
inline ::eve_launcher::installer::LocationChanged_Provider LocationChanged::provider() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.LocationChanged.provider)
  return static_cast< ::eve_launcher::installer::LocationChanged_Provider >(provider_);
}
inline void LocationChanged::set_provider(::eve_launcher::installer::LocationChanged_Provider value) {
  
  provider_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.LocationChanged.provider)
}

// string path = 4;
inline void LocationChanged::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LocationChanged::path() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.LocationChanged.path)
  return path_.GetNoArena();
}
inline void LocationChanged::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.LocationChanged.path)
}
#if LANG_CXX11
inline void LocationChanged::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.LocationChanged.path)
}
#endif
inline void LocationChanged::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.LocationChanged.path)
}
inline void LocationChanged::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.LocationChanged.path)
}
inline ::std::string* LocationChanged::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.LocationChanged.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocationChanged::release_path() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.LocationChanged.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocationChanged::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.LocationChanged.path)
}

// -------------------------------------------------------------------

// DetailsVisibilityChanged

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool DetailsVisibilityChanged::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void DetailsVisibilityChanged::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& DetailsVisibilityChanged::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& DetailsVisibilityChanged::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.DetailsVisibilityChanged.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* DetailsVisibilityChanged::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.DetailsVisibilityChanged.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* DetailsVisibilityChanged::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.DetailsVisibilityChanged.event_metadata)
  return event_metadata_;
}
inline void DetailsVisibilityChanged::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.DetailsVisibilityChanged.event_metadata)
}

// bool visible = 2;
inline void DetailsVisibilityChanged::clear_visible() {
  visible_ = false;
}
inline bool DetailsVisibilityChanged::visible() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.DetailsVisibilityChanged.visible)
  return visible_;
}
inline void DetailsVisibilityChanged::set_visible(bool value) {
  
  visible_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.DetailsVisibilityChanged.visible)
}

// -------------------------------------------------------------------

// AutoRunChanged

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool AutoRunChanged::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void AutoRunChanged::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& AutoRunChanged::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& AutoRunChanged::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.AutoRunChanged.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* AutoRunChanged::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.AutoRunChanged.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* AutoRunChanged::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.AutoRunChanged.event_metadata)
  return event_metadata_;
}
inline void AutoRunChanged::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.AutoRunChanged.event_metadata)
}

// bool run = 2;
inline void AutoRunChanged::clear_run() {
  run_ = false;
}
inline bool AutoRunChanged::run() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.AutoRunChanged.run)
  return run_;
}
inline void AutoRunChanged::set_run(bool value) {
  
  run_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.AutoRunChanged.run)
}

// -------------------------------------------------------------------

// EulaAcceptanceChanged

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool EulaAcceptanceChanged::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void EulaAcceptanceChanged::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& EulaAcceptanceChanged::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& EulaAcceptanceChanged::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.EulaAcceptanceChanged.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* EulaAcceptanceChanged::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.EulaAcceptanceChanged.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* EulaAcceptanceChanged::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.EulaAcceptanceChanged.event_metadata)
  return event_metadata_;
}
inline void EulaAcceptanceChanged::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.EulaAcceptanceChanged.event_metadata)
}

// bool accept = 2;
inline void EulaAcceptanceChanged::clear_accept() {
  accept_ = false;
}
inline bool EulaAcceptanceChanged::accept() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.EulaAcceptanceChanged.accept)
  return accept_;
}
inline void EulaAcceptanceChanged::set_accept(bool value) {
  
  accept_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.EulaAcceptanceChanged.accept)
}

// -------------------------------------------------------------------

// RedistSearchConcluded

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool RedistSearchConcluded::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void RedistSearchConcluded::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& RedistSearchConcluded::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& RedistSearchConcluded::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.RedistSearchConcluded.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* RedistSearchConcluded::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.RedistSearchConcluded.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* RedistSearchConcluded::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.RedistSearchConcluded.event_metadata)
  return event_metadata_;
}
inline void RedistSearchConcluded::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.RedistSearchConcluded.event_metadata)
}

// .eve_launcher.installer.RedistVersion version = 2;
inline void RedistSearchConcluded::clear_version() {
  version_ = 0;
}
inline ::eve_launcher::installer::RedistVersion RedistSearchConcluded::version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.RedistSearchConcluded.version)
  return static_cast< ::eve_launcher::installer::RedistVersion >(version_);
}
inline void RedistSearchConcluded::set_version(::eve_launcher::installer::RedistVersion value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.RedistSearchConcluded.version)
}

// .eve_launcher.installer.RedistSearchConcluded.RedistReason reason = 3;
inline void RedistSearchConcluded::clear_reason() {
  reason_ = 0;
}
inline ::eve_launcher::installer::RedistSearchConcluded_RedistReason RedistSearchConcluded::reason() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.RedistSearchConcluded.reason)
  return static_cast< ::eve_launcher::installer::RedistSearchConcluded_RedistReason >(reason_);
}
inline void RedistSearchConcluded::set_reason(::eve_launcher::installer::RedistSearchConcluded_RedistReason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.RedistSearchConcluded.reason)
}

// -------------------------------------------------------------------

// ProvidedClientFound

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool ProvidedClientFound::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void ProvidedClientFound::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& ProvidedClientFound::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& ProvidedClientFound::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ProvidedClientFound.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* ProvidedClientFound::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.ProvidedClientFound.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* ProvidedClientFound::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.ProvidedClientFound.event_metadata)
  return event_metadata_;
}
inline void ProvidedClientFound::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.ProvidedClientFound.event_metadata)
}

// -------------------------------------------------------------------

// MessageBoxShown

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool MessageBoxShown::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void MessageBoxShown::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& MessageBoxShown::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& MessageBoxShown::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxShown.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* MessageBoxShown::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.MessageBoxShown.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* MessageBoxShown::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.MessageBoxShown.event_metadata)
  return event_metadata_;
}
inline void MessageBoxShown::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.MessageBoxShown.event_metadata)
}

// .eve_launcher.installer.MessageBox message_box = 2;
inline void MessageBoxShown::clear_message_box() {
  message_box_ = 0;
}
inline ::eve_launcher::installer::MessageBox MessageBoxShown::message_box() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxShown.message_box)
  return static_cast< ::eve_launcher::installer::MessageBox >(message_box_);
}
inline void MessageBoxShown::set_message_box(::eve_launcher::installer::MessageBox value) {
  
  message_box_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.MessageBoxShown.message_box)
}

// -------------------------------------------------------------------

// MessageBoxClosed

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool MessageBoxClosed::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void MessageBoxClosed::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& MessageBoxClosed::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& MessageBoxClosed::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxClosed.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* MessageBoxClosed::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.MessageBoxClosed.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* MessageBoxClosed::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.MessageBoxClosed.event_metadata)
  return event_metadata_;
}
inline void MessageBoxClosed::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.MessageBoxClosed.event_metadata)
}

// .eve_launcher.installer.MessageBox message_box = 2;
inline void MessageBoxClosed::clear_message_box() {
  message_box_ = 0;
}
inline ::eve_launcher::installer::MessageBox MessageBoxClosed::message_box() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxClosed.message_box)
  return static_cast< ::eve_launcher::installer::MessageBox >(message_box_);
}
inline void MessageBoxClosed::set_message_box(::eve_launcher::installer::MessageBox value) {
  
  message_box_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.MessageBoxClosed.message_box)
}

// .eve_launcher.installer.MessageBoxClosed.MessageBoxButton message_box_button = 3;
inline void MessageBoxClosed::clear_message_box_button() {
  message_box_button_ = 0;
}
inline ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton MessageBoxClosed::message_box_button() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxClosed.message_box_button)
  return static_cast< ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton >(message_box_button_);
}
inline void MessageBoxClosed::set_message_box_button(::eve_launcher::installer::MessageBoxClosed_MessageBoxButton value) {
  
  message_box_button_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.MessageBoxClosed.message_box_button)
}

// int32 time_displayed = 4;
inline void MessageBoxClosed::clear_time_displayed() {
  time_displayed_ = 0;
}
inline ::google::protobuf::int32 MessageBoxClosed::time_displayed() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.MessageBoxClosed.time_displayed)
  return time_displayed_;
}
inline void MessageBoxClosed::set_time_displayed(::google::protobuf::int32 value) {
  
  time_displayed_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.MessageBoxClosed.time_displayed)
}

// -------------------------------------------------------------------

// StepExecuted

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool StepExecuted::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void StepExecuted::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& StepExecuted::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& StepExecuted::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.StepExecuted.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* StepExecuted::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.StepExecuted.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* StepExecuted::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.StepExecuted.event_metadata)
  return event_metadata_;
}
inline void StepExecuted::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.StepExecuted.event_metadata)
}

// .eve_launcher.installer.StepExecuted.Step step = 2;
inline void StepExecuted::clear_step() {
  step_ = 0;
}
inline ::eve_launcher::installer::StepExecuted_Step StepExecuted::step() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.StepExecuted.step)
  return static_cast< ::eve_launcher::installer::StepExecuted_Step >(step_);
}
inline void StepExecuted::set_step(::eve_launcher::installer::StepExecuted_Step value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.StepExecuted.step)
}

// .eve_launcher.installer.Component component = 3;
inline void StepExecuted::clear_component() {
  component_ = 0;
}
inline ::eve_launcher::installer::Component StepExecuted::component() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.StepExecuted.component)
  return static_cast< ::eve_launcher::installer::Component >(component_);
}
inline void StepExecuted::set_component(::eve_launcher::installer::Component value) {
  
  component_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.StepExecuted.component)
}

// .eve_launcher.installer.RedistVersion redist_version = 4;
inline void StepExecuted::clear_redist_version() {
  redist_version_ = 0;
}
inline ::eve_launcher::installer::RedistVersion StepExecuted::redist_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.StepExecuted.redist_version)
  return static_cast< ::eve_launcher::installer::RedistVersion >(redist_version_);
}
inline void StepExecuted::set_redist_version(::eve_launcher::installer::RedistVersion value) {
  
  redist_version_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.StepExecuted.redist_version)
}

// int32 duration = 5;
inline void StepExecuted::clear_duration() {
  duration_ = 0;
}
inline ::google::protobuf::int32 StepExecuted::duration() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.StepExecuted.duration)
  return duration_;
}
inline void StepExecuted::set_duration(::google::protobuf::int32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.StepExecuted.duration)
}

// -------------------------------------------------------------------

// ErrorEncountered

// .eve_launcher.installer.EventMetadata event_metadata = 1;
inline bool ErrorEncountered::has_event_metadata() const {
  return this != internal_default_instance() && event_metadata_ != NULL;
}
inline void ErrorEncountered::clear_event_metadata() {
  if (GetArenaNoVirtual() == NULL && event_metadata_ != NULL) {
    delete event_metadata_;
  }
  event_metadata_ = NULL;
}
inline const ::eve_launcher::installer::EventMetadata& ErrorEncountered::_internal_event_metadata() const {
  return *event_metadata_;
}
inline const ::eve_launcher::installer::EventMetadata& ErrorEncountered::event_metadata() const {
  const ::eve_launcher::installer::EventMetadata* p = event_metadata_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ErrorEncountered.event_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::EventMetadata*>(
      &::eve_launcher::installer::_EventMetadata_default_instance_);
}
inline ::eve_launcher::installer::EventMetadata* ErrorEncountered::release_event_metadata() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.ErrorEncountered.event_metadata)
  
  ::eve_launcher::installer::EventMetadata* temp = event_metadata_;
  event_metadata_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::EventMetadata* ErrorEncountered::mutable_event_metadata() {
  
  if (event_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::EventMetadata>(GetArenaNoVirtual());
    event_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.ErrorEncountered.event_metadata)
  return event_metadata_;
}
inline void ErrorEncountered::set_allocated_event_metadata(::eve_launcher::installer::EventMetadata* event_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_metadata_;
  }
  if (event_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_metadata, submessage_arena);
    }
    
  } else {
    
  }
  event_metadata_ = event_metadata;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.ErrorEncountered.event_metadata)
}

// .eve_launcher.installer.ErrorEncountered.ErrorCode code = 2;
inline void ErrorEncountered::clear_code() {
  code_ = 0;
}
inline ::eve_launcher::installer::ErrorEncountered_ErrorCode ErrorEncountered::code() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ErrorEncountered.code)
  return static_cast< ::eve_launcher::installer::ErrorEncountered_ErrorCode >(code_);
}
inline void ErrorEncountered::set_code(::eve_launcher::installer::ErrorEncountered_ErrorCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ErrorEncountered.code)
}

// .eve_launcher.installer.Page page = 3;
inline void ErrorEncountered::clear_page() {
  page_ = 0;
}
inline ::eve_launcher::installer::Page ErrorEncountered::page() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ErrorEncountered.page)
  return static_cast< ::eve_launcher::installer::Page >(page_);
}
inline void ErrorEncountered::set_page(::eve_launcher::installer::Page value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ErrorEncountered.page)
}

// .eve_launcher.installer.Component component = 4;
inline void ErrorEncountered::clear_component() {
  component_ = 0;
}
inline ::eve_launcher::installer::Component ErrorEncountered::component() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ErrorEncountered.component)
  return static_cast< ::eve_launcher::installer::Component >(component_);
}
inline void ErrorEncountered::set_component(::eve_launcher::installer::Component value) {
  
  component_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ErrorEncountered.component)
}

// .eve_launcher.installer.RedistVersion redist_version = 5;
inline void ErrorEncountered::clear_redist_version() {
  redist_version_ = 0;
}
inline ::eve_launcher::installer::RedistVersion ErrorEncountered::redist_version() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.ErrorEncountered.redist_version)
  return static_cast< ::eve_launcher::installer::RedistVersion >(redist_version_);
}
inline void ErrorEncountered::set_redist_version(::eve_launcher::installer::RedistVersion value) {
  
  redist_version_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.ErrorEncountered.redist_version)
}

// -------------------------------------------------------------------

// IPAddress

// fixed32 v4 = 1;
inline bool IPAddress::has_v4() const {
  return version_case() == kV4;
}
inline void IPAddress::set_has_v4() {
  _oneof_case_[0] = kV4;
}
inline void IPAddress::clear_v4() {
  if (has_v4()) {
    version_.v4_ = 0u;
    clear_has_version();
  }
}
inline ::google::protobuf::uint32 IPAddress::v4() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.IPAddress.v4)
  if (has_v4()) {
    return version_.v4_;
  }
  return 0u;
}
inline void IPAddress::set_v4(::google::protobuf::uint32 value) {
  if (!has_v4()) {
    clear_version();
    set_has_v4();
  }
  version_.v4_ = value;
  // @@protoc_insertion_point(field_set:eve_launcher.installer.IPAddress.v4)
}

// bytes v6 = 2;
inline bool IPAddress::has_v6() const {
  return version_case() == kV6;
}
inline void IPAddress::set_has_v6() {
  _oneof_case_[0] = kV6;
}
inline void IPAddress::clear_v6() {
  if (has_v6()) {
    version_.v6_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_version();
  }
}
inline const ::std::string& IPAddress::v6() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.IPAddress.v6)
  if (has_v6()) {
    return version_.v6_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void IPAddress::set_v6(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.installer.IPAddress.v6)
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.IPAddress.v6)
}
#if LANG_CXX11
inline void IPAddress::set_v6(::std::string&& value) {
  // @@protoc_insertion_point(field_set:eve_launcher.installer.IPAddress.v6)
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.IPAddress.v6)
}
#endif
inline void IPAddress::set_v6(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.IPAddress.v6)
}
inline void IPAddress::set_v6(const void* value, size_t size) {
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  version_.v6_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.IPAddress.v6)
}
inline ::std::string* IPAddress::mutable_v6() {
  if (!has_v6()) {
    clear_version();
    set_has_v6();
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.IPAddress.v6)
  return version_.v6_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IPAddress::release_v6() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.IPAddress.v6)
  if (has_v6()) {
    clear_has_version();
    return version_.v6_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void IPAddress::set_allocated_v6(::std::string* v6) {
  if (!has_v6()) {
    version_.v6_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_version();
  if (v6 != NULL) {
    set_has_v6();
    version_.v6_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), v6);
  }
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.IPAddress.v6)
}

inline bool IPAddress::has_version() const {
  return version_case() != VERSION_NOT_SET;
}
inline void IPAddress::clear_has_version() {
  _oneof_case_[0] = VERSION_NOT_SET;
}
inline IPAddress::VersionCase IPAddress::version_case() const {
  return IPAddress::VersionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// .google.protobuf.Timestamp created = 1;
inline bool Event::has_created() const {
  return this != internal_default_instance() && created_ != NULL;
}
inline const ::google::protobuf::Timestamp& Event::_internal_created() const {
  return *created_;
}
inline const ::google::protobuf::Timestamp& Event::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.created)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Event::release_created() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Event::mutable_created() {
  
  if (created_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.created)
  return created_;
}
inline void Event::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.created)
}

// bytes uuid = 2;
inline void Event::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::uuid() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.uuid)
  return uuid_.GetNoArena();
}
inline void Event::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Event.uuid)
}
#if LANG_CXX11
inline void Event::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.Event.uuid)
}
#endif
inline void Event::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.Event.uuid)
}
inline void Event::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.Event.uuid)
}
inline ::std::string* Event::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_uuid() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.uuid)
}

// .eve_launcher.installer.IPAddress ip_address = 3;
inline bool Event::has_ip_address() const {
  return this != internal_default_instance() && ip_address_ != NULL;
}
inline void Event::clear_ip_address() {
  if (GetArenaNoVirtual() == NULL && ip_address_ != NULL) {
    delete ip_address_;
  }
  ip_address_ = NULL;
}
inline const ::eve_launcher::installer::IPAddress& Event::_internal_ip_address() const {
  return *ip_address_;
}
inline const ::eve_launcher::installer::IPAddress& Event::ip_address() const {
  const ::eve_launcher::installer::IPAddress* p = ip_address_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.ip_address)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_launcher::installer::IPAddress*>(
      &::eve_launcher::installer::_IPAddress_default_instance_);
}
inline ::eve_launcher::installer::IPAddress* Event::release_ip_address() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.ip_address)
  
  ::eve_launcher::installer::IPAddress* temp = ip_address_;
  ip_address_ = NULL;
  return temp;
}
inline ::eve_launcher::installer::IPAddress* Event::mutable_ip_address() {
  
  if (ip_address_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_launcher::installer::IPAddress>(GetArenaNoVirtual());
    ip_address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.ip_address)
  return ip_address_;
}
inline void Event::set_allocated_ip_address(::eve_launcher::installer::IPAddress* ip_address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ip_address_;
  }
  if (ip_address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ip_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ip_address, submessage_arena);
    }
    
  } else {
    
  }
  ip_address_ = ip_address;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.ip_address)
}

// string tenant = 4;
inline void Event::clear_tenant() {
  tenant_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::tenant() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.tenant)
  return tenant_.GetNoArena();
}
inline void Event::set_tenant(const ::std::string& value) {
  
  tenant_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Event.tenant)
}
#if LANG_CXX11
inline void Event::set_tenant(::std::string&& value) {
  
  tenant_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.Event.tenant)
}
#endif
inline void Event::set_tenant(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tenant_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.Event.tenant)
}
inline void Event::set_tenant(const char* value, size_t size) {
  
  tenant_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.Event.tenant)
}
inline ::std::string* Event::mutable_tenant() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.tenant)
  return tenant_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_tenant() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.tenant)
  
  return tenant_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_tenant(::std::string* tenant) {
  if (tenant != NULL) {
    
  } else {
    
  }
  tenant_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tenant);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.tenant)
}

// .google.protobuf.Any payload = 5;
inline bool Event::has_payload() const {
  return this != internal_default_instance() && payload_ != NULL;
}
inline const ::google::protobuf::Any& Event::_internal_payload() const {
  return *payload_;
}
inline const ::google::protobuf::Any& Event::payload() const {
  const ::google::protobuf::Any* p = payload_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.payload)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Event::release_payload() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.payload)
  
  ::google::protobuf::Any* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* Event::mutable_payload() {
  
  if (payload_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.payload)
  return payload_;
}
inline void Event::set_allocated_payload(::google::protobuf::Any* payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(payload_);
  }
  if (payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.payload)
}

// bytes journey = 6;
inline void Event::clear_journey() {
  journey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::journey() const {
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.journey)
  return journey_.GetNoArena();
}
inline void Event::set_journey(const ::std::string& value) {
  
  journey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_launcher.installer.Event.journey)
}
#if LANG_CXX11
inline void Event::set_journey(::std::string&& value) {
  
  journey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_launcher.installer.Event.journey)
}
#endif
inline void Event::set_journey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  journey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_launcher.installer.Event.journey)
}
inline void Event::set_journey(const void* value, size_t size) {
  
  journey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_launcher.installer.Event.journey)
}
inline ::std::string* Event::mutable_journey() {
  
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.journey)
  return journey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_journey() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.journey)
  
  return journey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_journey(::std::string* journey) {
  if (journey != NULL) {
    
  } else {
    
  }
  journey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), journey);
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.journey)
}

// .google.protobuf.Timestamp reveived = 7;
inline bool Event::has_reveived() const {
  return this != internal_default_instance() && reveived_ != NULL;
}
inline const ::google::protobuf::Timestamp& Event::_internal_reveived() const {
  return *reveived_;
}
inline const ::google::protobuf::Timestamp& Event::reveived() const {
  const ::google::protobuf::Timestamp* p = reveived_;
  // @@protoc_insertion_point(field_get:eve_launcher.installer.Event.reveived)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Event::release_reveived() {
  // @@protoc_insertion_point(field_release:eve_launcher.installer.Event.reveived)
  
  ::google::protobuf::Timestamp* temp = reveived_;
  reveived_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Event::mutable_reveived() {
  
  if (reveived_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    reveived_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_launcher.installer.Event.reveived)
  return reveived_;
}
inline void Event::set_allocated_reveived(::google::protobuf::Timestamp* reveived) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reveived_);
  }
  if (reveived) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reveived)->GetArena();
    if (message_arena != submessage_arena) {
      reveived = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reveived, submessage_arena);
    }
    
  } else {
    
  }
  reveived_ = reveived;
  // @@protoc_insertion_point(field_set_allocated:eve_launcher.installer.Event.reveived)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace installer
}  // namespace eve_launcher

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eve_launcher::installer::Application_BuildType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::Application_BuildType>() {
  return ::eve_launcher::installer::Application_BuildType_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::Application_Locale> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::Application_Locale>() {
  return ::eve_launcher::installer::Application_Locale_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::Application_ApplicationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::Application_ApplicationType>() {
  return ::eve_launcher::installer::Application_ApplicationType_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::PageDisplayed_FlowDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::PageDisplayed_FlowDirection>() {
  return ::eve_launcher::installer::PageDisplayed_FlowDirection_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::UserCancelled_Progress> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::UserCancelled_Progress>() {
  return ::eve_launcher::installer::UserCancelled_Progress_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::ShutDown_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::ShutDown_State>() {
  return ::eve_launcher::installer::ShutDown_State_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::LocationChanged_Source> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::LocationChanged_Source>() {
  return ::eve_launcher::installer::LocationChanged_Source_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::LocationChanged_Provider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::LocationChanged_Provider>() {
  return ::eve_launcher::installer::LocationChanged_Provider_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::RedistSearchConcluded_RedistReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::RedistSearchConcluded_RedistReason>() {
  return ::eve_launcher::installer::RedistSearchConcluded_RedistReason_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton>() {
  return ::eve_launcher::installer::MessageBoxClosed_MessageBoxButton_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::StepExecuted_Step> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::StepExecuted_Step>() {
  return ::eve_launcher::installer::StepExecuted_Step_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::ErrorEncountered_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::ErrorEncountered_ErrorCode>() {
  return ::eve_launcher::installer::ErrorEncountered_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::Page> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::Page>() {
  return ::eve_launcher::installer::Page_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::RedistVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::RedistVersion>() {
  return ::eve_launcher::installer::RedistVersion_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::MessageBox> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::MessageBox>() {
  return ::eve_launcher::installer::MessageBox_descriptor();
}
template <> struct is_proto_enum< ::eve_launcher::installer::Component> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_launcher::installer::Component>() {
  return ::eve_launcher::installer::Component_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_eve_5flauncher_2finstaller_2eproto
